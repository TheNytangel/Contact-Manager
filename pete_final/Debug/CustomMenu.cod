; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	S:\Chris\OneDrive - UAT\C++ Programming II\pete_final\pete_final\CustomMenu.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	??1_Container_base12@std@@QAE@XZ		; std::_Container_base12::~_Container_base12
PUBLIC	?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Clrcont@_Iterator_base12@std@@QAEXXZ		; std::_Iterator_base12::_Clrcont
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ	; std::_Iterator_base12::_Getpnext
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ; std::_Wrap_alloc<std::allocator<char> >::address
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::operator=
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC	?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??8Option@CCustomMenu@@QBE_NABD@Z		; CCustomMenu::Option::operator==
PUBLIC	??MOption@CCustomMenu@@QBE_NABU01@@Z		; CCustomMenu::Option::operator<
PUBLIC	??0Option@CCustomMenu@@QAE@XZ			; CCustomMenu::Option::Option
PUBLIC	??1Option@CCustomMenu@@QAE@XZ			; CCustomMenu::Option::~Option
PUBLIC	??0Option@CCustomMenu@@QAE@ABU01@@Z		; CCustomMenu::Option::Option
PUBLIC	??0Option@CCustomMenu@@QAE@$$QAU01@@Z		; CCustomMenu::Option::Option
PUBLIC	??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z	; CCustomMenu::Option::operator=
PUBLIC	??_GOption@CCustomMenu@@QAEPAXI@Z		; CCustomMenu::Option::`scalar deleting destructor'
PUBLIC	??0?$allocator@UOption@CCustomMenu@@@std@@QAE@XZ ; std::allocator<CCustomMenu::Option>::allocator<CCustomMenu::Option>
PUBLIC	?deallocate@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@I@Z ; std::allocator<CCustomMenu::Option>::deallocate
PUBLIC	?allocate@?$allocator@UOption@CCustomMenu@@@std@@QAEPAUOption@CCustomMenu@@I@Z ; std::allocator<CCustomMenu::Option>::allocate
PUBLIC	?max_size@?$allocator@UOption@CCustomMenu@@@std@@QBEIXZ ; std::allocator<CCustomMenu::Option>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAIABV?$allocator@UOption@CCustomMenu@@@2@@Z ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::_Wrap_alloc<std::allocator<CCustomMenu::Option> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEPAUOption@CCustomMenu@@I@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@I@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::max_size
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >
PUBLIC	??1?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::~_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Free_proxy
PUBLIC	?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getpfirst
PUBLIC	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myproxy
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >::_Vector_val<std::_Simple_types<CCustomMenu::Option> >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >::~_Vector_val<std::_Simple_types<CCustomMenu::Option> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>
PUBLIC	??0?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >
PUBLIC	??1?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::~vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >
PUBLIC	?capacity@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::capacity
PUBLIC	?_Unused_capacity@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Unused_capacity
PUBLIC	?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::begin
PUBLIC	?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::end
PUBLIC	?size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::size
PUBLIC	?max_size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::max_size
PUBLIC	?push_back@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXABUOption@CCustomMenu@@@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::push_back
PUBLIC	?_Destroy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXPAUOption@CCustomMenu@@0@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Destroy
PUBLIC	?_Grow_to@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEII@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Grow_to
PUBLIC	?_Inside@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBE_NPBUOption@CCustomMenu@@@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Inside
PUBLIC	?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Reserve
PUBLIC	?_Tidy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Tidy
PUBLIC	?_Xlen@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Orphan_range
PUBLIC	??0CCustomMenu@@QAE@XZ				; CCustomMenu::CCustomMenu
PUBLIC	??1CCustomMenu@@QAE@XZ				; CCustomMenu::~CCustomMenu
PUBLIC	?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CCustomMenu::addMenuOption
PUBLIC	?displayMenuOptions@CCustomMenu@@QAEXXZ		; CCustomMenu::displayMenuOptions
PUBLIC	?contains@CCustomMenu@@QAE_ND@Z			; CCustomMenu::contains
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABUOption@CCustomMenu@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator*
PUBLIC	??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPBUOption@CCustomMenu@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator->
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator!=
PUBLIC	??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator<
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@$$QAV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV12@PAUOption@CCustomMenu@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPAUOption@CCustomMenu@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Unchecked
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >,char>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	?pointer_to@?$pointer_traits@PBUOption@CCustomMenu@@@std@@SAPBUOption@CCustomMenu@@ABU34@@Z ; std::pointer_traits<CCustomMenu::Option const *>::pointer_to
PUBLIC	??$addressof@$$CBUOption@CCustomMenu@@@std@@YAPBUOption@CCustomMenu@@ABU12@@Z ; std::addressof<CCustomMenu::Option const >
PUBLIC	??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unfancy<CCustomMenu::Option>
PUBLIC	??$construct@UOption@CCustomMenu@@AAU12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option &>
PUBLIC	??$construct@UOption@CCustomMenu@@ABU12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option const &>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@$$QAU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
PUBLIC	??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
PUBLIC	?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
PUBLIC	??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@$$QAV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1><>
PUBLIC	??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z	; std::_Debug_pointer_if<char const >
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$?0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<CCustomMenu::Option> > &>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Umove@PAUOption@CCustomMenu@@@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEPAUOption@CCustomMenu@@PAU23@00@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Umove<CCustomMenu::Option *>
PUBLIC	??$_Destroy_range@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<CCustomMenu::Option>,CCustomMenu::Option *>
PUBLIC	??$?0AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > &>
PUBLIC	?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ; std::pointer_traits<std::_Container_proxy *>::pointer_to
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
PUBLIC	??$_Find_unchecked@PAUOption@CCustomMenu@@D@std@@YAPAUOption@CCustomMenu@@PAU12@0ABD@Z ; std::_Find_unchecked<CCustomMenu::Option *,char>
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@AAV10@PAUOption@CCustomMenu@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >,std::less<void> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$forward@AAUOption@CCustomMenu@@@std@@YAAAUOption@CCustomMenu@@AAU12@@Z ; std::forward<CCustomMenu::Option &>
PUBLIC	??$construct@UOption@CCustomMenu@@AAU12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@AAU34@@Z ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option &>
PUBLIC	??$forward@ABUOption@CCustomMenu@@@std@@YAABUOption@CCustomMenu@@ABU12@@Z ; std::forward<CCustomMenu::Option const &>
PUBLIC	??$construct@UOption@CCustomMenu@@ABU12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@ABU34@@Z ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option const &>
PUBLIC	??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator==<std::allocator<char>,std::allocator<char> >
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$forward@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> > &>
PUBLIC	??$?0UOption@CCustomMenu@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UOption@CCustomMenu@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><CCustomMenu::Option>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Uninitialized_move@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z ; std::_Uninitialized_move<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >
PUBLIC	??$_Destroy_range1@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<CCustomMenu::Option>,CCustomMenu::Option *>
PUBLIC	??$forward@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > &>
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
PUBLIC	??$_Find_unchecked1@PAUOption@CCustomMenu@@D@std@@YAPAUOption@CCustomMenu@@PAU12@0ABDU?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<CCustomMenu::Option *,char>
PUBLIC	??$_Sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Sort_unchecked<CCustomMenu::Option *,std::less<void> >
PUBLIC	??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option &>
PUBLIC	??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option const &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Unchecked@PAUOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unchecked<CCustomMenu::Option *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >
PUBLIC	??$_Rechecked@PAUOption@CCustomMenu@@PAU12@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@PAU12@@Z ; std::_Rechecked<CCustomMenu::Option *,CCustomMenu::Option *>
PUBLIC	??$destroy@UOption@CCustomMenu@@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::destroy<CCustomMenu::Option>
PUBLIC	??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
PUBLIC	??$_Sort_unchecked1@PAUOption@CCustomMenu@@HU?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<CCustomMenu::Option *,int,std::less<void> >
PUBLIC	??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
PUBLIC	??$_Ptr_move_cat@UOption@CCustomMenu@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUOption@CCustomMenu@@0@Z ; std::_Ptr_move_cat<CCustomMenu::Option,CCustomMenu::Option>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >
PUBLIC	??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
PUBLIC	??$destroy@UOption@CCustomMenu@@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@@Z ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::destroy<CCustomMenu::Option>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YA?AU?$pair@PAUOption@CCustomMenu@@PAU12@@0@PAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<CCustomMenu::Option *,std::less<void> >
PUBLIC	??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Make_heap_unchecked<CCustomMenu::Option *,std::less<void> >
PUBLIC	??$_Sort_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Sort_heap_unchecked<CCustomMenu::Option *,std::less<void> >
PUBLIC	??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Insertion_sort_unchecked<CCustomMenu::Option *,std::less<void> >
PUBLIC	??$construct@UOption@CCustomMenu@@U12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@$$QAU23@@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option>
PUBLIC	??$destroy@UOption@CCustomMenu@@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@@Z ; std::allocator<CCustomMenu::Option>::destroy<CCustomMenu::Option>
PUBLIC	??$_Guess_median_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z ; std::_Guess_median_unchecked<CCustomMenu::Option *,std::less<void> >
PUBLIC	??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
PUBLIC	??$?RAAUOption@CCustomMenu@@AAU01@@?$less@X@std@@QBE_NAAUOption@CCustomMenu@@0@Z ; std::less<void>::operator()<CCustomMenu::Option &,CCustomMenu::Option &>
PUBLIC	??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
PUBLIC	??$?0AAPAUOption@CCustomMenu@@AAPAU01@X$0A@@?$pair@PAUOption@CCustomMenu@@PAU12@@std@@QAE@AAPAUOption@CCustomMenu@@0@Z ; std::pair<CCustomMenu::Option *,CCustomMenu::Option *>::pair<CCustomMenu::Option *,CCustomMenu::Option *><CCustomMenu::Option * &,CCustomMenu::Option * &,void,0>
PUBLIC	??$_Pop_heap_hole_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<CCustomMenu::Option *,int,CCustomMenu::Option,std::less<void> >
PUBLIC	??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Pop_heap_unchecked<CCustomMenu::Option *,std::less<void> >
PUBLIC	??$_Move_backward_unchecked@PAUOption@CCustomMenu@@PAU12@@std@@YAPAUOption@CCustomMenu@@PAU12@00@Z ; std::_Move_backward_unchecked<CCustomMenu::Option *,CCustomMenu::Option *>
PUBLIC	??$forward@UOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::forward<CCustomMenu::Option>
PUBLIC	??$construct@UOption@CCustomMenu@@U12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@$$QAU34@@Z ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option>
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
PUBLIC	??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
PUBLIC	??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ; std::pointer_traits<char *>::pointer_to
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Med3_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z ; std::_Med3_unchecked<CCustomMenu::Option *,std::less<void> >
PUBLIC	??$swap@UOption@CCustomMenu@@X@std@@YAXAAUOption@CCustomMenu@@0@Z ; std::swap<CCustomMenu::Option,void>
PUBLIC	??$forward@AAPAUOption@CCustomMenu@@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@@Z ; std::forward<CCustomMenu::Option * &>
PUBLIC	??$_Push_heap_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z ; std::_Push_heap_by_index<CCustomMenu::Option *,int,CCustomMenu::Option,std::less<void> >
PUBLIC	??$_Pop_heap_hole_unchecked@PAUOption@CCustomMenu@@U12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00$$QAU12@AAU?$less@X@0@@Z ; std::_Pop_heap_hole_unchecked<CCustomMenu::Option *,CCustomMenu::Option,std::less<void> >
PUBLIC	??$_Move_backward_unchecked1@PAUOption@CCustomMenu@@PAU12@@std@@YAPAUOption@CCustomMenu@@PAU12@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_backward_unchecked1<CCustomMenu::Option *,CCustomMenu::Option *>
PUBLIC	??$construct@UOption@CCustomMenu@@U12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@$$QAU23@@Z ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option>
PUBLIC	??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$_Unfancy@$$CBD@std@@YAPBDPBD@Z		; std::_Unfancy<char const >
PUBLIC	??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA	; `std::_Allocate'::`1'::__LINE__Var
PUBLIC	??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@	; `string'
PUBLIC	??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA ; `std::_Deallocate'::`1'::__LINE__Var
PUBLIC	??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@ ; `string'
PUBLIC	??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@ ; `string'
PUBLIC	??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@ ; `string'
PUBLIC	??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@ ; `string'
PUBLIC	??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@ ; `string'
PUBLIC	??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@ ; `string'
PUBLIC	??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ ; `string'
PUBLIC	??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@ ; `string'
PUBLIC	??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@ ; `string'
PUBLIC	??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@ ; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_C@_03KOEIKCBF@?$CJ?5?5?$AA@			; `string'
PUBLIC	??_C@_01GPOEFGEJ@?7?$AA@			; `string'
PUBLIC	??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; `string'
PUBLIC	??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; `string'
PUBLIC	??_C@_1PE@FEBODMLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IO@EADHKMNI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; `string'
PUBLIC	??_C@_1PC@BPDPMBHD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; `string'
PUBLIC	??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; `string'
PUBLIC	??_C@_1OM@HACCCHHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1CG@LEJCKCBB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; `string'
PUBLIC	??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	_strlen:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp__toupper:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
CONST	SEGMENT
??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ DB 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, '_', 00H, 'C', 00H, 'o', 00H, 'm'
	DB	00H, 'p', 00H, 'a', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LEJCKCBB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@LEJCKCBB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 'l', 00H, 'g'
	DB	00H, 'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'm', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1OM@HACCCHHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OM@HACCCHHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'C', 00H
	DB	'C', 00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, 'M'
	DB	00H, 'e', 00H, 'n', 00H, 'u', 00H, ':', 00H, ':', 00H, 'O', 00H
	DB	'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
CONST	SEGMENT
??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 'A', 00H
	DB	'r', 00H, 'g', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
CONST	SEGMENT
??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ DB 'Standa'
	DB	'rd C++ Libraries Invalid Argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1PC@BPDPMBHD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1PC@BPDPMBHD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'C', 00H
	DB	'C', 00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, 'M'
	DB	00H, 'e', 00H, 'n', 00H, 'u', 00H, ':', 00H, ':', 00H, 'O', 00H
	DB	'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '*', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
CONST	SEGMENT
??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1IO@EADHKMNI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@EADHKMNI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1PE@FEBODMLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1PE@FEBODMLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'C', 00H
	DB	'C', 00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, 'M'
	DB	00H, 'e', 00H, 'n', 00H, 'u', 00H, ':', 00H, ':', 00H, 'O', 00H
	DB	'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
CONST	SEGMENT
??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'R', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
CONST	SEGMENT
??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ DB 'Stand'
	DB	'ard C++ Libraries Out of Range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01GPOEFGEJ@?7?$AA@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7?$AA@ DB 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KOEIKCBF@?$CJ?5?5?$AA@
CONST	SEGMENT
??_C@_03KOEIKCBF@?$CJ?5?5?$AA@ DB ')  ', 00H		; `string'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@
CONST	SEGMENT
??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '-', 00H, ' ', 00H, '_'
	DB	00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '_', 00H, 'N', 00H
	DB	'O', 00H, 'N', 00H, '_', 00H, 'U', 00H, 'S', 00H, 'E', 00H, 'R'
	DB	00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '"', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@
CONST	SEGMENT
??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@ DB '_Ptr_u'
	DB	'ser - _Ptr_container <= _NON_USER_SIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@
CONST	SEGMENT
??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@ DB '"'
	DB	00H, '2', 00H, ' ', 00H, '*', 00H, ' ', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H, 'v', 00H, 'o'
	DB	00H, 'i', 00H, 'd', 00H, ' ', 00H, '*', 00H, ')', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r'
	DB	00H, '_', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H
	DB	'n', 00H, 'e', 00H, 'r', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@
CONST	SEGMENT
??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@ DB '2'
	DB	' * sizeof(void *) <= _Ptr_user - _Ptr_container', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '<', 00H, ' ', 00H, '_', 00H, 'P', 00H
	DB	't', 00H, 'r', 00H, '_', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@
CONST	SEGMENT
??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@ DB '_Ptr_containe'
	DB	'r < _Ptr_user', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@
CONST	SEGMENT
??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@ DB '"'
	DB	00H, 'r', 00H, 'e', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 't', 00H, '_', 00H, 'c'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, '<', 00H, 'u', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, 'p', 00H, 't', 00H, 'r', 00H, '_', 00H, 't'
	DB	00H, ' ', 00H, '*', 00H, '>', 00H, '(', 00H, '_', 00H, 'P', 00H
	DB	't', 00H, 'r', 00H, '_', 00H, 'p', 00H, 't', 00H, 'r', 00H, ')'
	DB	00H, '[', 00H, '-', 00H, '1', 00H, ']', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '_', 00H, 'B', 00H, 'I', 00H, 'G', 00H, '_'
	DB	00H, 'A', 00H, 'L', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'A', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H, 'E'
	DB	00H, 'N', 00H, 'T', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 'L', 00H
	DB	'"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@
CONST	SEGMENT
??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@ DB 'rei'
	DB	'nterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_S'
	DB	'ENTINEL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@
CONST	SEGMENT
??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@ DB '"'
	DB	00H, '(', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H
	DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '&', 00H, ' '
	DB	00H, '(', 00H, '_', 00H, 'B', 00H, 'I', 00H, 'G', 00H, '_', 00H
	DB	'A', 00H, 'L', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'A', 00H, 'T'
	DB	00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'A', 00H, 'L', 00H
	DB	'I', 00H, 'G', 00H, 'N', 00H, 'M', 00H, 'E', 00H, 'N', 00H, 'T'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, '1', 00H, ')', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, '"', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@
CONST	SEGMENT
??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@ DB '(_Ptr'
	DB	'_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@ DB '"'
	DB	00H, '_', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '(', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H
	DB	'-', 00H, '1', 00H, ')', 00H, ' ', 00H, '/', 00H, ' ', 00H, '_'
	DB	00H, 'S', 00H, 'z', 00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@
CONST	SEGMENT
??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@ DB '_'
	DB	'Count <= (size_t)(-1) / _Sz', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA DD 05cH ; `std::_Deallocate'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@ DB '_Ptr != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ DB '%', 00H, 'l', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	'"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@ DB '_Ptr_container !='
	DB	' 0', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA DD 030H	; `std::_Allocate'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ DB 'I'
	DB	00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H, 'O', 00H
	DB	'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T', 00H, ' '
	DB	00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H, 'P', 00H
	DB	'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H, 't'
	DB	00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$4
	DD	07H
	DD	FLAT:__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z$0
__ehfuncinfo$??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z$0
__ehfuncinfo$??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z$0
__ehfuncinfo$??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
__unwindtable$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$2
__ehfuncinfo$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z$0
__ehfuncinfo$??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z$0
__ehfuncinfo$??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z$2
__ehfuncinfo$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z$2
__ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z$0
__ehfuncinfo$??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
__tryblocktable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3
__unwindtable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z$2
__ehfuncinfo$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z$2
__ehfuncinfo$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?contains@CCustomMenu@@QAE_ND@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?contains@CCustomMenu@@QAE_ND@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?contains@CCustomMenu@@QAE_ND@Z$3
__ehfuncinfo$?contains@CCustomMenu@@QAE_ND@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?contains@CCustomMenu@@QAE_ND@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?displayMenuOptions@CCustomMenu@@QAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?displayMenuOptions@CCustomMenu@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?displayMenuOptions@CCustomMenu@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?displayMenuOptions@CCustomMenu@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?displayMenuOptions@CCustomMenu@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?displayMenuOptions@CCustomMenu@@QAEXXZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?displayMenuOptions@CCustomMenu@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?displayMenuOptions@CCustomMenu@@QAEXXZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$5
__ehfuncinfo$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
__ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
__ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Container_base12@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@$$CBD@std@@YAPBDPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@$$CBD@std@@YAPBDPBD@Z PROC			; std::_Unfancy<char const >, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 740  : 	return (_Ptr);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Unfancy@$$CBD@std@@YAPBDPBD@Z ENDP			; std::_Unfancy<char const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1051 : 	{	// propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00020	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1052 : 	_Left = _STD move(_Right);

  0003d	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0004d	e8 00 00 00 00	 call	 ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::operator=

; 1053 : 	}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UOption@CCustomMenu@@U12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@$$QAU23@@Z
_TEXT	SEGMENT
tv76 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UOption@CCustomMenu@@U12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@$$QAU23@@Z PROC ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	6a 20		 push	 32			; 00000020H
  00029	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0002e	83 c4 08	 add	 esp, 8
  00031	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00037	83 bd 2c ff ff
	ff 00		 cmp	 DWORD PTR $T1[ebp], 0
  0003e	74 20		 je	 SHORT $LN3@construct
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 ??$forward@UOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::forward<CCustomMenu::Option>
  00049	83 c4 04	 add	 esp, 4
  0004c	50		 push	 eax
  0004d	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00053	e8 00 00 00 00	 call	 ??0Option@CCustomMenu@@QAE@$$QAU01@@Z
  00058	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  0005e	eb 0a		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00060	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv76[ebp], 0
$LN1@construct:

; 738  : 		}

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
??$construct@UOption@CCustomMenu@@U12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@$$QAU23@@Z ENDP ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_backward_unchecked1@PAUOption@CCustomMenu@@PAU12@@std@@YAPAUOption@CCustomMenu@@PAU12@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_backward_unchecked1@PAUOption@CCustomMenu@@PAU12@@std@@YAPAUOption@CCustomMenu@@PAU12@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward_unchecked1<CCustomMenu::Option *,CCustomMenu::Option *>, COMDAT

; 2658 : 	{	// move [_First, _Last) backwards to [..., _Dest), no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
$LN2@Move_backw:

; 2659 : 	while (_First != _Last)

  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00024	74 29		 je	 SHORT $LN3@Move_backw

; 2660 : 		*--_Dest = _STD move(*--_Last);

  00026	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00029	83 e8 20	 sub	 eax, 32			; 00000020H
  0002c	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	83 e9 20	 sub	 ecx, 32			; 00000020H
  00035	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00038	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00041	83 c4 04	 add	 esp, 4
  00044	50		 push	 eax
  00045	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00048	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z
  0004d	eb cf		 jmp	 SHORT $LN2@Move_backw
$LN3@Move_backw:

; 2661 : 	return (_Dest);

  0004f	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2662 : 	}

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
??$_Move_backward_unchecked1@PAUOption@CCustomMenu@@PAU12@@std@@YAPAUOption@CCustomMenu@@PAU12@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward_unchecked1<CCustomMenu::Option *,CCustomMenu::Option *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAUOption@CCustomMenu@@U12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00$$QAU12@AAU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Pop_heap_hole_unchecked@PAUOption@CCustomMenu@@U12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00$$QAU12@AAU?$less@X@0@@Z PROC ; std::_Pop_heap_hole_unchecked<CCustomMenu::Option *,CCustomMenu::Option,std::less<void> >, COMDAT

; 2067 : 	{	// pop *_First to *_Dest and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2068 : 		// precondition: _First != _Last
; 2069 : 		// precondition: _First != _Dest
; 2070 : 	*_Dest = _STD move(*_First);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0002e	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z

; 2071 : 	_Pop_heap_hole_by_index(_First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First),

  00033	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00040	83 c4 04	 add	 esp, 4
  00043	50		 push	 eax
  00044	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00047	2b 55 08	 sub	 edx, DWORD PTR __First$[ebp]
  0004a	c1 fa 05	 sar	 edx, 5
  0004d	52		 push	 edx
  0004e	6a 00		 push	 0
  00050	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<CCustomMenu::Option *,int,CCustomMenu::Option,std::less<void> >
  00059	83 c4 14	 add	 esp, 20			; 00000014H

; 2072 : 		_STD move(_Val), _Pred);
; 2073 : 	}

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??$_Pop_heap_hole_unchecked@PAUOption@CCustomMenu@@U12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00$$QAU12@AAU?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_unchecked<CCustomMenu::Option *,CCustomMenu::Option,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z
_TEXT	SEGMENT
__Idx$1 = -8						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Push_heap_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z PROC ; std::_Push_heap_by_index<CCustomMenu::Option *,int,CCustomMenu::Option,std::less<void> >, COMDAT

; 1989 : 	{	// percolate _Hole to _Top or where _Val belongs, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1990 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00021	83 e8 01	 sub	 eax, 1
  00024	99		 cdq
  00025	2b c2		 sub	 eax, edx
  00027	d1 f8		 sar	 eax, 1
  00029	89 45 f8	 mov	 DWORD PTR __Idx$1[ebp], eax
  0002c	eb 0e		 jmp	 SHORT $LN4@Push_heap_
$LN2@Push_heap_:

; 1992 : 		_Idx = (_Hole - 1) / 2)

  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00031	83 e8 01	 sub	 eax, 1
  00034	99		 cdq
  00035	2b c2		 sub	 eax, edx
  00037	d1 f8		 sar	 eax, 1
  00039	89 45 f8	 mov	 DWORD PTR __Idx$1[ebp], eax
$LN4@Push_heap_:

; 1991 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);

  0003c	8b 45 10	 mov	 eax, DWORD PTR __Top$[ebp]
  0003f	3b 45 0c	 cmp	 eax, DWORD PTR __Hole$[ebp]
  00042	7d 54		 jge	 SHORT $LN3@Push_heap_
  00044	68 c7 07 00 00	 push	 1991			; 000007c7H
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0004e	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00051	50		 push	 eax
  00052	8b 4d f8	 mov	 ecx, DWORD PTR __Idx$1[ebp]
  00055	c1 e1 05	 shl	 ecx, 5
  00058	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 18	 mov	 edx, DWORD PTR __Pred$[ebp]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  00065	83 c4 14	 add	 esp, 20			; 00000014H
  00068	0f b6 c0	 movzx	 eax, al
  0006b	85 c0		 test	 eax, eax
  0006d	74 29		 je	 SHORT $LN3@Push_heap_

; 1993 : 		{	// move _Hole up to parent
; 1994 : 		*(_First + _Hole) = _STD move(*(_First + _Idx));

  0006f	8b 45 f8	 mov	 eax, DWORD PTR __Idx$1[ebp]
  00072	c1 e0 05	 shl	 eax, 5
  00075	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  0007e	83 c4 04	 add	 esp, 4
  00081	50		 push	 eax
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  00085	c1 e1 05	 shl	 ecx, 5
  00088	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  0008b	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z

; 1995 : 		_Hole = _Idx;

  00090	8b 45 f8	 mov	 eax, DWORD PTR __Idx$1[ebp]
  00093	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 1996 : 		}

  00096	eb 96		 jmp	 SHORT $LN2@Push_heap_
$LN3@Push_heap_:

; 1997 : 
; 1998 : 	*(_First + _Hole) = _STD move(_Val);	// drop _Val into final hole

  00098	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  000a1	83 c4 04	 add	 esp, 4
  000a4	50		 push	 eax
  000a5	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  000a8	c1 e1 05	 shl	 ecx, 5
  000ab	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  000ae	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z

; 1999 : 	}

  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000bc	3b ec		 cmp	 ebp, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
??$_Push_heap_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z ENDP ; std::_Push_heap_by_index<CCustomMenu::Option *,int,CCustomMenu::Option,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAUOption@CCustomMenu@@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUOption@CCustomMenu@@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@@Z PROC ; std::forward<CCustomMenu::Option * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@AAPAUOption@CCustomMenu@@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@@Z ENDP ; std::forward<CCustomMenu::Option * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@UOption@CCustomMenu@@X@std@@YAXAAUOption@CCustomMenu@@0@Z
_TEXT	SEGMENT
__Tmp$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UOption@CCustomMenu@@X@std@@YAXAAUOption@CCustomMenu@@0@Z PROC ; std::swap<CCustomMenu::Option,void>, COMDAT

; 48   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00012	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 49   : 	_Ty _Tmp = _STD move(_Left);

  00028	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8d 4d d8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00038	e8 00 00 00 00	 call	 ??0Option@CCustomMenu@@QAE@$$QAU01@@Z

; 50   : 	_Left = _STD move(_Right);

  0003d	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0004d	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z

; 51   : 	_Right = _STD move(_Tmp);

  00052	8d 45 d8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  0005b	83 c4 04	 add	 esp, 4
  0005e	50		 push	 eax
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00062	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z

; 52   : 	}

  00067	8d 4d d8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0006a	e8 00 00 00 00	 call	 ??1Option@CCustomMenu@@QAE@XZ
  0006f	52		 push	 edx
  00070	8b cd		 mov	 ecx, ebp
  00072	50		 push	 eax
  00073	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@swap
  00079	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007e	58		 pop	 eax
  0007f	5a		 pop	 edx
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00086	33 cd		 xor	 ecx, ebp
  00088	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008d	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
  0009e	66 90		 npad	 2
$LN5@swap:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN4@swap
$LN4@swap:
  000a8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  000ac	20 00 00 00	 DD	 32			; 00000020H
  000b0	00 00 00 00	 DD	 $LN3@swap
$LN3@swap:
  000b4	5f		 DB	 95			; 0000005fH
  000b5	54		 DB	 84			; 00000054H
  000b6	6d		 DB	 109			; 0000006dH
  000b7	70		 DB	 112			; 00000070H
  000b8	00		 DB	 0
??$swap@UOption@CCustomMenu@@X@std@@YAXAAUOption@CCustomMenu@@0@Z ENDP ; std::swap<CCustomMenu::Option,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Med3_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z PROC ; std::_Med3_unchecked<CCustomMenu::Option *,std::less<void> >, COMDAT

; 2653 : 	{	// sort median of three elements to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2654 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  0001e	68 5e 0a 00 00	 push	 2654			; 00000a5eH
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00028	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 14	 mov	 edx, DWORD PTR __Pred$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  00039	83 c4 14	 add	 esp, 20			; 00000014H
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	85 c0		 test	 eax, eax
  00041	74 10		 je	 SHORT $LN2@Med3_unche

; 2655 : 		_STD iter_swap(_Mid, _First);

  00043	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
  00050	83 c4 08	 add	 esp, 8
$LN2@Med3_unche:

; 2656 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  00053	68 60 0a 00 00	 push	 2656			; 00000a60H
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0005d	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00060	50		 push	 eax
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00064	51		 push	 ecx
  00065	8b 55 14	 mov	 edx, DWORD PTR __Pred$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  0006e	83 c4 14	 add	 esp, 20			; 00000014H
  00071	0f b6 c0	 movzx	 eax, al
  00074	85 c0		 test	 eax, eax
  00076	74 45		 je	 SHORT $LN1@Med3_unche

; 2657 : 		{	// swap middle and last, then test first again
; 2658 : 		_STD iter_swap(_Last, _Mid);

  00078	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
  00085	83 c4 08	 add	 esp, 8

; 2659 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00088	68 63 0a 00 00	 push	 2659			; 00000a63H
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00092	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00095	50		 push	 eax
  00096	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00099	51		 push	 ecx
  0009a	8b 55 14	 mov	 edx, DWORD PTR __Pred$[ebp]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	0f b6 c0	 movzx	 eax, al
  000a9	85 c0		 test	 eax, eax
  000ab	74 10		 je	 SHORT $LN1@Med3_unche

; 2660 : 			_STD iter_swap(_Mid, _First);

  000ad	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
  000ba	83 c4 08	 add	 esp, 8
$LN1@Med3_unche:

; 2661 : 		}
; 2662 : 	}

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c6	3b ec		 cmp	 ebp, esp
  000c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
??$_Med3_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z ENDP ; std::_Med3_unchecked<CCustomMenu::Option *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 725  : 	return (__builtin_addressof(_Val));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 280  : 		return (_STD addressof(_Val));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  00027	83 c4 04	 add	 esp, 4

; 281  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Tag$ = -5						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1062 : 	{	// (maybe) propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);

  0001e	0f b6 45 fb	 movzx	 eax, BYTE PTR __Tag$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1065 : 	}

  00033	52		 push	 edx
  00034	8b cd		 mov	 ecx, ebp
  00036	50		 push	 eax
  00037	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Pocma
  0003d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00042	58		 pop	 eax
  00043	5a		 pop	 edx
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN5@Pocma:
  00058	01 00 00 00	 DD	 1
  0005c	00 00 00 00	 DD	 $LN4@Pocma
$LN4@Pocma:
  00060	fb ff ff ff	 DD	 -5			; fffffffbH
  00064	01 00 00 00	 DD	 1
  00068	00 00 00 00	 DD	 $LN3@Pocma
$LN3@Pocma:
  0006c	5f		 DB	 95			; 0000005fH
  0006d	54		 DB	 84			; 00000054H
  0006e	61		 DB	 97			; 00000061H
  0006f	67		 DB	 103			; 00000067H
  00070	00		 DB	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
_TEXT	SEGMENT
tv175 = -364						; size = 4
tv188 = -360						; size = 4
tv185 = -356						; size = 4
tv195 = -352						; size = 4
tv183 = -348						; size = 4
tv194 = -344						; size = 4
tv180 = -340						; size = 4
tv193 = -336						; size = 4
tv178 = -332						; size = 4
tv192 = -328						; size = 4
tv174 = -324						; size = 4
tv191 = -320						; size = 4
$T2 = -312						; size = 12
$T3 = -292						; size = 4
$T4 = -280						; size = 12
$T5 = -260						; size = 4
$T6 = -248						; size = 4
$T7 = -236						; size = 4
$T8 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT
; _this$ = ecx

; 1202 : 		{	// assign [_First, _Last), input iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 94 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-364]
  00021	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1203 : 		return (replace(begin(), end(), _First, _Last));

  00049	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0004c	8b cc		 mov	 ecx, esp
  0004e	89 a5 14 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], esp
  00054	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
  0005d	89 85 c0 fe ff
	ff		 mov	 DWORD PTR tv191[ebp], eax
  00063	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR tv191[ebp]
  00069	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv174[ebp], ecx
  0006f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00073	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00076	8b cc		 mov	 ecx, esp
  00078	89 a5 08 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], esp
  0007e	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00081	52		 push	 edx
  00082	e8 00 00 00 00	 call	 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
  00087	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv192[ebp], eax
  0008d	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv192[ebp]
  00093	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv178[ebp], eax
  00099	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0009d	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000a3	51		 push	 ecx
  000a4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	e8 00 00 00 00	 call	 ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
  000ac	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv193[ebp], eax
  000b2	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR tv193[ebp]
  000b8	89 95 ac fe ff
	ff		 mov	 DWORD PTR tv180[ebp], edx
  000be	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000c2	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000c5	8b cc		 mov	 ecx, esp
  000c7	89 a5 fc fe ff
	ff		 mov	 DWORD PTR $T5[ebp], esp
  000cd	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv180[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@$$QAV01@@Z
  000d9	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv194[ebp], eax
  000df	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR tv194[ebp]
  000e5	89 8d a4 fe ff
	ff		 mov	 DWORD PTR tv183[ebp], ecx
  000eb	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000ef	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000f5	52		 push	 edx
  000f6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  000fe	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv195[ebp], eax
  00104	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR tv195[ebp]
  0010a	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv185[ebp], eax
  00110	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00114	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00117	8b cc		 mov	 ecx, esp
  00119	89 a5 dc fe ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  0011f	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR tv185[ebp]
  00125	52		 push	 edx
  00126	e8 00 00 00 00	 call	 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@$$QAV01@@Z
  0012b	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv188[ebp], eax
  00131	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00135	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  0013d	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv175[ebp], eax
  00143	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv175[ebp]
  00149	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
  0014f	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00153	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00159	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  0015e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00162	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00168	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  0016d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00171	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00174	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  00179	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00180	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00183	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  00188	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]

; 1204 : 		}

  0018e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00191	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00198	59		 pop	 ecx
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5b		 pop	 ebx
  0019c	81 c4 6c 01 00
	00		 add	 esp, 364		; 0000016cH
  001a2	3b ec		 cmp	 ebp, esp
  001a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$2:
  00010	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$3:
  0001b	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$4:
  00026	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$5:
  00031	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00037	e9 00 00 00 00	 jmp	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z$6:
  0003c	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00042	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__ehhandler$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z:
  00047	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004e	8b 8a 90 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-368]
  00054	33 c8		 xor	 ecx, eax
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 398  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 399  : 		return (*(_Mybase *)this - _Right);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-

; 400  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 339  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 340  : 		return ((reference)**(_Mybase *)this);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*

; 341  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 322  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 321  : 		: _Mybase(_Parg, _Pstring)

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Pstring$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >

; 323  : 		}

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UOption@CCustomMenu@@U12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@$$QAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UOption@CCustomMenu@@U12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@$$QAU34@@Z PROC ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$forward@UOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::forward<CCustomMenu::Option>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$construct@UOption@CCustomMenu@@U12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@$$QAU23@@Z ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option>

; 858  : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$construct@UOption@CCustomMenu@@U12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@$$QAU34@@Z ENDP ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z PROC ; std::forward<CCustomMenu::Option>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@UOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ENDP ; std::forward<CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAUOption@CCustomMenu@@PAU12@@std@@YAPAUOption@CCustomMenu@@PAU12@00@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward_unchecked@PAUOption@CCustomMenu@@PAU12@@std@@YAPAUOption@CCustomMenu@@PAU12@00@Z PROC ; std::_Move_backward_unchecked<CCustomMenu::Option *,CCustomMenu::Option *>, COMDAT

; 2676 : 	{	// move [_First, _Last) backwards to [..., _Dest), choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2677 : 	return (_Move_backward_unchecked1(_First, _Last,

  0001e	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00021	50		 push	 eax
  00022	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@UOption@CCustomMenu@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUOption@CCustomMenu@@0@Z ; std::_Ptr_move_cat<CCustomMenu::Option,CCustomMenu::Option>
  0002b	83 c4 08	 add	 esp, 8
  0002e	88 85 3b ff ff
	ff		 mov	 BYTE PTR $T1[ebp], al
  00034	0f b6 95 3b ff
	ff ff		 movzx	 edx, BYTE PTR $T1[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 ??$_Move_backward_unchecked1@PAUOption@CCustomMenu@@PAU12@@std@@YAPAUOption@CCustomMenu@@PAU12@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_backward_unchecked1<CCustomMenu::Option *,CCustomMenu::Option *>
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 2678 : 		_Dest, _Ptr_move_cat(_First, _Dest)));
; 2679 : 	}

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??$_Move_backward_unchecked@PAUOption@CCustomMenu@@PAU12@@std@@YAPAUOption@CCustomMenu@@PAU12@00@Z ENDP ; std::_Move_backward_unchecked<CCustomMenu::Option *,CCustomMenu::Option *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
_TEXT	SEGMENT
__Val$2 = -52						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z PROC ; std::_Pop_heap_unchecked<CCustomMenu::Option *,std::less<void> >, COMDAT

; 2078 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00020	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2079 : 	if (2 <= _Last - _First)

  00040	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00043	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00046	c1 f8 05	 sar	 eax, 5
  00049	83 f8 02	 cmp	 eax, 2
  0004c	7c 59		 jl	 SHORT $LN1@Pop_heap_u

; 2080 : 		{
; 2081 : 		--_Last;

  0004e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00051	83 e8 20	 sub	 eax, 32			; 00000020H
  00054	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax

; 2082 : 		_Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00057	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00060	83 c4 04	 add	 esp, 4
  00063	50		 push	 eax
  00064	8d 4d cc	 lea	 ecx, DWORD PTR __Val$2[ebp]
  00067	e8 00 00 00 00	 call	 ??0Option@CCustomMenu@@QAE@$$QAU01@@Z
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2083 : 		_Pop_heap_hole_unchecked(_First, _Last, _Last,

  00073	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  00076	50		 push	 eax
  00077	8d 4d cc	 lea	 ecx, DWORD PTR __Val$2[ebp]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00080	83 c4 04	 add	 esp, 4
  00083	50		 push	 eax
  00084	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00087	52		 push	 edx
  00088	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0008b	50		 push	 eax
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_unchecked@PAUOption@CCustomMenu@@U12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00$$QAU12@AAU?$less@X@0@@Z ; std::_Pop_heap_hole_unchecked<CCustomMenu::Option *,CCustomMenu::Option,std::less<void> >
  00095	83 c4 14	 add	 esp, 20			; 00000014H

; 2084 : 			_STD move(_Val), _Pred);
; 2085 : 		}

  00098	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009f	8d 4d cc	 lea	 ecx, DWORD PTR __Val$2[ebp]
  000a2	e8 00 00 00 00	 call	 ??1Option@CCustomMenu@@QAE@XZ
$LN1@Pop_heap_u:

; 2086 : 	}

  000a7	52		 push	 edx
  000a8	8b cd		 mov	 ecx, ebp
  000aa	50		 push	 eax
  000ab	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@Pop_heap_u
  000b1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b6	58		 pop	 eax
  000b7	5a		 pop	 edx
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c2	59		 pop	 ecx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c9	33 cd		 xor	 ecx, ebp
  000cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d0	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  000d6	3b ec		 cmp	 ebp, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
  000e1	0f 1f 00	 npad	 3
$LN8@Pop_heap_u:
  000e4	01 00 00 00	 DD	 1
  000e8	00 00 00 00	 DD	 $LN7@Pop_heap_u
$LN7@Pop_heap_u:
  000ec	cc ff ff ff	 DD	 -52			; ffffffccH
  000f0	20 00 00 00	 DD	 32			; 00000020H
  000f4	00 00 00 00	 DD	 $LN5@Pop_heap_u
$LN5@Pop_heap_u:
  000f8	5f		 DB	 95			; 0000005fH
  000f9	56		 DB	 86			; 00000056H
  000fa	61		 DB	 97			; 00000061H
  000fb	6c		 DB	 108			; 0000006cH
  000fc	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR __Val$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Option@CCustomMenu@@QAE@XZ
__ehhandler$??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 04 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-252]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ENDP ; std::_Pop_heap_unchecked<CCustomMenu::Option *,std::less<void> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z
_TEXT	SEGMENT
__Max_sequence_non_leaf$ = -32				; size = 4
__Idx$ = -20						; size = 4
__Top$ = -8						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Pop_heap_hole_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z PROC ; std::_Pop_heap_hole_by_index<CCustomMenu::Option *,int,CCustomMenu::Option,std::less<void> >, COMDAT

; 2036 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2037 : 		// precondition: _Bottom != 0
; 2038 : 	const _Diff _Top = _Hole;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR __Top$[ebp], eax

; 2039 : 	_Diff _Idx = _Hole;

  00024	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00027	89 45 ec	 mov	 DWORD PTR __Idx$[ebp], eax

; 2040 : 
; 2041 : 	// Check whether _Idx can have a child before calculating that child's index, since
; 2042 : 	// calculating the child's index can trigger integer overflows
; 2043 : 	const _Diff _Max_sequence_non_leaf = (_Bottom - 1) / 2;

  0002a	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  0002d	83 e8 01	 sub	 eax, 1
  00030	99		 cdq
  00031	2b c2		 sub	 eax, edx
  00033	d1 f8		 sar	 eax, 1
  00035	89 45 e0	 mov	 DWORD PTR __Max_sequence_non_leaf$[ebp], eax
$LN2@Pop_heap_h:

; 2044 : 	while (_Idx < _Max_sequence_non_leaf)

  00038	8b 45 ec	 mov	 eax, DWORD PTR __Idx$[ebp]
  0003b	3b 45 e0	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  0003e	7d 70		 jge	 SHORT $LN3@Pop_heap_h

; 2045 : 		{	// move _Hole down to larger child
; 2046 : 		_Idx = 2 * _Idx + 2;

  00040	8b 45 ec	 mov	 eax, DWORD PTR __Idx$[ebp]
  00043	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  00047	89 4d ec	 mov	 DWORD PTR __Idx$[ebp], ecx

; 2047 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  0004a	68 ff 07 00 00	 push	 2047			; 000007ffH
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00054	8b 45 ec	 mov	 eax, DWORD PTR __Idx$[ebp]
  00057	83 e8 01	 sub	 eax, 1
  0005a	c1 e0 05	 shl	 eax, 5
  0005d	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR __Idx$[ebp]
  00064	c1 e1 05	 shl	 ecx, 5
  00067	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  0006a	51		 push	 ecx
  0006b	8b 55 18	 mov	 edx, DWORD PTR __Pred$[ebp]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  00074	83 c4 14	 add	 esp, 20			; 00000014H
  00077	0f b6 c0	 movzx	 eax, al
  0007a	85 c0		 test	 eax, eax
  0007c	74 09		 je	 SHORT $LN4@Pop_heap_h

; 2048 : 			--_Idx;

  0007e	8b 45 ec	 mov	 eax, DWORD PTR __Idx$[ebp]
  00081	83 e8 01	 sub	 eax, 1
  00084	89 45 ec	 mov	 DWORD PTR __Idx$[ebp], eax
$LN4@Pop_heap_h:

; 2049 : 		*(_First + _Hole) = _STD move(*(_First + _Idx));

  00087	8b 45 ec	 mov	 eax, DWORD PTR __Idx$[ebp]
  0008a	c1 e0 05	 shl	 eax, 5
  0008d	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00096	83 c4 04	 add	 esp, 4
  00099	50		 push	 eax
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  0009d	c1 e1 05	 shl	 ecx, 5
  000a0	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  000a3	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z

; 2050 : 		_Hole = _Idx;

  000a8	8b 45 ec	 mov	 eax, DWORD PTR __Idx$[ebp]
  000ab	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 2051 : 		}

  000ae	eb 88		 jmp	 SHORT $LN2@Pop_heap_h
$LN3@Pop_heap_h:

; 2052 : 
; 2053 : 	if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0)

  000b0	8b 45 ec	 mov	 eax, DWORD PTR __Idx$[ebp]
  000b3	3b 45 e0	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  000b6	75 40		 jne	 SHORT $LN5@Pop_heap_h
  000b8	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000bb	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000c0	79 05		 jns	 SHORT $LN7@Pop_heap_h
  000c2	48		 dec	 eax
  000c3	83 c8 fe	 or	 eax, -2			; fffffffeH
  000c6	40		 inc	 eax
$LN7@Pop_heap_h:
  000c7	85 c0		 test	 eax, eax
  000c9	75 2d		 jne	 SHORT $LN5@Pop_heap_h

; 2054 : 		{	// only child at bottom, move _Hole down to it
; 2055 : 		*(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000cb	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000ce	83 e8 01	 sub	 eax, 1
  000d1	c1 e0 05	 shl	 eax, 5
  000d4	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  000dd	83 c4 04	 add	 esp, 4
  000e0	50		 push	 eax
  000e1	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  000e4	c1 e1 05	 shl	 ecx, 5
  000e7	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  000ea	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z

; 2056 : 		_Hole = _Bottom - 1;

  000ef	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000f2	83 e8 01	 sub	 eax, 1
  000f5	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax
$LN5@Pop_heap_h:

; 2057 : 		}
; 2058 : 
; 2059 : 	_Push_heap_by_index(_First, _Hole, _Top, _STD move(_Val), _Pred);

  000f8	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00105	83 c4 04	 add	 esp, 4
  00108	50		 push	 eax
  00109	8b 55 f8	 mov	 edx, DWORD PTR __Top$[ebp]
  0010c	52		 push	 edx
  0010d	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00110	50		 push	 eax
  00111	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ??$_Push_heap_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z ; std::_Push_heap_by_index<CCustomMenu::Option *,int,CCustomMenu::Option,std::less<void> >
  0011a	83 c4 14	 add	 esp, 20			; 00000014H

; 2060 : 	}

  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00126	3b ec		 cmp	 ebp, esp
  00128	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_by_index<CCustomMenu::Option *,int,CCustomMenu::Option,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAPAUOption@CCustomMenu@@AAPAU01@X$0A@@?$pair@PAUOption@CCustomMenu@@PAU12@@std@@QAE@AAPAUOption@CCustomMenu@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAUOption@CCustomMenu@@AAPAU01@X$0A@@?$pair@PAUOption@CCustomMenu@@PAU12@@std@@QAE@AAPAUOption@CCustomMenu@@0@Z PROC ; std::pair<CCustomMenu::Option *,CCustomMenu::Option *>::pair<CCustomMenu::Option *,CCustomMenu::Option *><CCustomMenu::Option * &,CCustomMenu::Option * &,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

  00023	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@AAPAUOption@CCustomMenu@@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@@Z ; std::forward<CCustomMenu::Option * &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 10		 mov	 edx, DWORD PTR [eax]
  00034	89 11		 mov	 DWORD PTR [ecx], edx

; 171  : 				second(_STD forward<_Other2>(_Val2))

  00036	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??$forward@AAPAUOption@CCustomMenu@@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@@Z ; std::forward<CCustomMenu::Option * &>
  0003f	83 c4 04	 add	 esp, 4
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 10		 mov	 edx, DWORD PTR [eax]
  00047	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 173  : 		}

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
??$?0AAPAUOption@CCustomMenu@@AAPAU01@X$0A@@?$pair@PAUOption@CCustomMenu@@PAU12@@std@@QAE@AAPAUOption@CCustomMenu@@0@Z ENDP ; std::pair<CCustomMenu::Option *,CCustomMenu::Option *>::pair<CCustomMenu::Option *,CCustomMenu::Option *><CCustomMenu::Option * &,CCustomMenu::Option * &,void,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z PROC ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>, COMDAT

; 22   : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 23   : 	swap(*_Left, *_Right);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$swap@UOption@CCustomMenu@@X@std@@YAXAAUOption@CCustomMenu@@0@Z ; std::swap<CCustomMenu::Option,void>
  0002b	83 c4 08	 add	 esp, 8

; 24   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ENDP ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$?RAAUOption@CCustomMenu@@AAU01@@?$less@X@std@@QBE_NAAUOption@CCustomMenu@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?RAAUOption@CCustomMenu@@AAU01@@?$less@X@std@@QBE_NAAUOption@CCustomMenu@@0@Z PROC ; std::less<void>::operator()<CCustomMenu::Option &,CCustomMenu::Option &>, COMDAT
; _this$ = ecx

; 322  : 		{	// transparently apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 323  : 		return (static_cast<_Ty1&&>(_Left)

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002a	e8 00 00 00 00	 call	 ??MOption@CCustomMenu@@QBE_NABU01@@Z ; CCustomMenu::Option::operator<

; 324  : 			< static_cast<_Ty2&&>(_Right));
; 325  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??$?RAAUOption@CCustomMenu@@AAU01@@?$less@X@std@@QBE_NAAUOption@CCustomMenu@@0@Z ENDP ; std::less<void>::operator()<CCustomMenu::Option &,CCustomMenu::Option &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z
_TEXT	SEGMENT
tv79 = -194						; size = 1
tv80 = -193						; size = 1
__Pred$ = 8						; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
__File$ = 20						; size = 4
__Line$ = 24						; size = 4
??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z PROC ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>, COMDAT

; 895  : 	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 896  : 	return (!_Pred(_Left, _Right)

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00025	51		 push	 ecx
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?RAAUOption@CCustomMenu@@AAU01@@?$less@X@std@@QBE_NAAUOption@CCustomMenu@@0@Z ; std::less<void>::operator()<CCustomMenu::Option &,CCustomMenu::Option &>
  0002e	0f b6 d0	 movzx	 edx, al
  00031	85 d2		 test	 edx, edx
  00033	75 09		 jne	 SHORT $LN5@Debug_lt_p
  00035	c6 85 3f ff ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
  0003c	eb 52		 jmp	 SHORT $LN6@Debug_lt_p
$LN5@Debug_lt_p:
  0003e	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00041	50		 push	 eax
  00042	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00045	51		 push	 ecx
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00049	e8 00 00 00 00	 call	 ??$?RAAUOption@CCustomMenu@@AAU01@@?$less@X@std@@QBE_NAAUOption@CCustomMenu@@0@Z ; std::less<void>::operator()<CCustomMenu::Option &,CCustomMenu::Option &>
  0004e	0f b6 d0	 movzx	 edx, al
  00051	85 d2		 test	 edx, edx
  00053	74 28		 je	 SHORT $LN3@Debug_lt_p
  00055	8b f4		 mov	 esi, esp
  00057	8b 45 18	 mov	 eax, DWORD PTR __Line$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d 14	 mov	 ecx, DWORD PTR __File$[ebp]
  0005e	51		 push	 ecx
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@LEJCKCBB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$AA@
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	3b f4		 cmp	 esi, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	c6 85 3e ff ff
	ff 01		 mov	 BYTE PTR tv79[ebp], 1
  0007b	eb 07		 jmp	 SHORT $LN4@Debug_lt_p
$LN3@Debug_lt_p:
  0007d	c6 85 3e ff ff
	ff 01		 mov	 BYTE PTR tv79[ebp], 1
$LN4@Debug_lt_p:
  00084	8a 95 3e ff ff
	ff		 mov	 dl, BYTE PTR tv79[ebp]
  0008a	88 95 3f ff ff
	ff		 mov	 BYTE PTR tv80[ebp], dl
$LN6@Debug_lt_p:
  00090	8a 85 3f ff ff
	ff		 mov	 al, BYTE PTR tv80[ebp]

; 897  : 		? false
; 898  : 		: _Pred(_Right, _Left)
; 899  : 			? (_DEBUG_ERROR2("invalid comparator", _File, _Line), true)
; 900  : 			: true);
; 901  : 	}

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0009f	3b ec		 cmp	 ebp, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ENDP ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z
_TEXT	SEGMENT
__Step$1 = -8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Guess_median_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z PROC ; std::_Guess_median_unchecked<CCustomMenu::Option *,std::less<void> >, COMDAT

; 2667 : 	{	// sort median element to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2668 : 	if (40 < _Last - _First)

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00024	c1 f8 05	 sar	 eax, 5
  00027	83 f8 28	 cmp	 eax, 40			; 00000028H
  0002a	0f 8e b6 00 00
	00		 jle	 $LN2@Guess_medi

; 2669 : 		{	// median of nine
; 2670 : 		size_t _Step = (_Last - _First + 1) / 8;

  00030	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00033	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00036	c1 f8 05	 sar	 eax, 5
  00039	83 c0 01	 add	 eax, 1
  0003c	99		 cdq
  0003d	83 e2 07	 and	 edx, 7
  00040	03 c2		 add	 eax, edx
  00042	c1 f8 03	 sar	 eax, 3
  00045	89 45 f8	 mov	 DWORD PTR __Step$1[ebp], eax

; 2671 : 		_Med3_unchecked(_First, _First + _Step, _First + 2 * _Step, _Pred);

  00048	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR __Step$1[ebp]
  0004f	d1 e1		 shl	 ecx, 1
  00051	c1 e1 05	 shl	 ecx, 5
  00054	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 f8	 mov	 edx, DWORD PTR __Step$1[ebp]
  0005b	c1 e2 05	 shl	 edx, 5
  0005e	03 55 08	 add	 edx, DWORD PTR __First$[ebp]
  00061	52		 push	 edx
  00062	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z ; std::_Med3_unchecked<CCustomMenu::Option *,std::less<void> >
  0006b	83 c4 10	 add	 esp, 16			; 00000010H

; 2672 : 		_Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  0006e	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00071	50		 push	 eax
  00072	8b 4d f8	 mov	 ecx, DWORD PTR __Step$1[ebp]
  00075	c1 e1 05	 shl	 ecx, 5
  00078	03 4d 0c	 add	 ecx, DWORD PTR __Mid$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 f8	 mov	 eax, DWORD PTR __Step$1[ebp]
  00083	c1 e0 05	 shl	 eax, 5
  00086	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00089	2b c8		 sub	 ecx, eax
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z ; std::_Med3_unchecked<CCustomMenu::Option *,std::less<void> >
  00091	83 c4 10	 add	 esp, 16			; 00000010H

; 2673 : 		_Med3_unchecked(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

  00094	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00097	50		 push	 eax
  00098	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0009b	51		 push	 ecx
  0009c	8b 55 f8	 mov	 edx, DWORD PTR __Step$1[ebp]
  0009f	c1 e2 05	 shl	 edx, 5
  000a2	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  000a5	2b c2		 sub	 eax, edx
  000a7	50		 push	 eax
  000a8	8b 4d f8	 mov	 ecx, DWORD PTR __Step$1[ebp]
  000ab	d1 e1		 shl	 ecx, 1
  000ad	c1 e1 05	 shl	 ecx, 5
  000b0	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  000b3	2b d1		 sub	 edx, ecx
  000b5	52		 push	 edx
  000b6	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z ; std::_Med3_unchecked<CCustomMenu::Option *,std::less<void> >
  000bb	83 c4 10	 add	 esp, 16			; 00000010H

; 2674 : 		_Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  000be	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000c1	50		 push	 eax
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR __Step$1[ebp]
  000c5	c1 e1 05	 shl	 ecx, 5
  000c8	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  000cb	2b d1		 sub	 edx, ecx
  000cd	52		 push	 edx
  000ce	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d f8	 mov	 ecx, DWORD PTR __Step$1[ebp]
  000d5	c1 e1 05	 shl	 ecx, 5
  000d8	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z ; std::_Med3_unchecked<CCustomMenu::Option *,std::less<void> >
  000e1	83 c4 10	 add	 esp, 16			; 00000010H

; 2675 : 		}
; 2676 : 	else

  000e4	eb 18		 jmp	 SHORT $LN1@Guess_medi
$LN2@Guess_medi:

; 2677 : 		_Med3_unchecked(_First, _Mid, _Last, _Pred);

  000e6	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000e9	50		 push	 eax
  000ea	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  000ed	51		 push	 ecx
  000ee	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  000f1	52		 push	 edx
  000f2	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z ; std::_Med3_unchecked<CCustomMenu::Option *,std::less<void> >
  000fb	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Guess_medi:

; 2678 : 	}

  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00107	3b ec		 cmp	 ebp, esp
  00109	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
??$_Guess_median_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z ENDP ; std::_Guess_median_unchecked<CCustomMenu::Option *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UOption@CCustomMenu@@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@UOption@CCustomMenu@@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@@Z PROC ; std::allocator<CCustomMenu::Option>::destroy<CCustomMenu::Option>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Ptr->~_Uty();

  00023	6a 00		 push	 0
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00028	e8 00 00 00 00	 call	 ??_GOption@CCustomMenu@@QAEPAXI@Z

; 745  : 		}

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
??$destroy@UOption@CCustomMenu@@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@@Z ENDP ; std::allocator<CCustomMenu::Option>::destroy<CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UOption@CCustomMenu@@U12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@$$QAU23@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UOption@CCustomMenu@@U12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@$$QAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@UOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::forward<CCustomMenu::Option>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??$construct@UOption@CCustomMenu@@U12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@$$QAU34@@Z ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option>
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
??$construct@UOption@CCustomMenu@@U12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@$$QAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
_TEXT	SEGMENT
__First1$2 = -88					; size = 4
__Val$3 = -76						; size = 32
__Next1$4 = -36						; size = 4
__Next$5 = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z PROC ; std::_Insertion_sort_unchecked<CCustomMenu::Option *,std::less<void> >, COMDAT

; 2627 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd e4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-284]
  00020	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2628 : 	if (_First != _Last)

  00040	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00043	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00046	0f 84 12 01 00
	00		 je	 $LN1@Insertion_

; 2629 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  0004c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004f	89 45 e8	 mov	 DWORD PTR __Next$5[ebp], eax
$LN4@Insertion_:
  00052	8b 45 e8	 mov	 eax, DWORD PTR __Next$5[ebp]
  00055	83 c0 20	 add	 eax, 32			; 00000020H
  00058	89 45 e8	 mov	 DWORD PTR __Next$5[ebp], eax
  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Next$5[ebp]
  0005e	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00061	0f 84 f7 00 00
	00		 je	 $LN1@Insertion_

; 2630 : 			{	// order next element
; 2631 : 			_BidIt _Next1 = _Next;

  00067	8b 45 e8	 mov	 eax, DWORD PTR __Next$5[ebp]
  0006a	89 45 dc	 mov	 DWORD PTR __Next1$4[ebp], eax

; 2632 : 			_Iter_value_t<_BidIt> _Val = _STD move(*_Next);

  0006d	8b 45 e8	 mov	 eax, DWORD PTR __Next$5[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00076	83 c4 04	 add	 esp, 4
  00079	50		 push	 eax
  0007a	8d 4d b4	 lea	 ecx, DWORD PTR __Val$3[ebp]
  0007d	e8 00 00 00 00	 call	 ??0Option@CCustomMenu@@QAE@$$QAU01@@Z
  00082	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2633 : 
; 2634 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  00089	68 4a 0a 00 00	 push	 2634			; 00000a4aH
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00093	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00096	50		 push	 eax
  00097	8d 4d b4	 lea	 ecx, DWORD PTR __Val$3[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 10	 mov	 edx, DWORD PTR __Pred$[ebp]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  000a4	83 c4 14	 add	 esp, 20			; 00000014H
  000a7	0f b6 c0	 movzx	 eax, al
  000aa	85 c0		 test	 eax, eax
  000ac	74 34		 je	 SHORT $LN9@Insertion_

; 2635 : 				{	// found new earliest element, move to front
; 2636 : 				_Move_backward_unchecked(_First, _Next, ++_Next1);

  000ae	8b 45 dc	 mov	 eax, DWORD PTR __Next1$4[ebp]
  000b1	83 c0 20	 add	 eax, 32			; 00000020H
  000b4	89 45 dc	 mov	 DWORD PTR __Next1$4[ebp], eax
  000b7	8b 4d dc	 mov	 ecx, DWORD PTR __Next1$4[ebp]
  000ba	51		 push	 ecx
  000bb	8b 55 e8	 mov	 edx, DWORD PTR __Next$5[ebp]
  000be	52		 push	 edx
  000bf	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ??$_Move_backward_unchecked@PAUOption@CCustomMenu@@PAU12@@std@@YAPAUOption@CCustomMenu@@PAU12@00@Z ; std::_Move_backward_unchecked<CCustomMenu::Option *,CCustomMenu::Option *>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2637 : 				*_First = _STD move(_Val);

  000cb	8d 45 b4	 lea	 eax, DWORD PTR __Val$3[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  000d4	83 c4 04	 add	 esp, 4
  000d7	50		 push	 eax
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000db	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z

; 2638 : 				}
; 2639 : 			else

  000e0	eb 68		 jmp	 SHORT $LN10@Insertion_
$LN9@Insertion_:

; 2640 : 				{	// look for insertion point after first
; 2641 : 				for (_BidIt _First1 = _Next1;

  000e2	8b 45 dc	 mov	 eax, DWORD PTR __Next1$4[ebp]
  000e5	89 45 a8	 mov	 DWORD PTR __First1$2[ebp], eax
  000e8	eb 06		 jmp	 SHORT $LN7@Insertion_
$LN5@Insertion_:

; 2643 : 					_Next1 = _First1)

  000ea	8b 45 a8	 mov	 eax, DWORD PTR __First1$2[ebp]
  000ed	89 45 dc	 mov	 DWORD PTR __Next1$4[ebp], eax
$LN7@Insertion_:

; 2642 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);

  000f0	8b 45 a8	 mov	 eax, DWORD PTR __First1$2[ebp]
  000f3	83 e8 20	 sub	 eax, 32			; 00000020H
  000f6	89 45 a8	 mov	 DWORD PTR __First1$2[ebp], eax
  000f9	68 52 0a 00 00	 push	 2642			; 00000a52H
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00103	8b 4d a8	 mov	 ecx, DWORD PTR __First1$2[ebp]
  00106	51		 push	 ecx
  00107	8d 55 b4	 lea	 edx, DWORD PTR __Val$3[ebp]
  0010a	52		 push	 edx
  0010b	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  00114	83 c4 14	 add	 esp, 20			; 00000014H
  00117	0f b6 c8	 movzx	 ecx, al
  0011a	85 c9		 test	 ecx, ecx
  0011c	74 17		 je	 SHORT $LN6@Insertion_

; 2644 : 					*_Next1 = _STD move(*_First1);	// move hole down

  0011e	8b 45 a8	 mov	 eax, DWORD PTR __First1$2[ebp]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00127	83 c4 04	 add	 esp, 4
  0012a	50		 push	 eax
  0012b	8b 4d dc	 mov	 ecx, DWORD PTR __Next1$4[ebp]
  0012e	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z
  00133	eb b5		 jmp	 SHORT $LN5@Insertion_
$LN6@Insertion_:

; 2645 : 				*_Next1 = _STD move(_Val);	// insert element in hole

  00135	8d 45 b4	 lea	 eax, DWORD PTR __Val$3[ebp]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  0013e	83 c4 04	 add	 esp, 4
  00141	50		 push	 eax
  00142	8b 4d dc	 mov	 ecx, DWORD PTR __Next1$4[ebp]
  00145	e8 00 00 00 00	 call	 ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z
$LN10@Insertion_:

; 2646 : 				}
; 2647 : 			}

  0014a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00151	8d 4d b4	 lea	 ecx, DWORD PTR __Val$3[ebp]
  00154	e8 00 00 00 00	 call	 ??1Option@CCustomMenu@@QAE@XZ
  00159	e9 f4 fe ff ff	 jmp	 $LN4@Insertion_
$LN1@Insertion_:

; 2648 : 	}

  0015e	52		 push	 edx
  0015f	8b cd		 mov	 ecx, ebp
  00161	50		 push	 eax
  00162	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@Insertion_
  00168	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0016d	58		 pop	 eax
  0016e	5a		 pop	 edx
  0016f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00172	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00179	59		 pop	 ecx
  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	5b		 pop	 ebx
  0017d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00180	33 cd		 xor	 ecx, ebp
  00182	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00187	81 c4 1c 01 00
	00		 add	 esp, 284		; 0000011cH
  0018d	3b ec		 cmp	 ebp, esp
  0018f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c3		 ret	 0
$LN16@Insertion_:
  00198	01 00 00 00	 DD	 1
  0019c	00 00 00 00	 DD	 $LN15@Insertion_
$LN15@Insertion_:
  001a0	b4 ff ff ff	 DD	 -76			; ffffffb4H
  001a4	20 00 00 00	 DD	 32			; 00000020H
  001a8	00 00 00 00	 DD	 $LN13@Insertion_
$LN13@Insertion_:
  001ac	5f		 DB	 95			; 0000005fH
  001ad	56		 DB	 86			; 00000056H
  001ae	61		 DB	 97			; 00000061H
  001af	6c		 DB	 108			; 0000006cH
  001b0	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR __Val$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Option@CCustomMenu@@QAE@XZ
__ehhandler$??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a e0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-288]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ENDP ; std::_Insertion_sort_unchecked<CCustomMenu::Option *,std::less<void> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Sort_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z PROC ; std::_Sort_heap_unchecked<CCustomMenu::Option *,std::less<void> >, COMDAT

; 2141 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2142 : 	for (; 2 <= _Last - _First; --_Last)

  0001e	eb 09		 jmp	 SHORT $LN4@Sort_heap_
$LN2@Sort_heap_:
  00020	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00023	83 e8 20	 sub	 eax, 32			; 00000020H
  00026	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN4@Sort_heap_:
  00029	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0002f	c1 f8 05	 sar	 eax, 5
  00032	83 f8 02	 cmp	 eax, 2
  00035	7c 16		 jl	 SHORT $LN1@Sort_heap_

; 2143 : 		_Pop_heap_unchecked(_First, _Last, _Pred);

  00037	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ??$_Pop_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Pop_heap_unchecked<CCustomMenu::Option *,std::less<void> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	eb d3		 jmp	 SHORT $LN2@Sort_heap_
$LN1@Sort_heap_:

; 2144 : 	}

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??$_Sort_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ENDP ; std::_Sort_heap_unchecked<CCustomMenu::Option *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
_TEXT	SEGMENT
__Val$2 = -76						; size = 32
__Hole$3 = -36						; size = 4
__Bottom$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z PROC ; std::_Make_heap_unchecked<CCustomMenu::Option *,std::less<void> >, COMDAT

; 2108 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd f0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-272]
  00020	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2109 : 	_Iter_diff_t<_RanIt> _Bottom = _Last - _First;

  00040	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00043	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00046	c1 f8 05	 sar	 eax, 5
  00049	89 45 e8	 mov	 DWORD PTR __Bottom$[ebp], eax

; 2110 : 	if (2 <= _Bottom)

  0004c	83 7d e8 02	 cmp	 DWORD PTR __Bottom$[ebp], 2
  00050	7c 72		 jl	 SHORT $LN1@Make_heap_

; 2111 : 		{
; 2112 : 		for (_Iter_diff_t<_RanIt> _Hole = _Bottom / 2; 0 < _Hole; )

  00052	8b 45 e8	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00055	99		 cdq
  00056	2b c2		 sub	 eax, edx
  00058	d1 f8		 sar	 eax, 1
  0005a	89 45 dc	 mov	 DWORD PTR __Hole$3[ebp], eax
$LN4@Make_heap_:
  0005d	83 7d dc 00	 cmp	 DWORD PTR __Hole$3[ebp], 0
  00061	7e 61		 jle	 SHORT $LN1@Make_heap_

; 2113 : 			{	// reheap top half, bottom to top
; 2114 : 			--_Hole;

  00063	8b 45 dc	 mov	 eax, DWORD PTR __Hole$3[ebp]
  00066	83 e8 01	 sub	 eax, 1
  00069	89 45 dc	 mov	 DWORD PTR __Hole$3[ebp], eax

; 2115 : 			_Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  0006c	8b 45 dc	 mov	 eax, DWORD PTR __Hole$3[ebp]
  0006f	c1 e0 05	 shl	 eax, 5
  00072	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  0007b	83 c4 04	 add	 esp, 4
  0007e	50		 push	 eax
  0007f	8d 4d b4	 lea	 ecx, DWORD PTR __Val$2[ebp]
  00082	e8 00 00 00 00	 call	 ??0Option@CCustomMenu@@QAE@$$QAU01@@Z
  00087	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2116 : 			_Pop_heap_hole_by_index(_First, _Hole, _Bottom,

  0008e	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  00091	50		 push	 eax
  00092	8d 4d b4	 lea	 ecx, DWORD PTR __Val$2[ebp]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  0009b	83 c4 04	 add	 esp, 4
  0009e	50		 push	 eax
  0009f	8b 55 e8	 mov	 edx, DWORD PTR __Bottom$[ebp]
  000a2	52		 push	 edx
  000a3	8b 45 dc	 mov	 eax, DWORD PTR __Hole$3[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUOption@CCustomMenu@@HU12@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@HH$$QAU12@AAU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<CCustomMenu::Option *,int,CCustomMenu::Option,std::less<void> >
  000b0	83 c4 14	 add	 esp, 20			; 00000014H

; 2117 : 				_STD move(_Val), _Pred);
; 2118 : 			}

  000b3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ba	8d 4d b4	 lea	 ecx, DWORD PTR __Val$2[ebp]
  000bd	e8 00 00 00 00	 call	 ??1Option@CCustomMenu@@QAE@XZ
  000c2	eb 99		 jmp	 SHORT $LN4@Make_heap_
$LN1@Make_heap_:

; 2119 : 		}
; 2120 : 	}

  000c4	52		 push	 edx
  000c5	8b cd		 mov	 ecx, ebp
  000c7	50		 push	 eax
  000c8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@Make_heap_
  000ce	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d3	58		 pop	 eax
  000d4	5a		 pop	 edx
  000d5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000df	59		 pop	 ecx
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e6	33 cd		 xor	 ecx, ebp
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  000f3	3b ec		 cmp	 ebp, esp
  000f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c3		 ret	 0
  000fe	66 90		 npad	 2
$LN11@Make_heap_:
  00100	01 00 00 00	 DD	 1
  00104	00 00 00 00	 DD	 $LN10@Make_heap_
$LN10@Make_heap_:
  00108	b4 ff ff ff	 DD	 -76			; ffffffb4H
  0010c	20 00 00 00	 DD	 32			; 00000020H
  00110	00 00 00 00	 DD	 $LN8@Make_heap_
$LN8@Make_heap_:
  00114	5f		 DB	 95			; 0000005fH
  00115	56		 DB	 86			; 00000056H
  00116	61		 DB	 97			; 00000061H
  00117	6c		 DB	 108			; 0000006cH
  00118	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR __Val$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Option@CCustomMenu@@QAE@XZ
__ehhandler$??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a ec fe ff
	ff		 mov	 ecx, DWORD PTR [edx-276]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ENDP ; std::_Make_heap_unchecked<CCustomMenu::Option *,std::less<void> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YA?AU?$pair@PAUOption@CCustomMenu@@PAU12@@0@PAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
_TEXT	SEGMENT
tv161 = -264						; size = 4
tv204 = -260						; size = 4
tv160 = -260						; size = 4
tv218 = -256						; size = 4
tv201 = -256						; size = 4
tv159 = -256						; size = 4
__Glast$ = -56						; size = 4
__Gfirst$ = -44						; size = 4
__Plast$ = -32						; size = 4
__Pfirst$ = -20						; size = 4
__Mid$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Partition_by_median_guess_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YA?AU?$pair@PAUOption@CCustomMenu@@PAU12@@0@PAUOption@CCustomMenu@@0AAU?$less@X@0@@Z PROC ; std::_Partition_by_median_guess_unchecked<CCustomMenu::Option *,std::less<void> >, COMDAT

; 2684 : 	{	// partition [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2685 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	2b 45 0c	 sub	 eax, DWORD PTR __First$[ebp]
  00024	c1 f8 05	 sar	 eax, 5
  00027	99		 cdq
  00028	2b c2		 sub	 eax, edx
  0002a	d1 f8		 sar	 eax, 1
  0002c	c1 e0 05	 shl	 eax, 5
  0002f	03 45 0c	 add	 eax, DWORD PTR __First$[ebp]
  00032	89 45 f8	 mov	 DWORD PTR __Mid$[ebp], eax

; 2686 : 	_Guess_median_unchecked(_First, _Mid, _Last - 1, _Pred);

  00035	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00038	50		 push	 eax
  00039	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0003c	83 e9 20	 sub	 ecx, 32			; 00000020H
  0003f	51		 push	 ecx
  00040	8b 55 f8	 mov	 edx, DWORD PTR __Mid$[ebp]
  00043	52		 push	 edx
  00044	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??$_Guess_median_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@00AAU?$less@X@0@@Z ; std::_Guess_median_unchecked<CCustomMenu::Option *,std::less<void> >
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 2687 : 	_RanIt _Pfirst = _Mid;

  00050	8b 45 f8	 mov	 eax, DWORD PTR __Mid$[ebp]
  00053	89 45 ec	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 2688 : 	_RanIt _Plast = _Pfirst + 1;

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00059	83 c0 20	 add	 eax, 32			; 00000020H
  0005c	89 45 e0	 mov	 DWORD PTR __Plast$[ebp], eax
$LN2@Partition_:

; 2689 : 
; 2690 : 	while (_First < _Pfirst
; 2691 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 2692 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  0005f	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00062	3b 45 ec	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00065	73 4d		 jae	 SHORT $LN4@Partition_
  00067	68 83 0a 00 00	 push	 2691			; 00000a83H
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00071	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00074	50		 push	 eax
  00075	8b 4d ec	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00078	83 e9 20	 sub	 ecx, 32			; 00000020H
  0007b	51		 push	 ecx
  0007c	8b 55 14	 mov	 edx, DWORD PTR __Pred$[ebp]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  00085	83 c4 14	 add	 esp, 20			; 00000014H
  00088	0f b6 c0	 movzx	 eax, al
  0008b	85 c0		 test	 eax, eax
  0008d	75 25		 jne	 SHORT $LN4@Partition_
  0008f	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00092	83 e8 20	 sub	 eax, 32			; 00000020H
  00095	50		 push	 eax
  00096	8b 4d ec	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00099	51		 push	 ecx
  0009a	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  0009d	e8 00 00 00 00	 call	 ??$?RAAUOption@CCustomMenu@@AAU01@@?$less@X@std@@QBE_NAAUOption@CCustomMenu@@0@Z ; std::less<void>::operator()<CCustomMenu::Option &,CCustomMenu::Option &>
  000a2	0f b6 d0	 movzx	 edx, al
  000a5	85 d2		 test	 edx, edx
  000a7	75 0b		 jne	 SHORT $LN4@Partition_

; 2693 : 		--_Pfirst;

  000a9	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000ac	83 e8 20	 sub	 eax, 32			; 00000020H
  000af	89 45 ec	 mov	 DWORD PTR __Pfirst$[ebp], eax
  000b2	eb ab		 jmp	 SHORT $LN2@Partition_
$LN4@Partition_:

; 2694 : 	while (_Plast < _Last
; 2695 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 2696 : 		&& !_Pred(*_Pfirst, *_Plast))

  000b4	8b 45 e0	 mov	 eax, DWORD PTR __Plast$[ebp]
  000b7	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  000ba	73 47		 jae	 SHORT $LN5@Partition_
  000bc	68 87 0a 00 00	 push	 2695			; 00000a87H
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000c6	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d e0	 mov	 ecx, DWORD PTR __Plast$[ebp]
  000cd	51		 push	 ecx
  000ce	8b 55 14	 mov	 edx, DWORD PTR __Pred$[ebp]
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  000d7	83 c4 14	 add	 esp, 20			; 00000014H
  000da	0f b6 c0	 movzx	 eax, al
  000dd	85 c0		 test	 eax, eax
  000df	75 22		 jne	 SHORT $LN5@Partition_
  000e1	8b 45 e0	 mov	 eax, DWORD PTR __Plast$[ebp]
  000e4	50		 push	 eax
  000e5	8b 4d ec	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  000e8	51		 push	 ecx
  000e9	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  000ec	e8 00 00 00 00	 call	 ??$?RAAUOption@CCustomMenu@@AAU01@@?$less@X@std@@QBE_NAAUOption@CCustomMenu@@0@Z ; std::less<void>::operator()<CCustomMenu::Option &,CCustomMenu::Option &>
  000f1	0f b6 d0	 movzx	 edx, al
  000f4	85 d2		 test	 edx, edx
  000f6	75 0b		 jne	 SHORT $LN5@Partition_

; 2697 : 		++_Plast;

  000f8	8b 45 e0	 mov	 eax, DWORD PTR __Plast$[ebp]
  000fb	83 c0 20	 add	 eax, 32			; 00000020H
  000fe	89 45 e0	 mov	 DWORD PTR __Plast$[ebp], eax
  00101	eb b1		 jmp	 SHORT $LN4@Partition_
$LN5@Partition_:

; 2698 : 
; 2699 : 	_RanIt _Gfirst = _Plast;

  00103	8b 45 e0	 mov	 eax, DWORD PTR __Plast$[ebp]
  00106	89 45 d4	 mov	 DWORD PTR __Gfirst$[ebp], eax

; 2700 : 	_RanIt _Glast = _Pfirst;

  00109	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0010c	89 45 c8	 mov	 DWORD PTR __Glast$[ebp], eax
$LN8@Partition_:

; 2701 : 
; 2702 : 	for (; ; )
; 2703 : 		{	// partition
; 2704 : 		for (; _Gfirst < _Last; ++_Gfirst)

  0010f	eb 09		 jmp	 SHORT $LN11@Partition_
$LN9@Partition_:
  00111	8b 45 d4	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00114	83 c0 20	 add	 eax, 32			; 00000020H
  00117	89 45 d4	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN11@Partition_:
  0011a	8b 45 d4	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0011d	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00120	0f 83 a2 00 00
	00		 jae	 $LN10@Partition_

; 2705 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  00126	68 91 0a 00 00	 push	 2705			; 00000a91H
  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00130	8b 45 d4	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00133	50		 push	 eax
  00134	8b 4d ec	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00137	51		 push	 ecx
  00138	8b 55 14	 mov	 edx, DWORD PTR __Pred$[ebp]
  0013b	52		 push	 edx
  0013c	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  00141	83 c4 14	 add	 esp, 20			; 00000014H
  00144	0f b6 c0	 movzx	 eax, al
  00147	85 c0		 test	 eax, eax
  00149	74 02		 je	 SHORT $LN15@Partition_
  0014b	eb 76		 jmp	 SHORT $LN16@Partition_
$LN15@Partition_:

; 2706 : 				;
; 2707 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  0014d	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00150	50		 push	 eax
  00151	8b 4d d4	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00154	51		 push	 ecx
  00155	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00158	e8 00 00 00 00	 call	 ??$?RAAUOption@CCustomMenu@@AAU01@@?$less@X@std@@QBE_NAAUOption@CCustomMenu@@0@Z ; std::less<void>::operator()<CCustomMenu::Option &,CCustomMenu::Option &>
  0015d	0f b6 d0	 movzx	 edx, al
  00160	85 d2		 test	 edx, edx
  00162	74 04		 je	 SHORT $LN17@Partition_

; 2708 : 				break;

  00164	eb 62		 jmp	 SHORT $LN10@Partition_
  00166	eb 5b		 jmp	 SHORT $LN16@Partition_
$LN17@Partition_:

; 2709 : 			else if (_Plast++ != _Gfirst)

  00168	8b 45 e0	 mov	 eax, DWORD PTR __Plast$[ebp]
  0016b	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv159[ebp], eax
  00171	8b 4d d4	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00174	89 8d fc fe ff
	ff		 mov	 DWORD PTR tv160[ebp], ecx
  0017a	8b 55 e0	 mov	 edx, DWORD PTR __Plast$[ebp]
  0017d	83 c2 20	 add	 edx, 32			; 00000020H
  00180	89 55 e0	 mov	 DWORD PTR __Plast$[ebp], edx
  00183	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv159[ebp]
  00189	3b 85 fc fe ff
	ff		 cmp	 eax, DWORD PTR tv160[ebp]
  0018f	74 0c		 je	 SHORT $LN33@Partition_
  00191	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv161[ebp], 1
  0019b	eb 0a		 jmp	 SHORT $LN34@Partition_
$LN33@Partition_:
  0019d	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
$LN34@Partition_:
  001a7	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR tv161[ebp], 0
  001ae	74 13		 je	 SHORT $LN16@Partition_

; 2710 : 				_STD iter_swap(_Plast - 1, _Gfirst);

  001b0	8b 45 d4	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001b3	50		 push	 eax
  001b4	8b 4d e0	 mov	 ecx, DWORD PTR __Plast$[ebp]
  001b7	83 e9 20	 sub	 ecx, 32			; 00000020H
  001ba	51		 push	 ecx
  001bb	e8 00 00 00 00	 call	 ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
  001c0	83 c4 08	 add	 esp, 8
$LN16@Partition_:

; 2711 : 		for (; _First < _Glast; --_Glast)

  001c3	e9 49 ff ff ff	 jmp	 $LN9@Partition_
$LN10@Partition_:
  001c8	eb 09		 jmp	 SHORT $LN14@Partition_
$LN12@Partition_:
  001ca	8b 45 c8	 mov	 eax, DWORD PTR __Glast$[ebp]
  001cd	83 e8 20	 sub	 eax, 32			; 00000020H
  001d0	89 45 c8	 mov	 DWORD PTR __Glast$[ebp], eax
$LN14@Partition_:
  001d3	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  001d6	3b 45 c8	 cmp	 eax, DWORD PTR __Glast$[ebp]
  001d9	73 74		 jae	 SHORT $LN13@Partition_

; 2712 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  001db	68 98 0a 00 00	 push	 2712			; 00000a98H
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  001e5	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  001e8	50		 push	 eax
  001e9	8b 4d c8	 mov	 ecx, DWORD PTR __Glast$[ebp]
  001ec	83 e9 20	 sub	 ecx, 32			; 00000020H
  001ef	51		 push	 ecx
  001f0	8b 55 14	 mov	 edx, DWORD PTR __Pred$[ebp]
  001f3	52		 push	 edx
  001f4	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AAU?$less@X@std@@AAUOption@CCustomMenu@@AAU34@@std@@YA_NAAU?$less@X@0@AAUOption@CCustomMenu@@1PB_WI@Z ; std::_Debug_lt_pred<std::less<void> &,CCustomMenu::Option &,CCustomMenu::Option &>
  001f9	83 c4 14	 add	 esp, 20			; 00000014H
  001fc	0f b6 c0	 movzx	 eax, al
  001ff	85 c0		 test	 eax, eax
  00201	74 02		 je	 SHORT $LN20@Partition_
  00203	eb 45		 jmp	 SHORT $LN21@Partition_
$LN20@Partition_:

; 2713 : 				;
; 2714 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  00205	8b 45 c8	 mov	 eax, DWORD PTR __Glast$[ebp]
  00208	83 e8 20	 sub	 eax, 32			; 00000020H
  0020b	50		 push	 eax
  0020c	8b 4d ec	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  0020f	51		 push	 ecx
  00210	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00213	e8 00 00 00 00	 call	 ??$?RAAUOption@CCustomMenu@@AAU01@@?$less@X@std@@QBE_NAAUOption@CCustomMenu@@0@Z ; std::less<void>::operator()<CCustomMenu::Option &,CCustomMenu::Option &>
  00218	0f b6 d0	 movzx	 edx, al
  0021b	85 d2		 test	 edx, edx
  0021d	74 04		 je	 SHORT $LN22@Partition_

; 2715 : 				break;

  0021f	eb 2e		 jmp	 SHORT $LN13@Partition_
  00221	eb 27		 jmp	 SHORT $LN21@Partition_
$LN22@Partition_:

; 2716 : 			else if (--_Pfirst != _Glast - 1)

  00223	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00226	83 e8 20	 sub	 eax, 32			; 00000020H
  00229	89 45 ec	 mov	 DWORD PTR __Pfirst$[ebp], eax
  0022c	8b 4d c8	 mov	 ecx, DWORD PTR __Glast$[ebp]
  0022f	83 e9 20	 sub	 ecx, 32			; 00000020H
  00232	39 4d ec	 cmp	 DWORD PTR __Pfirst$[ebp], ecx
  00235	74 13		 je	 SHORT $LN21@Partition_

; 2717 : 				_STD iter_swap(_Pfirst, _Glast - 1);

  00237	8b 45 c8	 mov	 eax, DWORD PTR __Glast$[ebp]
  0023a	83 e8 20	 sub	 eax, 32			; 00000020H
  0023d	50		 push	 eax
  0023e	8b 4d ec	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00241	51		 push	 ecx
  00242	e8 00 00 00 00	 call	 ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
  00247	83 c4 08	 add	 esp, 8
$LN21@Partition_:

; 2718 : 		if (_Glast == _First && _Gfirst == _Last)

  0024a	e9 7b ff ff ff	 jmp	 $LN12@Partition_
$LN13@Partition_:
  0024f	8b 45 c8	 mov	 eax, DWORD PTR __Glast$[ebp]
  00252	3b 45 0c	 cmp	 eax, DWORD PTR __First$[ebp]
  00255	75 20		 jne	 SHORT $LN25@Partition_
  00257	8b 45 d4	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0025a	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  0025d	75 18		 jne	 SHORT $LN25@Partition_

; 2719 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

  0025f	8d 45 e0	 lea	 eax, DWORD PTR __Plast$[ebp]
  00262	50		 push	 eax
  00263	8d 4d ec	 lea	 ecx, DWORD PTR __Pfirst$[ebp]
  00266	51		 push	 ecx
  00267	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0026a	e8 00 00 00 00	 call	 ??$?0AAPAUOption@CCustomMenu@@AAPAU01@X$0A@@?$pair@PAUOption@CCustomMenu@@PAU12@@std@@QAE@AAPAUOption@CCustomMenu@@0@Z ; std::pair<CCustomMenu::Option *,CCustomMenu::Option *>::pair<CCustomMenu::Option *,CCustomMenu::Option *><CCustomMenu::Option * &,CCustomMenu::Option * &,void,0>
  0026f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00272	e9 e5 00 00 00	 jmp	 $LN1@Partition_
$LN25@Partition_:

; 2720 : 
; 2721 : 		if (_Glast == _First)

  00277	8b 45 c8	 mov	 eax, DWORD PTR __Glast$[ebp]
  0027a	3b 45 0c	 cmp	 eax, DWORD PTR __First$[ebp]
  0027d	75 5d		 jne	 SHORT $LN26@Partition_

; 2722 : 			{	// no room at bottom, rotate pivot upward
; 2723 : 			if (_Plast != _Gfirst)

  0027f	8b 45 e0	 mov	 eax, DWORD PTR __Plast$[ebp]
  00282	3b 45 d4	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  00285	74 10		 je	 SHORT $LN28@Partition_

; 2724 : 				_STD iter_swap(_Pfirst, _Plast);

  00287	8b 45 e0	 mov	 eax, DWORD PTR __Plast$[ebp]
  0028a	50		 push	 eax
  0028b	8b 4d ec	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  0028e	51		 push	 ecx
  0028f	e8 00 00 00 00	 call	 ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
  00294	83 c4 08	 add	 esp, 8
$LN28@Partition_:

; 2725 : 			++_Plast;

  00297	8b 45 e0	 mov	 eax, DWORD PTR __Plast$[ebp]
  0029a	83 c0 20	 add	 eax, 32			; 00000020H
  0029d	89 45 e0	 mov	 DWORD PTR __Plast$[ebp], eax

; 2726 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

  002a0	8b 45 d4	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  002a3	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv201[ebp], eax
  002a9	8b 4d d4	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  002ac	83 c1 20	 add	 ecx, 32			; 00000020H
  002af	89 4d d4	 mov	 DWORD PTR __Gfirst$[ebp], ecx
  002b2	8b 55 ec	 mov	 edx, DWORD PTR __Pfirst$[ebp]
  002b5	89 95 fc fe ff
	ff		 mov	 DWORD PTR tv204[ebp], edx
  002bb	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002be	83 c0 20	 add	 eax, 32			; 00000020H
  002c1	89 45 ec	 mov	 DWORD PTR __Pfirst$[ebp], eax
  002c4	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv201[ebp]
  002ca	51		 push	 ecx
  002cb	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv204[ebp]
  002d1	52		 push	 edx
  002d2	e8 00 00 00 00	 call	 ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
  002d7	83 c4 08	 add	 esp, 8
  002da	eb 7b		 jmp	 SHORT $LN27@Partition_
$LN26@Partition_:

; 2727 : 			}
; 2728 : 		else if (_Gfirst == _Last)

  002dc	8b 45 d4	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  002df	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  002e2	75 45		 jne	 SHORT $LN29@Partition_

; 2729 : 			{	// no room at top, rotate pivot downward
; 2730 : 			if (--_Glast != --_Pfirst)

  002e4	8b 45 c8	 mov	 eax, DWORD PTR __Glast$[ebp]
  002e7	83 e8 20	 sub	 eax, 32			; 00000020H
  002ea	89 45 c8	 mov	 DWORD PTR __Glast$[ebp], eax
  002ed	8b 4d ec	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  002f0	83 e9 20	 sub	 ecx, 32			; 00000020H
  002f3	89 4d ec	 mov	 DWORD PTR __Pfirst$[ebp], ecx
  002f6	8b 55 c8	 mov	 edx, DWORD PTR __Glast$[ebp]
  002f9	3b 55 ec	 cmp	 edx, DWORD PTR __Pfirst$[ebp]
  002fc	74 10		 je	 SHORT $LN31@Partition_

; 2731 : 				_STD iter_swap(_Glast, _Pfirst);

  002fe	8b 45 ec	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00301	50		 push	 eax
  00302	8b 4d c8	 mov	 ecx, DWORD PTR __Glast$[ebp]
  00305	51		 push	 ecx
  00306	e8 00 00 00 00	 call	 ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
  0030b	83 c4 08	 add	 esp, 8
$LN31@Partition_:

; 2732 : 			_STD iter_swap(_Pfirst, --_Plast);

  0030e	8b 45 e0	 mov	 eax, DWORD PTR __Plast$[ebp]
  00311	83 e8 20	 sub	 eax, 32			; 00000020H
  00314	89 45 e0	 mov	 DWORD PTR __Plast$[ebp], eax
  00317	8b 4d e0	 mov	 ecx, DWORD PTR __Plast$[ebp]
  0031a	51		 push	 ecx
  0031b	8b 55 ec	 mov	 edx, DWORD PTR __Pfirst$[ebp]
  0031e	52		 push	 edx
  0031f	e8 00 00 00 00	 call	 ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
  00324	83 c4 08	 add	 esp, 8

; 2733 : 			}
; 2734 : 		else

  00327	eb 2e		 jmp	 SHORT $LN27@Partition_
$LN29@Partition_:

; 2735 : 			_STD iter_swap(_Gfirst++, --_Glast);

  00329	8b 45 c8	 mov	 eax, DWORD PTR __Glast$[ebp]
  0032c	83 e8 20	 sub	 eax, 32			; 00000020H
  0032f	89 45 c8	 mov	 DWORD PTR __Glast$[ebp], eax
  00332	8b 4d d4	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00335	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv218[ebp], ecx
  0033b	8b 55 d4	 mov	 edx, DWORD PTR __Gfirst$[ebp]
  0033e	83 c2 20	 add	 edx, 32			; 00000020H
  00341	89 55 d4	 mov	 DWORD PTR __Gfirst$[ebp], edx
  00344	8b 45 c8	 mov	 eax, DWORD PTR __Glast$[ebp]
  00347	50		 push	 eax
  00348	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv218[ebp]
  0034e	51		 push	 ecx
  0034f	e8 00 00 00 00	 call	 ??$iter_swap@PAUOption@CCustomMenu@@PAU12@@std@@YAXPAUOption@CCustomMenu@@0@Z ; std::iter_swap<CCustomMenu::Option *,CCustomMenu::Option *>
  00354	83 c4 08	 add	 esp, 8
$LN27@Partition_:

; 2736 : 		}

  00357	e9 b3 fd ff ff	 jmp	 $LN8@Partition_
$LN1@Partition_:

; 2737 : 	}

  0035c	52		 push	 edx
  0035d	8b cd		 mov	 ecx, ebp
  0035f	50		 push	 eax
  00360	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN38@Partition_
  00366	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0036b	58		 pop	 eax
  0036c	5a		 pop	 edx
  0036d	5f		 pop	 edi
  0036e	5e		 pop	 esi
  0036f	5b		 pop	 ebx
  00370	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00376	3b ec		 cmp	 ebp, esp
  00378	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0037d	8b e5		 mov	 esp, ebp
  0037f	5d		 pop	 ebp
  00380	c3		 ret	 0
  00381	0f 1f 00	 npad	 3
$LN38@Partition_:
  00384	02 00 00 00	 DD	 2
  00388	00 00 00 00	 DD	 $LN37@Partition_
$LN37@Partition_:
  0038c	ec ff ff ff	 DD	 -20			; ffffffecH
  00390	04 00 00 00	 DD	 4
  00394	00 00 00 00	 DD	 $LN35@Partition_
  00398	e0 ff ff ff	 DD	 -32			; ffffffe0H
  0039c	04 00 00 00	 DD	 4
  003a0	00 00 00 00	 DD	 $LN36@Partition_
$LN36@Partition_:
  003a4	5f		 DB	 95			; 0000005fH
  003a5	50		 DB	 80			; 00000050H
  003a6	6c		 DB	 108			; 0000006cH
  003a7	61		 DB	 97			; 00000061H
  003a8	73		 DB	 115			; 00000073H
  003a9	74		 DB	 116			; 00000074H
  003aa	00		 DB	 0
$LN35@Partition_:
  003ab	5f		 DB	 95			; 0000005fH
  003ac	50		 DB	 80			; 00000050H
  003ad	66		 DB	 102			; 00000066H
  003ae	69		 DB	 105			; 00000069H
  003af	72		 DB	 114			; 00000072H
  003b0	73		 DB	 115			; 00000073H
  003b1	74		 DB	 116			; 00000074H
  003b2	00		 DB	 0
??$_Partition_by_median_guess_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YA?AU?$pair@PAUOption@CCustomMenu@@PAU12@@0@PAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ENDP ; std::_Partition_by_median_guess_unchecked<CCustomMenu::Option *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UOption@CCustomMenu@@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UOption@CCustomMenu@@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@@Z PROC ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::destroy<CCustomMenu::Option>, COMDAT

; 863  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 864  : 		_Al.destroy(_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00025	e8 00 00 00 00	 call	 ??$destroy@UOption@CCustomMenu@@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@@Z ; std::allocator<CCustomMenu::Option>::destroy<CCustomMenu::Option>

; 865  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$destroy@UOption@CCustomMenu@@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@@Z ENDP ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::destroy<CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 554  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
tv80 = -224						; size = 4
__Next$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >, COMDAT

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00021	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 274  : 	_FwdIt _Next = _Dest;

  00041	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00044	89 45 e8	 mov	 DWORD PTR __Next$[ebp], eax

; 275  : 
; 276  : 	_TRY_BEGIN

  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  0004e	eb 12		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00050	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00053	83 c0 20	 add	 eax, 32			; 00000020H
  00056	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0005c	83 c1 20	 add	 ecx, 32			; 00000020H
  0005f	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN4@Uninitiali:
  00062	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00065	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00068	74 30		 je	 SHORT $LN3@Uninitiali

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));

  0006a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unfancy<CCustomMenu::Option>
  00073	83 c4 04	 add	 esp, 4
  00076	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ; std::move<CCustomMenu::Option &>
  00085	83 c4 04	 add	 esp, 4
  00088	50		 push	 eax
  00089	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv80[ebp]
  0008f	52		 push	 edx
  00090	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00093	e8 00 00 00 00	 call	 ??$construct@UOption@CCustomMenu@@U12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@$$QAU23@@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option>
  00098	eb b6		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:
  0009a	eb 23		 jmp	 SHORT $LN7@Uninitiali
__catch$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:

; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);

  0009c	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000a3	51		 push	 ecx
  000a4	8b 55 e8	 mov	 edx, DWORD PTR __Next$[ebp]
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<CCustomMenu::Option>,CCustomMenu::Option *>
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : 	_RERAISE;

  000b0	6a 00		 push	 0
  000b2	6a 00		 push	 0
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8

; 282  : 	_CATCH_END

  000b9	b8 00 00 00 00	 mov	 eax, $LN10@Uninitiali
  000be	c3		 ret	 0
$LN7@Uninitiali:
  000bf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000c6	eb 07		 jmp	 SHORT __tryend$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$1
$LN10@Uninitiali:
  000c8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$1:

; 283  : 
; 284  : 	return (_Dest);

  000cf	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN6@Uninitiali:

; 285  : 	}

  000d2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000d5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000dc	59		 pop	 ecx
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  000e6	3b ec		 cmp	 ebp, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 1c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-228]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@UOption@CCustomMenu@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUOption@CCustomMenu@@0@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_move_cat@UOption@CCustomMenu@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUOption@CCustomMenu@@0@Z PROC ; std::_Ptr_move_cat<CCustomMenu::Option,CCustomMenu::Option>, COMDAT

; 809  : 	{	// return pointer move optimization category for pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 810  : 	return {};

  0001e	33 c0		 xor	 eax, eax
  00020	88 85 3b ff ff
	ff		 mov	 BYTE PTR $T1[ebp], al
  00026	8a 85 3b ff ff
	ff		 mov	 al, BYTE PTR $T1[ebp]

; 811  : 	}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Ptr_move_cat@UOption@CCustomMenu@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUOption@CCustomMenu@@0@Z ENDP ; std::_Ptr_move_cat<CCustomMenu::Option,CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z PROC ; std::move<CCustomMenu::Option &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$move@AAUOption@CCustomMenu@@@std@@YA$$QAUOption@CCustomMenu@@AAU12@@Z ENDP ; std::move<CCustomMenu::Option &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Sort_unchecked1@PAUOption@CCustomMenu@@HU?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0HAAU?$less@X@0@@Z
_TEXT	SEGMENT
__Mid$1 = -24						; size = 8
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Sort_unchecked1@PAUOption@CCustomMenu@@HU?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0HAAU?$less@X@0@@Z PROC ; std::_Sort_unchecked1<CCustomMenu::Option *,int,std::less<void> >, COMDAT

; 2743 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
$LN2@Sort_unche:

; 2744 : 	_Diff _Count;
; 2745 : 	while (_ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal)

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00024	c1 f8 05	 sar	 eax, 5
  00027	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax
  0002a	83 7d f8 20	 cmp	 DWORD PTR __Count$[ebp], 32 ; 00000020H
  0002e	0f 8e 94 00 00
	00		 jle	 $LN3@Sort_unche
  00034	83 7d 10 00	 cmp	 DWORD PTR __Ideal$[ebp], 0
  00038	0f 8e 8a 00 00
	00		 jle	 $LN3@Sort_unche

; 2746 : 		{	// divide and conquer by quicksort
; 2747 : 		pair<_RanIt, _RanIt> _Mid =
; 2748 : 			_Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  0003e	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00041	50		 push	 eax
  00042	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00045	51		 push	 ecx
  00046	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00049	52		 push	 edx
  0004a	8d 45 e8	 lea	 eax, DWORD PTR __Mid$1[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YA?AU?$pair@PAUOption@CCustomMenu@@PAU12@@0@PAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<CCustomMenu::Option *,std::less<void> >
  00053	83 c4 10	 add	 esp, 16			; 00000010H

; 2749 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

  00056	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  00059	99		 cdq
  0005a	2b c2		 sub	 eax, edx
  0005c	d1 f8		 sar	 eax, 1
  0005e	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax
  00061	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  00064	99		 cdq
  00065	2b c2		 sub	 eax, edx
  00067	d1 f8		 sar	 eax, 1
  00069	03 45 10	 add	 eax, DWORD PTR __Ideal$[ebp]
  0006c	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax

; 2750 : 
; 2751 : 		if (_Mid.first - _First < _Last - _Mid.second)

  0006f	8b 45 e8	 mov	 eax, DWORD PTR __Mid$1[ebp]
  00072	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00075	c1 f8 05	 sar	 eax, 5
  00078	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0007b	2b 4d ec	 sub	 ecx, DWORD PTR __Mid$1[ebp+4]
  0007e	c1 f9 05	 sar	 ecx, 5
  00081	3b c1		 cmp	 eax, ecx
  00083	7d 20		 jge	 SHORT $LN4@Sort_unche

; 2752 : 			{	// loop on second half
; 2753 : 			_Sort_unchecked1(_First, _Mid.first, _Ideal, _Pred);

  00085	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00088	50		 push	 eax
  00089	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 e8	 mov	 edx, DWORD PTR __Mid$1[ebp]
  00090	52		 push	 edx
  00091	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??$_Sort_unchecked1@PAUOption@CCustomMenu@@HU?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<CCustomMenu::Option *,int,std::less<void> >
  0009a	83 c4 10	 add	 esp, 16			; 00000010H

; 2754 : 			_First = _Mid.second;

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Mid$1[ebp+4]
  000a0	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 2755 : 			}
; 2756 : 		else

  000a3	eb 1e		 jmp	 SHORT $LN5@Sort_unche
$LN4@Sort_unche:

; 2757 : 			{	// loop on first half
; 2758 : 			_Sort_unchecked1(_Mid.second, _Last, _Ideal, _Pred);

  000a5	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  000b0	52		 push	 edx
  000b1	8b 45 ec	 mov	 eax, DWORD PTR __Mid$1[ebp+4]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??$_Sort_unchecked1@PAUOption@CCustomMenu@@HU?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<CCustomMenu::Option *,int,std::less<void> >
  000ba	83 c4 10	 add	 esp, 16			; 00000010H

; 2759 : 			_Last = _Mid.first;

  000bd	8b 45 e8	 mov	 eax, DWORD PTR __Mid$1[ebp]
  000c0	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN5@Sort_unche:

; 2760 : 			}
; 2761 : 		}

  000c3	e9 56 ff ff ff	 jmp	 $LN2@Sort_unche
$LN3@Sort_unche:

; 2762 : 
; 2763 : 	if (_ISORT_MAX < _Count)

  000c8	83 7d f8 20	 cmp	 DWORD PTR __Count$[ebp], 32 ; 00000020H
  000cc	7e 2a		 jle	 SHORT $LN6@Sort_unche

; 2764 : 		{	// heap sort if too many divisions
; 2765 : 		_Make_heap_unchecked(_First, _Last, _Pred);

  000ce	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000d5	51		 push	 ecx
  000d6	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000d9	52		 push	 edx
  000da	e8 00 00 00 00	 call	 ??$_Make_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Make_heap_unchecked<CCustomMenu::Option *,std::less<void> >
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2766 : 		_Sort_heap_unchecked(_First, _Last, _Pred);

  000e2	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 ??$_Sort_heap_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Sort_heap_unchecked<CCustomMenu::Option *,std::less<void> >
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f6	eb 1a		 jmp	 SHORT $LN1@Sort_unche
$LN6@Sort_unche:

; 2767 : 		}
; 2768 : 	else if (2 <= _Count)

  000f8	83 7d f8 02	 cmp	 DWORD PTR __Count$[ebp], 2
  000fc	7c 14		 jl	 SHORT $LN1@Sort_unche

; 2769 : 		_Insertion_sort_unchecked(_First, _Last, _Pred);	// small

  000fe	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00101	50		 push	 eax
  00102	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00105	51		 push	 ecx
  00106	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00109	52		 push	 edx
  0010a	e8 00 00 00 00	 call	 ??$_Insertion_sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Insertion_sort_unchecked<CCustomMenu::Option *,std::less<void> >
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Sort_unche:

; 2770 : 	}

  00112	52		 push	 edx
  00113	8b cd		 mov	 ecx, ebp
  00115	50		 push	 eax
  00116	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@Sort_unche
  0011c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00121	58		 pop	 eax
  00122	5a		 pop	 edx
  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0012c	3b ec		 cmp	 ebp, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
  00137	90		 npad	 1
$LN12@Sort_unche:
  00138	01 00 00 00	 DD	 1
  0013c	00 00 00 00	 DD	 $LN11@Sort_unche
$LN11@Sort_unche:
  00140	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00144	08 00 00 00	 DD	 8
  00148	00 00 00 00	 DD	 $LN10@Sort_unche
$LN10@Sort_unche:
  0014c	5f		 DB	 95			; 0000005fH
  0014d	4d		 DB	 77			; 0000004dH
  0014e	69		 DB	 105			; 00000069H
  0014f	64		 DB	 100			; 00000064H
  00150	00		 DB	 0
??$_Sort_unchecked1@PAUOption@CCustomMenu@@HU?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0HAAU?$less@X@0@@Z ENDP ; std::_Sort_unchecked1<CCustomMenu::Option *,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@PB_WI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@PB_WI@Z PROC ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >, COMDAT

; 918  : 	{	// (don't) test non-pointer for non-singularity, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 919  : 	}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@PB_WI@Z ENDP ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UOption@CCustomMenu@@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@UOption@CCustomMenu@@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@@Z PROC ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::destroy<CCustomMenu::Option>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$destroy@UOption@CCustomMenu@@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@@Z ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::destroy<CCustomMenu::Option>
  00030	83 c4 08	 add	 esp, 8

; 1004 : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??$destroy@UOption@CCustomMenu@@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::destroy<CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUOption@CCustomMenu@@PAU12@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@PAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUOption@CCustomMenu@@PAU12@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@PAU12@@Z PROC ; std::_Rechecked<CCustomMenu::Option *,CCustomMenu::Option *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 458  : 	_Dest = _Src;

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00024	89 08		 mov	 DWORD PTR [eax], ecx

; 459  : 	return (_Dest);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]

; 460  : 	}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Rechecked@PAUOption@CCustomMenu@@PAU12@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@PAU12@@Z ENDP ; std::_Rechecked<CCustomMenu::Option *,CCustomMenu::Option *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -221						; size = 1
$T2 = -209						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 302  : 	typedef decltype(_STD move(*_First)) _Src_type; // TRANSITION MODULES VSO#222794
; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

  0001e	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00021	50		 push	 eax
  00022	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@UOption@CCustomMenu@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUOption@CCustomMenu@@0@Z ; std::_Ptr_move_cat<CCustomMenu::Option,CCustomMenu::Option>
  0002b	83 c4 08	 add	 esp, 8
  0002e	88 85 23 ff ff
	ff		 mov	 BYTE PTR $T1[ebp], al
  00034	51		 push	 ecx
  00035	8b cc		 mov	 ecx, esp
  00037	8d 95 2f ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
  00043	0f b6 85 23 ff
	ff ff		 movzx	 eax, BYTE PTR $T1[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00052	52		 push	 edx
  00053	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >
  00060	83 c4 18	 add	 esp, 24			; 00000018H

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z PROC ; std::_Unchecked<CCustomMenu::Option *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 428  : 	return (_Src);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 429  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Unchecked@PAUOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ENDP ; std::_Unchecked<CCustomMenu::Option *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
tv74 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	6a 08		 push	 8
  00029	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0002e	83 c4 08	 add	 esp, 8
  00031	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00037	83 bd 2c ff ff
	ff 00		 cmp	 DWORD PTR $T1[ebp], 0
  0003e	74 2a		 je	 SHORT $LN3@construct
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  00049	83 c4 04	 add	 esp, 4
  0004c	8b 10		 mov	 edx, DWORD PTR [eax]
  0004e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00051	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00057	89 11		 mov	 DWORD PTR [ecx], edx
  00059	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0005c	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00062	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 0a		 jmp	 SHORT $LN1@construct
$LN3@construct:
  0006a	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
$LN1@construct:

; 738  : 		}

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 08 00	 ret	 8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	6a 04		 push	 4
  00029	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0002e	83 c4 08	 add	 esp, 8
  00031	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00037	83 bd 2c ff ff
	ff 00		 cmp	 DWORD PTR $T1[ebp], 0
  0003e	74 24		 je	 SHORT $LN3@construct
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  00049	83 c4 04	 add	 esp, 4
  0004c	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	89 02		 mov	 DWORD PTR [edx], eax
  00056	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  0005c	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  00062	eb 0a		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00064	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
$LN1@construct:

; 738  : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z
_TEXT	SEGMENT
tv79 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z PROC ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00021	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00042	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00045	50		 push	 eax
  00046	6a 20		 push	 32			; 00000020H
  00048	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004d	83 c4 08	 add	 esp, 8
  00050	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005d	83 bd 14 ff ff
	ff 00		 cmp	 DWORD PTR $T2[ebp], 0
  00064	74 20		 je	 SHORT $LN3@construct
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ??$forward@ABUOption@CCustomMenu@@@std@@YAABUOption@CCustomMenu@@ABU12@@Z ; std::forward<CCustomMenu::Option const &>
  0006f	83 c4 04	 add	 esp, 4
  00072	50		 push	 eax
  00073	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  00079	e8 00 00 00 00	 call	 ??0Option@CCustomMenu@@QAE@ABU01@@Z
  0007e	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  00084	eb 0a		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00086	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv79[ebp], 0
$LN4@construct:
  00090	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv79[ebp]
  00096	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], edx
  0009c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 738  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000b7	3b ec		 cmp	 ebp, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00010	83 c4 08	 add	 esp, 8
  00013	c3		 ret	 0
__ehhandler$??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z ENDP ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z
_TEXT	SEGMENT
tv79 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z PROC ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00021	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00042	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00045	50		 push	 eax
  00046	6a 20		 push	 32			; 00000020H
  00048	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004d	83 c4 08	 add	 esp, 8
  00050	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005d	83 bd 14 ff ff
	ff 00		 cmp	 DWORD PTR $T2[ebp], 0
  00064	74 20		 je	 SHORT $LN3@construct
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ??$forward@AAUOption@CCustomMenu@@@std@@YAAAUOption@CCustomMenu@@AAU12@@Z ; std::forward<CCustomMenu::Option &>
  0006f	83 c4 04	 add	 esp, 4
  00072	50		 push	 eax
  00073	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  00079	e8 00 00 00 00	 call	 ??0Option@CCustomMenu@@QAE@ABU01@@Z
  0007e	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  00084	eb 0a		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00086	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv79[ebp], 0
$LN4@construct:
  00090	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv79[ebp]
  00096	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], edx
  0009c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 738  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000b7	3b ec		 cmp	 ebp, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00010	83 c4 08	 add	 esp, 8
  00013	c3		 ret	 0
__ehhandler$??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z ENDP ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option &>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z PROC ; std::_Sort_unchecked<CCustomMenu::Option *,std::less<void> >, COMDAT

; 2775 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2776 : 	_Sort_unchecked1(_First, _Last, _Last - _First, _Pred);

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00025	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  00028	c1 f9 05	 sar	 ecx, 5
  0002b	51		 push	 ecx
  0002c	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??$_Sort_unchecked1@PAUOption@CCustomMenu@@HU?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<CCustomMenu::Option *,int,std::less<void> >
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 2777 : 	}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
??$_Sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ENDP ; std::_Sort_unchecked<CCustomMenu::Option *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Find_unchecked1@PAUOption@CCustomMenu@@D@std@@YAPAUOption@CCustomMenu@@PAU12@0ABDU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Find_unchecked1@PAUOption@CCustomMenu@@D@std@@YAPAUOption@CCustomMenu@@PAU12@0ABDU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find_unchecked1<CCustomMenu::Option *,char>, COMDAT

; 3256 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3257 : 	for (; _First != _Last; ++_First)

  0001e	eb 09		 jmp	 SHORT $LN4@Find_unche
$LN2@Find_unche:
  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	83 c0 20	 add	 eax, 32			; 00000020H
  00026	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Find_unche:
  00029	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002c	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0002f	74 17		 je	 SHORT $LN3@Find_unche

; 3258 : 		if (*_First == _Val)

  00031	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00038	e8 00 00 00 00	 call	 ??8Option@CCustomMenu@@QBE_NABD@Z ; CCustomMenu::Option::operator==
  0003d	0f b6 c8	 movzx	 ecx, al
  00040	85 c9		 test	 ecx, ecx
  00042	74 02		 je	 SHORT $LN5@Find_unche

; 3259 : 			break;

  00044	eb 02		 jmp	 SHORT $LN3@Find_unche
$LN5@Find_unche:

; 3260 : 	return (_First);

  00046	eb d8		 jmp	 SHORT $LN2@Find_unche
$LN3@Find_unche:
  00048	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 3261 : 	}

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
??$_Find_unchecked1@PAUOption@CCustomMenu@@D@std@@YAPAUOption@CCustomMenu@@PAU12@0ABDU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find_unchecked1<CCustomMenu::Option *,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >, COMDAT

; 953  : 	{	// test iterator pair for valid range, random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00020	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 954  : 	if (_First != _Last)

  00044	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  00047	50		 push	 eax
  00048	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0004b	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator!=
  00050	0f b6 c8	 movzx	 ecx, al
  00053	85 c9		 test	 ecx, ecx
  00055	74 5a		 je	 SHORT $LN2@Debug_rang

; 955  : 		{	// check for non-null pointers, valid range
; 956  : 		_DEBUG_POINTER2(_First, _File, _Line);

  00057	8b 45 24	 mov	 eax, DWORD PTR __Line$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d 20	 mov	 ecx, DWORD PTR __File$[ebp]
  0005e	51		 push	 ecx
  0005f	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH

; 957  : 		_DEBUG_POINTER2(_Last, _File, _Line);

  0006b	8b 45 24	 mov	 eax, DWORD PTR __Line$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 20	 mov	 ecx, DWORD PTR __File$[ebp]
  00072	51		 push	 ecx
  00073	8d 55 14	 lea	 edx, DWORD PTR __Last$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 958  : 		if (_Last < _First)

  0007f	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00082	50		 push	 eax
  00083	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00086	e8 00 00 00 00	 call	 ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator<
  0008b	0f b6 c8	 movzx	 ecx, al
  0008e	85 c9		 test	 ecx, ecx
  00090	74 1f		 je	 SHORT $LN2@Debug_rang

; 959  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

  00092	8b f4		 mov	 esi, esp
  00094	8b 45 24	 mov	 eax, DWORD PTR __Line$[ebp]
  00097	50		 push	 eax
  00098	8b 4d 20	 mov	 ecx, DWORD PTR __File$[ebp]
  0009b	51		 push	 ecx
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000aa	3b f4		 cmp	 esi, esp
  000ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Debug_rang:

; 960  : 		}
; 961  : 	}

  000b1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000b5	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  000bd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c4	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  000c7	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  000cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d6	59		 pop	 ecx
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000e0	3b ec		 cmp	 ebp, esp
  000e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 709  : 		{	// construct from a related allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 710  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<CCustomMenu::Option>,CCustomMenu::Option *>, COMDAT

; 1099 : 	{	// destroy [_First, _Last), no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1100 : 	for (; _First != _Last; ++_First)

  0001e	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	83 c0 20	 add	 eax, 32			; 00000020H
  00026	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  00029	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002c	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0002f	74 17		 je	 SHORT $LN1@Destroy_ra

; 1101 : 		_Al.destroy(_Unfancy(_First));

  00031	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unfancy<CCustomMenu::Option>
  0003a	83 c4 04	 add	 esp, 4
  0003d	50		 push	 eax
  0003e	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00041	e8 00 00 00 00	 call	 ??$destroy@UOption@CCustomMenu@@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::destroy<CCustomMenu::Option>
  00046	eb d8		 jmp	 SHORT $LN2@Destroy_ra
$LN1@Destroy_ra:

; 1102 : 	}

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
??$_Destroy_range1@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<CCustomMenu::Option>,CCustomMenu::Option *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,

  0001e	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Unchecked@PAUOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unchecked<CCustomMenu::Option *>
  0002b	83 c4 04	 add	 esp, 4
  0002e	50		 push	 eax
  0002f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ??$_Unchecked@PAUOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unchecked<CCustomMenu::Option *>
  00038	83 c4 04	 add	 esp, 4
  0003b	50		 push	 eax
  0003c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$_Unchecked@PAUOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unchecked<CCustomMenu::Option *>
  00045	83 c4 04	 add	 esp, 4
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	50		 push	 eax
  00052	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??$_Rechecked@PAUOption@CCustomMenu@@PAU12@@std@@YAAAPAUOption@CCustomMenu@@AAPAU12@PAU12@@Z ; std::_Rechecked<CCustomMenu::Option *,CCustomMenu::Option *>
  0005b	83 c4 08	 add	 esp, 8
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]

; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
??$_Uninitialized_move@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 858  : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 863  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 864  : 		_Al.destroy(_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00025	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 865  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0UOption@CCustomMenu@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UOption@CCustomMenu@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0UOption@CCustomMenu@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UOption@CCustomMenu@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><CCustomMenu::Option>, COMDAT
; _this$ = ecx

; 709  : 		{	// construct from a related allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 710  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??$?0UOption@CCustomMenu@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UOption@CCustomMenu@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>

; 858  : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 863  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 864  : 		_Al.destroy(_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00025	e8 00 00 00 00	 call	 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 865  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1038 : 	{	// (don't) propagate on container copy assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1039 : 	}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx

; 289  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 287  : 		: _Ty1(_STD forward<_Other1>(_Val1)),

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 290  : 		}

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 795  : 	{	// test for allocator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 796  : 	return (true);

  0001e	b0 01		 mov	 al, 1

; 797  : 	}

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 1016 : 	{	// test for allocator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ; std::operator==<char,char>
  0002b	83 c4 08	 add	 esp, 8

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UOption@CCustomMenu@@ABU12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@ABU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UOption@CCustomMenu@@ABU12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$forward@ABUOption@CCustomMenu@@@std@@YAABUOption@CCustomMenu@@ABU12@@Z ; std::forward<CCustomMenu::Option const &>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$construct@UOption@CCustomMenu@@ABU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option const &>

; 858  : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$construct@UOption@CCustomMenu@@ABU12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUOption@CCustomMenu@@@std@@YAABUOption@CCustomMenu@@ABU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUOption@CCustomMenu@@@std@@YAABUOption@CCustomMenu@@ABU12@@Z PROC ; std::forward<CCustomMenu::Option const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@ABUOption@CCustomMenu@@@std@@YAABUOption@CCustomMenu@@ABU12@@Z ENDP ; std::forward<CCustomMenu::Option const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UOption@CCustomMenu@@AAU12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@AAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UOption@CCustomMenu@@AAU12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@AAU34@@Z PROC ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$forward@AAUOption@CCustomMenu@@@std@@YAAAUOption@CCustomMenu@@AAU12@@Z ; std::forward<CCustomMenu::Option &>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$construct@UOption@CCustomMenu@@AAU12@@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z ; std::allocator<CCustomMenu::Option>::construct<CCustomMenu::Option,CCustomMenu::Option &>

; 858  : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$construct@UOption@CCustomMenu@@AAU12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@AAU34@@Z ENDP ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUOption@CCustomMenu@@@std@@YAAAUOption@CCustomMenu@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUOption@CCustomMenu@@@std@@YAAAUOption@CCustomMenu@@AAU12@@Z PROC ; std::forward<CCustomMenu::Option &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@AAUOption@CCustomMenu@@@std@@YAAAUOption@CCustomMenu@@AAU12@@Z ENDP ; std::forward<CCustomMenu::Option &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 141  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 142  : 			return (_Ok);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 143  : 			}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

  00042	8b f4		 mov	 esi, esp
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	0f b6 c0	 movzx	 eax, al
  00054	85 c0		 test	 eax, eax
  00056	75 14		 jne	 SHORT $LN1@sentry

; 133  : 				this->_Myostr._Osfx();

  00058	8b f4		 mov	 esi, esp
  0005a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 122  : 			: _Sentry_base(_Ostr)

  00042	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00045	50		 push	 eax
  00046	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00055	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0005d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00060	8b f4		 mov	 esi, esp
  00062	8b ca		 mov	 ecx, edx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	0f b6 c0	 movzx	 eax, al
  00074	85 c0		 test	 eax, eax
  00076	74 6e		 je	 SHORT $LN2@sentry
  00078	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00080	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00083	8b f4		 mov	 esi, esp
  00085	8b ca		 mov	 ecx, edx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0008d	3b f4		 cmp	 esi, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	85 c0		 test	 eax, eax
  00096	74 4e		 je	 SHORT $LN2@sentry
  00098	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0009b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000a0	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000a3	8b f4		 mov	 esi, esp
  000a5	8b ca		 mov	 ecx, edx
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	3b 45 08	 cmp	 eax, DWORD PTR __Ostr$[ebp]
  000b7	74 2d		 je	 SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

  000b9	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000be	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000c1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000c4	8b f4		 mov	 esi, esp
  000c6	8b ca		 mov	 ecx, edx
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	8b f4		 mov	 esi, esp
  000d7	8b c8		 mov	 ecx, eax
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  000df	3b f4		 cmp	 esi, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@sentry:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  000e6	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000eb	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000ee	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000f1	8b f4		 mov	 esi, esp
  000f3	8b ca		 mov	 ecx, edx
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  000fb	3b f4		 cmp	 esi, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 127  : 			}

  00108	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0010f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00112	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00115	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011c	59		 pop	 ecx
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00126	3b ec		 cmp	 ebp, esp
  00128	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv92 = -224						; size = 4
tv86 = -220						; size = 4
tv72 = -220						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00021	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 107  : 			if (_Myostr.rdbuf() != 0)

  00042	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  0004d	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  00053	8b 02		 mov	 eax, DWORD PTR [edx]
  00055	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  0005b	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0005e	8b f4		 mov	 esi, esp
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	85 c0		 test	 eax, eax
  0006f	74 4d		 je	 SHORT $LN3@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

  00071	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv86[ebp], ecx
  0007c	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv86[ebp]
  00082	8b 02		 mov	 eax, DWORD PTR [edx]
  00084	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv86[ebp]
  0008a	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0008d	8b f4		 mov	 esi, esp
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00095	3b f4		 cmp	 esi, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv92[ebp], eax
  000a2	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv92[ebp]
  000a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000aa	8b f4		 mov	 esi, esp
  000ac	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv92[ebp]
  000b2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b5	ff d0		 call	 eax
  000b7	3b f4		 cmp	 esi, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Sentry_bas:

; 109  : 			}

  000be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c8	59		 pop	 ecx
  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  000d2	3b ec		 cmp	 ebp, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 1c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-228]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv93 = -212						; size = 4
tv87 = -208						; size = 4
tv73 = -208						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00013	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 			: _Myostr(_Ostr)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 101  : 			if (_Myostr.rdbuf() != 0)

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  00036	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  0003c	8b 02		 mov	 eax, DWORD PTR [edx]
  0003e	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  00044	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00047	8b f4		 mov	 esi, esp
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	85 c0		 test	 eax, eax
  00058	74 4d		 je	 SHORT $LN1@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005f	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv87[ebp], ecx
  00065	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv87[ebp]
  0006b	8b 02		 mov	 eax, DWORD PTR [edx]
  0006d	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv87[ebp]
  00073	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00076	8b f4		 mov	 esi, esp
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  0008b	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  00091	8b 11		 mov	 edx, DWORD PTR [ecx]
  00093	8b f4		 mov	 esi, esp
  00095	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  0009b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0009e	ff d0		 call	 eax
  000a0	3b f4		 cmp	 esi, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Sentry_bas:

; 103  : 			}

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
tv176 = -268						; size = 4
tv175 = -264						; size = 4
tv168 = -264						; size = 4
tv172 = -260						; size = 4
tv165 = -260						; size = 4
tv179 = -256						; size = 4
tv171 = -256						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
$T4 = -224						; size = 4
$T5 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Pred$ = 32						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >,std::less<void> >, COMDAT

; 2782 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00020	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 2783 : 	_DEBUG_RANGE(_First, _Last);

  00044	68 df 0a 00 00	 push	 2783			; 00000adfH
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0004e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00051	8b cc		 mov	 ecx, esp
  00053	89 a5 2c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], esp
  00059	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  00062	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv179[ebp], eax
  00068	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv179[ebp]
  0006e	89 8d fc fe ff
	ff		 mov	 DWORD PTR tv165[ebp], ecx
  00074	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00078	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0007b	8b cc		 mov	 ecx, esp
  0007d	89 a5 20 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], esp
  00083	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  0008c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv168[ebp], eax
  00092	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00096	e8 00 00 00 00	 call	 ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
  0009b	83 c4 20	 add	 esp, 32			; 00000020H

; 2784 : 	_Sort_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);

  0009e	8d 45 20	 lea	 eax, DWORD PTR __Pred$[ebp]
  000a1	50		 push	 eax
  000a2	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000a5	8b cc		 mov	 ecx, esp
  000a7	89 a5 14 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  000ad	8d 55 14	 lea	 edx, DWORD PTR __Last$[ebp]
  000b0	52		 push	 edx
  000b1	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  000b6	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv171[ebp], eax
  000bc	e8 00 00 00 00	 call	 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c4	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv172[ebp], eax
  000ca	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv172[ebp]
  000d0	50		 push	 eax
  000d1	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000d4	8b cc		 mov	 ecx, esp
  000d6	89 a5 08 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], esp
  000dc	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  000df	52		 push	 edx
  000e0	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  000e5	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv175[ebp], eax
  000eb	e8 00 00 00 00	 call	 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f3	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv176[ebp], eax
  000f9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUOption@CCustomMenu@@U?$less@X@std@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$less@X@0@@Z ; std::_Sort_unchecked<CCustomMenu::Option *,std::less<void> >
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2785 : 	}

  00108	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0010c	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0010f	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  00114	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0011b	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  0011e	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  00123	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00126	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012d	59		 pop	 ecx
  0012e	5f		 pop	 edi
  0012f	5e		 pop	 esi
  00130	5b		 pop	 ebx
  00131	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00137	3b ec		 cmp	 ebp, esp
  00139	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z$2:
  00010	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 8a f0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-272]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >,std::less<void> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@AAV10@PAUOption@CCustomMenu@@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@AAV10@PAUOption@CCustomMenu@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >, COMDAT

; 411  : 	{	// convert to checked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 412  : 	return (_Iter._Rechecked(_Right));

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Iter$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV12@PAUOption@CCustomMenu@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Rechecked

; 413  : 	}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@AAV10@PAUOption@CCustomMenu@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Find_unchecked@PAUOption@CCustomMenu@@D@std@@YAPAUOption@CCustomMenu@@PAU12@0ABD@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find_unchecked@PAUOption@CCustomMenu@@D@std@@YAPAUOption@CCustomMenu@@PAU12@0ABD@Z PROC ; std::_Find_unchecked<CCustomMenu::Option *,char>, COMDAT

; 3266 : 	{	// find first matching _Val; choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3267 : 	// activate optimization for pointers to (const) bytes and integral values
; 3268 : 	typedef integral_constant<bool,
; 3269 : 		(is_same<_InIt, char *>::value
; 3270 : 		|| is_same<_InIt, signed char *>::value
; 3271 : 		|| is_same<_InIt, unsigned char *>::value
; 3272 : 		|| is_same<_InIt, const char *>::value
; 3273 : 		|| is_same<_InIt, const signed char *>::value
; 3274 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3275 : 		&& is_integral<_Ty>::value
; 3276 : 	> _Memchr_opt;
; 3277 : 	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));

  0001e	0f b6 85 3b ff
	ff ff		 movzx	 eax, BYTE PTR $T1[ebp]
  00025	50		 push	 eax
  00026	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Find_unchecked1@PAUOption@CCustomMenu@@D@std@@YAPAUOption@CCustomMenu@@PAU12@0ABDU?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<CCustomMenu::Option *,char>
  00037	83 c4 10	 add	 esp, 16			; 00000010H

; 3278 : 	}

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$_Find_unchecked@PAUOption@CCustomMenu@@D@std@@YAPAUOption@CCustomMenu@@PAU12@0ABD@Z ENDP ; std::_Find_unchecked<CCustomMenu::Option *,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Iter$ = 8						; size = 12
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >, COMDAT

; 402  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00020	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 403  : 	return (_Iter._Unchecked());

  00044	8d 4d 08	 lea	 ecx, DWORD PTR __Iter$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPAUOption@CCustomMenu@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Unchecked
  0004c	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00052	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00059	8d 4d 08	 lea	 ecx, DWORD PTR __Iter$[ebp]
  0005c	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  00061	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 404  : 	}

  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR __Iter$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z
_TEXT	SEGMENT
tv140 = -252						; size = 4
tv137 = -248						; size = 4
tv143 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
$T4 = -209						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z PROC ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >, COMDAT

; 966  : 	{	// test iterator pair for valid range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00020	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 967  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat_t<_InIt>());

  00044	33 c0		 xor	 eax, eax
  00046	88 85 2f ff ff
	ff		 mov	 BYTE PTR $T4[ebp], al
  0004c	0f b6 8d 2f ff
	ff ff		 movzx	 ecx, BYTE PTR $T4[ebp]
  00053	51		 push	 ecx
  00054	8b 55 24	 mov	 edx, DWORD PTR __Line$[ebp]
  00057	52		 push	 edx
  00058	8b 45 20	 mov	 eax, DWORD PTR __File$[ebp]
  0005b	50		 push	 eax
  0005c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0005f	8b cc		 mov	 ecx, esp
  00061	89 a5 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  00067	8d 55 14	 lea	 edx, DWORD PTR __Last$[ebp]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  00070	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv143[ebp], eax
  00076	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv143[ebp]
  0007c	89 85 08 ff ff
	ff		 mov	 DWORD PTR tv137[ebp], eax
  00082	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00086	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00089	8b cc		 mov	 ecx, esp
  0008b	89 a5 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], esp
  00091	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  0009a	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv140[ebp], eax
  000a0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000a4	e8 00 00 00 00	 call	 ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
  000a9	83 c4 24	 add	 esp, 36			; 00000024H

; 968  : 	}

  000ac	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000b0	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  000b3	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  000b8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000bf	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  000c2	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  000c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d1	59		 pop	 ecx
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  000db	3b ec		 cmp	 ebp, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z$2:
  00010	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 8a 00 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-256]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z ENDP ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 725  : 	return (__builtin_addressof(_Val));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z PROC ; std::pointer_traits<std::_Container_proxy *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 280  : 		return (_STD addressof(_Val));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00027	83 c4 04	 add	 esp, 4

; 281  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ENDP ; std::pointer_traits<std::_Container_proxy *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > &>, COMDAT
; _this$ = ecx

; 952  : 		{	// construct from a related allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 951  : 		: _Mybase(_STD forward<_Other>(_Right))

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>

; 953  : 		}

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??$?0AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CCustomMenu::Option>,CCustomMenu::Option *>, COMDAT

; 1114 : 	{	// destroy [_First, _Last), choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

  0001e	0f b6 85 3b ff
	ff ff		 movzx	 eax, BYTE PTR $T1[ebp]
  00025	50		 push	 eax
  00026	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Destroy_range1@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<CCustomMenu::Option>,CCustomMenu::Option *>
  00037	83 c4 10	 add	 esp, 16			; 00000010H

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$_Destroy_range@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CCustomMenu::Option>,CCustomMenu::Option *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUOption@CCustomMenu@@@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEPAUOption@CCustomMenu@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUOption@CCustomMenu@@@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEPAUOption@CCustomMenu@@PAU23@00@Z PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Umove<CCustomMenu::Option *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1659 : 		return (_Uninitialized_move(_First, _Last,

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  0002b	50		 push	 eax
  0002c	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUOption@CCustomMenu@@PAU12@V?$allocator@UOption@CCustomMenu@@@std@@@std@@YAPAUOption@CCustomMenu@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z ; std::_Uninitialized_move<CCustomMenu::Option *,CCustomMenu::Option *,std::allocator<CCustomMenu::Option> >
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 1660 : 			_Ptr, this->_Getal()));
; 1661 : 		}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUOption@CCustomMenu@@@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEPAUOption@CCustomMenu@@PAU23@00@Z ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Umove<CCustomMenu::Option *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 740  : 	return (_Ptr);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
  00030	83 c4 08	 add	 esp, 8

; 1004 : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<CCustomMenu::Option> > &>, COMDAT
; _this$ = ecx

; 952  : 		{	// construct from a related allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 951  : 		: _Mybase(_STD forward<_Other>(_Right))

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> > &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??$?0UOption@CCustomMenu@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UOption@CCustomMenu@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><CCustomMenu::Option>

; 953  : 		}

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??$?0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<CCustomMenu::Option> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 988  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 976  : 		return (_Mybase::allocate(_Count));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate

; 977  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ; std::pointer_traits<std::_Container_proxy *>::pointer_to
  0002c	83 c4 04	 add	 esp, 4

; 927  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00023	6a 01		 push	 1
  00025	6a 08		 push	 8
  00027	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 726  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00023	6a 08		 push	 8
  00025	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 721  : 		}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z
_TEXT	SEGMENT
__Test$ = 8						; size = 1
__Ptr$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z PROC	; std::_Debug_pointer_if<char const >, COMDAT

; 937  : 	{	// conditionally test pointer for non-singularity, pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 938  : 	if (_Test && _Ptr == 0)

  0001e	0f b6 45 08	 movzx	 eax, BYTE PTR __Test$[ebp]
  00022	85 c0		 test	 eax, eax
  00024	74 25		 je	 SHORT $LN1@Debug_poin
  00026	83 7d 0c 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0002a	75 1f		 jne	 SHORT $LN1@Debug_poin

; 939  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

  0002c	8b f4		 mov	 esi, esp
  0002e	8b 45 14	 mov	 eax, DWORD PTR __Line$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __File$[ebp]
  00035	51		 push	 ecx
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	3b f4		 cmp	 esi, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Debug_poin:

; 940  : 	}

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z ENDP	; std::_Debug_pointer_if<char const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 740  : 	return (_Ptr);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
  00030	83 c4 08	 add	 esp, 8

; 1004 : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 725  : 	return (__builtin_addressof(_Val));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 280  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 281  : 		}

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Tag$ = -5						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1043 : 	{	// (maybe) propagate on container copy assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);

  0001e	0f b6 45 fb	 movzx	 eax, BYTE PTR __Tag$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1046 : 	}

  00033	52		 push	 edx
  00034	8b cd		 mov	 ecx, ebp
  00036	50		 push	 eax
  00037	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Pocca
  0003d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00042	58		 pop	 eax
  00043	5a		 pop	 edx
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN5@Pocca:
  00058	01 00 00 00	 DD	 1
  0005c	00 00 00 00	 DD	 $LN4@Pocca
$LN4@Pocca:
  00060	fb ff ff ff	 DD	 -5			; fffffffbH
  00064	01 00 00 00	 DD	 1
  00068	00 00 00 00	 DD	 $LN3@Pocca
$LN3@Pocca:
  0006c	5f		 DB	 95			; 0000005fH
  0006d	54		 DB	 84			; 00000054H
  0006e	61		 DB	 97			; 00000061H
  0006f	67		 DB	 103			; 00000067H
  00070	00		 DB	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 952  : 		{	// construct from a related allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 951  : 		: _Mybase(_STD forward<_Other>(_Right))

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>

; 953  : 		}

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1><>, COMDAT
; _this$ = ecx

; 280  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::_Wrap_alloc<std::allocator<CCustomMenu::Option> >
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >::_Vector_val<std::_Simple_types<CCustomMenu::Option> >

; 281  : 		}

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00021	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 620  : 		: _Mypair(_One_then_variadic_args_t(),

  00042	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
  0004b	83 c4 04	 add	 esp, 4
  0004e	50		 push	 eax
  0004f	0f b6 8d 23 ff
	ff ff		 movzx	 ecx, BYTE PTR $T2[ebp]
  00056	51		 push	 ecx
  00057	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 623  : 		_Alloc_proxy();

  00066	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 624  : 		}

  0006e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0008c	3b ec		 cmp	 ebp, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 1025 : 	{	// test for allocator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1026 : 	return (!(_Left == _Right));

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator==<std::allocator<char>,std::allocator<char> >
  0002b	83 c4 08	 add	 esp, 8
  0002e	0f b6 d0	 movzx	 edx, al
  00031	85 d2		 test	 edx, edx
  00033	75 0c		 jne	 SHORT $LN3@operator
  00035	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00041	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0004b	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]

; 1027 : 	}

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@$$QAU01@@Z
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00035	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00038	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00035	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00038	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 254  : 		if (this->_Getcont() != _Right._Getcont())

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00035	3b f0		 cmp	 esi, eax
  00037	0f 84 86 00 00
	00		 je	 $LN1@Compat

; 255  : 			{
; 256  : 			_DEBUG_ERROR("string iterators incompatible");

  0003d	8b f4		 mov	 esi, esp
  0003f	68 00 01 00 00	 push	 256			; 00000100H
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@EADHKMNI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 257  : 			_SCL_SECURE_INVALID_ARGUMENT;

  0005e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
  00063	85 c0		 test	 eax, eax
  00065	74 04		 je	 SHORT $LN4@Compat
  00067	33 c9		 xor	 ecx, ecx
  00069	75 30		 jne	 SHORT $LN5@Compat
$LN4@Compat:
  0006b	8b f4		 mov	 esi, esp
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00077	6a 00		 push	 0
  00079	68 01 01 00 00	 push	 257			; 00000101H
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@EADHKMNI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00083	6a 02		 push	 2
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0008b	83 c4 18	 add	 esp, 24			; 00000018H
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	83 f8 01	 cmp	 eax, 1
  00098	75 01		 jne	 SHORT $LN5@Compat
  0009a	cc		 int	 3
$LN5@Compat:
  0009b	8b f4		 mov	 esi, esp
  0009d	6a 00		 push	 0
  0009f	68 01 01 00 00	 push	 257			; 00000101H
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@EADHKMNI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000b9	83 c4 14	 add	 esp, 20			; 00000014H
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Compat:

; 258  : 			}
; 259  : 		}

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000cc	3b ec		 cmp	 ebp, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 04 00	 ret	 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==, COMDAT
; _this$ = ecx

; 220  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 221  : 		_Compat(_Right);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat

; 222  : 		return (_Ptr == _Right._Ptr);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00035	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00038	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003b	75 0c		 jne	 SHORT $LN3@operator
  0003d	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  00047	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00049	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00053	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]

; 223  : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 209  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 210  : 		_Compat(_Right);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat

; 211  : 		return (_Ptr - _Right._Ptr);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00035	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00038	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]

; 212  : 		}

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
tv77 = -232						; size = 4
__Contptr$ = -32					; size = 4
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 67   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 68   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 69   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002b	89 45 ec	 mov	 DWORD PTR __Mycont$[ebp], eax

; 70   : 		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;

  0002e	83 7d ec 00	 cmp	 DWORD PTR __Mycont$[ebp], 0
  00032	74 10		 je	 SHORT $LN5@operator
  00034	8b 4d ec	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0003c	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00042	eb 0a		 jmp	 SHORT $LN6@operator
$LN5@operator:
  00044	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
$LN6@operator:
  0004e	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  00054	89 45 e0	 mov	 DWORD PTR __Contptr$[ebp], eax

; 71   : 		if (_Mycont == 0
; 72   : 			|| _Ptr == nullptr_t{}
; 73   : 			|| _Unfancy(_Ptr) < _Contptr
; 74   : 			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))

  00057	83 7d ec 00	 cmp	 DWORD PTR __Mycont$[ebp], 0
  0005b	74 39		 je	 SHORT $LN3@operator
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00060	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00064	74 30		 je	 SHORT $LN3@operator
  00066	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ??$_Unfancy@$$CBD@std@@YAPBDPBD@Z ; std::_Unfancy<char const >
  00072	83 c4 04	 add	 esp, 4
  00075	3b 45 e0	 cmp	 eax, DWORD PTR __Contptr$[ebp]
  00078	72 1c		 jb	 SHORT $LN3@operator
  0007a	8b 45 ec	 mov	 eax, DWORD PTR __Mycont$[ebp]
  0007d	8b 75 e0	 mov	 esi, DWORD PTR __Contptr$[ebp]
  00080	03 70 14	 add	 esi, DWORD PTR [eax+20]
  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00089	52		 push	 edx
  0008a	e8 00 00 00 00	 call	 ??$_Unfancy@$$CBD@std@@YAPBDPBD@Z ; std::_Unfancy<char const >
  0008f	83 c4 04	 add	 esp, 4
  00092	3b f0		 cmp	 esi, eax
  00094	77 7d		 ja	 SHORT $LN2@operator
$LN3@operator:

; 75   : 			{	// report error
; 76   : 			_DEBUG_ERROR("string iterator not dereferencable");

  00096	8b f4		 mov	 esi, esp
  00098	6a 4c		 push	 76			; 0000004cH
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@EADHKMNI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 77   : 			_SCL_SECURE_OUT_OF_RANGE;

  000b4	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  000b9	85 c0		 test	 eax, eax
  000bb	74 04		 je	 SHORT $LN7@operator
  000bd	33 c9		 xor	 ecx, ecx
  000bf	75 2d		 jne	 SHORT $LN8@operator
$LN7@operator:
  000c1	8b f4		 mov	 esi, esp
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  000cd	6a 00		 push	 0
  000cf	6a 4d		 push	 77			; 0000004dH
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@EADHKMNI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000d6	6a 02		 push	 2
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  000de	83 c4 18	 add	 esp, 24			; 00000018H
  000e1	3b f4		 cmp	 esi, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e8	83 f8 01	 cmp	 eax, 1
  000eb	75 01		 jne	 SHORT $LN8@operator
  000ed	cc		 int	 3
$LN8@operator:
  000ee	8b f4		 mov	 esi, esp
  000f0	6a 00		 push	 0
  000f2	6a 4d		 push	 77			; 0000004dH
  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@EADHKMNI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00109	83 c4 14	 add	 esp, 20			; 00000014H
  0010c	3b f4		 cmp	 esi, esp
  0010e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 78   : 			}
; 79   : 
; 80   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 81   : 		_SCL_SECURE_VALIDATE(_Ptr != nullptr_t{});
; 82   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 83   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 84   : 		const auto _Contptr = _Mycont->_Myptr();
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(_Contptr <= _Unfancy(_Ptr) && _Unfancy(_Ptr) < _Contptr + _Mycont->_Mysize);
; 86   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 87   : 
; 88   : 		_Analysis_assume_(_Ptr != nullptr_t{});
; 89   : 
; 90   : 		return (*_Ptr);

  00113	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00116	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 91   : 		}

  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00122	3b ec		 cmp	 ebp, esp
  00124	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 49   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 48   : 		: _Ptr(_Parg)

  00051	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00057	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 50   : 		this->_Adopt(_Pstring);

  0005a	8b 45 0c	 mov	 eax, DWORD PTR __Pstring$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 51   : 		}

  00066	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@$$QAU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@$$QAU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UOption@CCustomMenu@@ABU12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UOption@CCustomMenu@@ABU12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@ABUOption@CCustomMenu@@@std@@YAABUOption@CCustomMenu@@ABU12@@Z ; std::forward<CCustomMenu::Option const &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??$construct@UOption@CCustomMenu@@ABU12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@ABU34@@Z ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option const &>
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
??$construct@UOption@CCustomMenu@@ABU12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UOption@CCustomMenu@@AAU12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UOption@CCustomMenu@@AAU12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@AAUOption@CCustomMenu@@@std@@YAAAUOption@CCustomMenu@@AAU12@@Z ; std::forward<CCustomMenu::Option &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??$construct@UOption@CCustomMenu@@AAU12@@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAXAAV?$allocator@UOption@CCustomMenu@@@1@PAUOption@CCustomMenu@@AAU34@@Z ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option &>
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
??$construct@UOption@CCustomMenu@@AAU12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z PROC ; std::_Unfancy<CCustomMenu::Option>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 740  : 	return (_Ptr);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ENDP ; std::_Unfancy<CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUOption@CCustomMenu@@@std@@YAPBUOption@CCustomMenu@@ABU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUOption@CCustomMenu@@@std@@YAPBUOption@CCustomMenu@@ABU12@@Z PROC ; std::addressof<CCustomMenu::Option const >, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 725  : 	return (__builtin_addressof(_Val));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$addressof@$$CBUOption@CCustomMenu@@@std@@YAPBUOption@CCustomMenu@@ABU12@@Z ENDP ; std::addressof<CCustomMenu::Option const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PBUOption@CCustomMenu@@@std@@SAPBUOption@CCustomMenu@@ABU34@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PBUOption@CCustomMenu@@@std@@SAPBUOption@CCustomMenu@@ABU34@@Z PROC ; std::pointer_traits<CCustomMenu::Option const *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 280  : 		return (_STD addressof(_Val));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$addressof@$$CBUOption@CCustomMenu@@@std@@YAPBUOption@CCustomMenu@@ABU12@@Z ; std::addressof<CCustomMenu::Option const >
  00027	83 c4 04	 add	 esp, 4

; 281  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?pointer_to@?$pointer_traits@PBUOption@CCustomMenu@@@std@@SAPBUOption@CCustomMenu@@ABU34@@Z ENDP ; std::pointer_traits<CCustomMenu::Option const *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 991  : 	{	// insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 992  : 	_Ostr.put(_Ostr.widen('\n'));

  0001e	8b f4		 mov	 esi, esp
  00020	6a 0a		 push	 10			; 0000000aH
  00022	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0002a	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0002d	8b ca		 mov	 ecx, edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b f4		 mov	 esi, esp
  0003e	0f b6 c0	 movzx	 eax, al
  00041	50		 push	 eax
  00042	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 993  : 	_Ostr.flush();

  00052	8b f4		 mov	 esi, esp
  00054	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 994  : 	return (_Ostr);

  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]

; 995  : 	}

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv411 = -340						; size = 8
tv294 = -332						; size = 4
tv291 = -332						; size = 8
tv289 = -332						; size = 4
tv136 = -332						; size = 4
tv329 = -328						; size = 8
tv293 = -328						; size = 4
tv288 = -328						; size = 4
tv290 = -324						; size = 4
tv138 = -324						; size = 4
tv292 = -321						; size = 1
tv287 = -321						; size = 1
$T2 = -316						; size = 4
$T3 = -304						; size = 4
$T4 = -292						; size = 4
$T5 = -280						; size = 4
$T6 = -268						; size = 4
__Ok$ = -64						; size = 8
__Pad$ = -48						; size = 4
__Size$ = -36						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 170  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d bd ac fe ff
	ff		 lea	 edi, DWORD PTR [ebp-340]
  00021	b9 51 00 00 00	 mov	 ecx, 81			; 00000051H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 171  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 172  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 173  : 	typedef typename _Mystr::size_type _Mysizt;
; 174  : 
; 175  : 	ios_base::iostate _State = ios_base::goodbit;

  00041	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 176  : 	_Mysizt _Size = _Str.size();

  00048	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0004b	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00050	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 177  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size

  00053	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0005b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0005e	8b f4		 mov	 esi, esp
  00060	8b ca		 mov	 ecx, edx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv329[ebp], eax
  00075	89 95 bc fe ff
	ff		 mov	 DWORD PTR tv329[ebp+4], edx
  0007b	83 bd bc fe ff
	ff 00		 cmp	 DWORD PTR tv329[ebp+4], 0
  00082	7c 53		 jl	 SHORT $LN17@operator
  00084	7f 09		 jg	 SHORT $LN24@operator
  00086	83 bd b8 fe ff
	ff 00		 cmp	 DWORD PTR tv329[ebp], 0
  0008d	76 48		 jbe	 SHORT $LN17@operator
$LN24@operator:
  0008f	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00092	8b 08		 mov	 ecx, DWORD PTR [eax]
  00094	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00097	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0009a	8b f4		 mov	 esi, esp
  0009c	8b ca		 mov	 ecx, edx
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000a4	3b f4		 cmp	 esi, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  000ae	76 27		 jbe	 SHORT $LN17@operator
  000b0	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000b8	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000bb	8b f4		 mov	 esi, esp
  000bd	8b ca		 mov	 ecx, edx
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000c5	3b f4		 cmp	 esi, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cc	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  000cf	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv136[ebp], eax
  000d5	eb 0a		 jmp	 SHORT $LN18@operator
$LN17@operator:
  000d7	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
$LN18@operator:
  000e1	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR tv136[ebp]
  000e7	89 45 d0	 mov	 DWORD PTR __Pad$[ebp], eax

; 178  : 		? 0 : (_Mysizt)_Ostr.width() - _Size;
; 179  : 	const typename _Myos::sentry _Ok(_Ostr);

  000ea	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000ed	50		 push	 eax
  000ee	8d 4d c0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000f1	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000f6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 180  : 
; 181  : 	if (!_Ok)

  000fd	8d 4d c0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00100	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00105	0f b6 c0	 movzx	 eax, al
  00108	85 c0		 test	 eax, eax
  0010a	75 0e		 jne	 SHORT $LN8@operator

; 182  : 		_State |= ios_base::badbit;

  0010c	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  0010f	83 c8 04	 or	 eax, 4
  00112	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax

; 183  : 	else

  00115	e9 aa 02 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 184  : 		{	// state okay, insert characters
; 185  : 	_TRY_IO_BEGIN

  0011a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 186  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  0011e	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00121	8b 08		 mov	 ecx, DWORD PTR [eax]
  00123	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00126	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00129	8b f4		 mov	 esi, esp
  0012b	8b ca		 mov	 ecx, edx
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  00133	3b f4		 cmp	 esi, esp
  00135	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013a	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv138[ebp], eax
  00140	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR tv138[ebp]
  00146	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  0014b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0014e	0f 84 c0 00 00
	00		 je	 $LN11@operator

; 187  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00154	eb 09		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00156	8b 45 d0	 mov	 eax, DWORD PTR __Pad$[ebp]
  00159	83 e8 01	 sub	 eax, 1
  0015c	89 45 d0	 mov	 DWORD PTR __Pad$[ebp], eax
$LN4@operator:
  0015f	83 7d d0 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00163	0f 86 ab 00 00
	00		 jbe	 $LN11@operator

; 188  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00169	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0016c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00171	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00174	8b f4		 mov	 esi, esp
  00176	8b ca		 mov	 ecx, edx
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0017e	3b f4		 cmp	 esi, esp
  00180	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00185	88 85 bf fe ff
	ff		 mov	 BYTE PTR tv287[ebp], al
  0018b	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0018e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00190	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00193	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00196	8b f4		 mov	 esi, esp
  00198	8b ca		 mov	 ecx, edx
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001a0	3b f4		 cmp	 esi, esp
  001a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a7	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv288[ebp], eax
  001ad	8b f4		 mov	 esi, esp
  001af	0f b6 85 bf fe
	ff ff		 movzx	 eax, BYTE PTR tv287[ebp]
  001b6	50		 push	 eax
  001b7	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR tv288[ebp]
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001c3	3b f4		 cmp	 esi, esp
  001c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ca	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv289[ebp], eax
  001d0	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv289[ebp]
  001d6	89 8d f4 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
  001dc	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  001e1	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  001e7	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  001ed	52		 push	 edx
  001ee	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  001fa	83 c4 08	 add	 esp, 8
  001fd	0f b6 c8	 movzx	 ecx, al
  00200	85 c9		 test	 ecx, ecx
  00202	74 0b		 je	 SHORT $LN12@operator

; 189  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 190  : 					{	// insertion failed, quit
; 191  : 					_State |= ios_base::badbit;

  00204	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  00207	83 c8 04	 or	 eax, 4
  0020a	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax

; 192  : 					break;

  0020d	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 193  : 					}
; 194  : 
; 195  : 		if (_State == ios_base::goodbit

  0020f	e9 42 ff ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 196  : 			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)

  00214	83 7d e8 00	 cmp	 DWORD PTR __State$[ebp], 0
  00218	0f 85 8e 00 00
	00		 jne	 $LN13@operator
  0021e	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00221	8b 08		 mov	 ecx, DWORD PTR [eax]
  00223	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00226	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00229	8b f4		 mov	 esi, esp
  0022b	8b ca		 mov	 ecx, edx
  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00233	3b f4		 cmp	 esi, esp
  00235	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023a	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv290[ebp], eax
  00240	8b 45 dc	 mov	 eax, DWORD PTR __Size$[ebp]
  00243	33 c9		 xor	 ecx, ecx
  00245	8b f4		 mov	 esi, esp
  00247	51		 push	 ecx
  00248	50		 push	 eax
  00249	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0024c	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00251	50		 push	 eax
  00252	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv290[ebp]
  00258	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  0025e	3b f4		 cmp	 esi, esp
  00260	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00265	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv291[ebp], eax
  0026b	89 95 b8 fe ff
	ff		 mov	 DWORD PTR tv291[ebp+4], edx
  00271	8b 55 dc	 mov	 edx, DWORD PTR __Size$[ebp]
  00274	33 c0		 xor	 eax, eax
  00276	89 95 ac fe ff
	ff		 mov	 DWORD PTR tv411[ebp], edx
  0027c	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv411[ebp+4], eax
  00282	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv291[ebp]
  00288	3b 8d ac fe ff
	ff		 cmp	 ecx, DWORD PTR tv411[ebp]
  0028e	75 0e		 jne	 SHORT $LN25@operator
  00290	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv291[ebp+4]
  00296	3b 95 b0 fe ff
	ff		 cmp	 edx, DWORD PTR tv411[ebp+4]
  0029c	74 0e		 je	 SHORT $LN13@operator
$LN25@operator:

; 197  : 				!= (streamsize)_Size)
; 198  : 				_State |= ios_base::badbit;

  0029e	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  002a1	83 c8 04	 or	 eax, 4
  002a4	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax

; 199  : 		else

  002a7	e9 c0 00 00 00	 jmp	 $LN14@operator
$LN13@operator:

; 200  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  002ac	eb 09		 jmp	 SHORT $LN7@operator
$LN5@operator:
  002ae	8b 45 d0	 mov	 eax, DWORD PTR __Pad$[ebp]
  002b1	83 e8 01	 sub	 eax, 1
  002b4	89 45 d0	 mov	 DWORD PTR __Pad$[ebp], eax
$LN7@operator:
  002b7	83 7d d0 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  002bb	0f 86 ab 00 00
	00		 jbe	 $LN14@operator

; 201  : 				if (_Traits::eq_int_type(_Traits::eof(),

  002c1	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c6	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002c9	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002cc	8b f4		 mov	 esi, esp
  002ce	8b ca		 mov	 ecx, edx
  002d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  002d6	3b f4		 cmp	 esi, esp
  002d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002dd	88 85 bf fe ff
	ff		 mov	 BYTE PTR tv292[ebp], al
  002e3	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e8	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002eb	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002ee	8b f4		 mov	 esi, esp
  002f0	8b ca		 mov	 ecx, edx
  002f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002f8	3b f4		 cmp	 esi, esp
  002fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ff	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv293[ebp], eax
  00305	8b f4		 mov	 esi, esp
  00307	0f b6 85 bf fe
	ff ff		 movzx	 eax, BYTE PTR tv292[ebp]
  0030e	50		 push	 eax
  0030f	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR tv293[ebp]
  00315	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0031b	3b f4		 cmp	 esi, esp
  0031d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00322	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv294[ebp], eax
  00328	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv294[ebp]
  0032e	89 8d dc fe ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  00334	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  00339	89 85 d0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0033f	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00345	52		 push	 edx
  00346	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0034c	50		 push	 eax
  0034d	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  00352	83 c4 08	 add	 esp, 8
  00355	0f b6 c8	 movzx	 ecx, al
  00358	85 c9		 test	 ecx, ecx
  0035a	74 0b		 je	 SHORT $LN15@operator

; 202  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 203  : 					{	// insertion failed, quit
; 204  : 					_State |= ios_base::badbit;

  0035c	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  0035f	83 c8 04	 or	 eax, 4
  00362	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax

; 205  : 					break;

  00365	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 206  : 					}

  00367	e9 42 ff ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 207  : 		_Ostr.width(0);

  0036c	8b f4		 mov	 esi, esp
  0036e	6a 00		 push	 0
  00370	6a 00		 push	 0
  00372	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00375	8b 08		 mov	 ecx, DWORD PTR [eax]
  00377	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0037a	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0037d	8b ca		 mov	 ecx, edx
  0037f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  00385	3b f4		 cmp	 esi, esp
  00387	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0038c	eb 26		 jmp	 SHORT $LN19@operator
__catch$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:

; 208  : 		_CATCH_IO_(_Ostr)

  0038e	8b f4		 mov	 esi, esp
  00390	6a 01		 push	 1
  00392	6a 04		 push	 4
  00394	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00397	8b 08		 mov	 ecx, DWORD PTR [eax]
  00399	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0039c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0039f	8b ca		 mov	 ecx, edx
  003a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003a7	3b f4		 cmp	 esi, esp
  003a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003ae	b8 00 00 00 00	 mov	 eax, $LN23@operator
  003b3	c3		 ret	 0
$LN19@operator:
  003b4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  003bb	eb 07		 jmp	 SHORT $LN9@operator
$LN23@operator:
  003bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 209  : 		}
; 210  : 
; 211  : 	_Ostr.setstate(_State);

  003c4	8b f4		 mov	 esi, esp
  003c6	6a 00		 push	 0
  003c8	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  003cb	50		 push	 eax
  003cc	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003cf	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d1	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003d4	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  003d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003dd	3b f4		 cmp	 esi, esp
  003df	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 212  : 	return (_Ostr);

  003e4	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003e7	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  003ed	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  003f4	8d 4d c0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  003f7	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  003fc	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 213  : 	}

  00402	52		 push	 edx
  00403	8b cd		 mov	 ecx, ebp
  00405	50		 push	 eax
  00406	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN29@operator
  0040c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00411	58		 pop	 eax
  00412	5a		 pop	 edx
  00413	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00416	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0041d	59		 pop	 ecx
  0041e	5f		 pop	 edi
  0041f	5e		 pop	 esi
  00420	5b		 pop	 ebx
  00421	81 c4 54 01 00
	00		 add	 esp, 340		; 00000154H
  00427	3b ec		 cmp	 ebp, esp
  00429	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0042e	8b e5		 mov	 esp, ebp
  00430	5d		 pop	 ebp
  00431	c3		 ret	 0
  00432	66 90		 npad	 2
$LN29@operator:
  00434	01 00 00 00	 DD	 1
  00438	00 00 00 00	 DD	 $LN28@operator
$LN28@operator:
  0043c	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00440	08 00 00 00	 DD	 8
  00444	00 00 00 00	 DD	 $LN26@operator
$LN26@operator:
  00448	5f		 DB	 95			; 0000005fH
  00449	4f		 DB	 79			; 0000004fH
  0044a	6b		 DB	 107			; 0000006bH
  0044b	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a a8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-344]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv135 = -352						; size = 8
tv342 = -344						; size = 8
tv290 = -340						; size = 4
tv287 = -340						; size = 8
tv285 = -340						; size = 4
tv328 = -336						; size = 8
tv289 = -336						; size = 4
tv284 = -336						; size = 4
tv286 = -332						; size = 4
tv137 = -332						; size = 4
tv288 = -329						; size = 1
tv283 = -329						; size = 1
$T2 = -324						; size = 4
$T3 = -312						; size = 4
$T4 = -300						; size = 4
$T5 = -288						; size = 4
$T6 = -276						; size = 4
__Ok$ = -72						; size = 8
__Pad$ = -56						; size = 8
__Count$ = -40						; size = 8
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 780  : 	{	// insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00021	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 781  : 	typedef char _Elem;
; 782  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 783  : 	ios_base::iostate _State = ios_base::goodbit;

  00041	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 784  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

  00048	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  00051	83 c4 04	 add	 esp, 4
  00054	33 c9		 xor	 ecx, ecx
  00056	89 45 d8	 mov	 DWORD PTR __Count$[ebp], eax
  00059	89 4d dc	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b f4		 mov	 esi, esp
  00069	8b ca		 mov	 ecx, edx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv328[ebp], eax
  0007e	89 95 b4 fe ff
	ff		 mov	 DWORD PTR tv328[ebp+4], edx
  00084	83 bd b4 fe ff
	ff 00		 cmp	 DWORD PTR tv328[ebp+4], 0
  0008b	7c 79		 jl	 SHORT $LN17@operator
  0008d	7f 09		 jg	 SHORT $LN24@operator
  0008f	83 bd b0 fe ff
	ff 00		 cmp	 DWORD PTR tv328[ebp], 0
  00096	76 6e		 jbe	 SHORT $LN17@operator
$LN24@operator:
  00098	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0009b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000a0	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000a3	8b f4		 mov	 esi, esp
  000a5	8b ca		 mov	 ecx, edx
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv342[ebp], eax
  000ba	89 95 ac fe ff
	ff		 mov	 DWORD PTR tv342[ebp+4], edx
  000c0	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv342[ebp+4]
  000c6	3b 45 dc	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  000c9	7c 3b		 jl	 SHORT $LN17@operator
  000cb	7f 0b		 jg	 SHORT $LN25@operator
  000cd	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR tv342[ebp]
  000d3	3b 4d d8	 cmp	 ecx, DWORD PTR __Count$[ebp]
  000d6	76 2e		 jbe	 SHORT $LN17@operator
$LN25@operator:
  000d8	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000e0	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000e3	8b f4		 mov	 esi, esp
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000eb	3b f4		 cmp	 esi, esp
  000ed	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f2	2b 45 d8	 sub	 eax, DWORD PTR __Count$[ebp]
  000f5	1b 55 dc	 sbb	 edx, DWORD PTR __Count$[ebp+4]
  000f8	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
  000fe	89 95 a4 fe ff
	ff		 mov	 DWORD PTR tv135[ebp+4], edx
  00104	eb 0b		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00106	0f 57 c0	 xorps	 xmm0, xmm0
  00109	66 0f 13 85 a0
	fe ff ff	 movlpd	 QWORD PTR tv135[ebp], xmm0
$LN18@operator:
  00111	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR tv135[ebp]
  00117	89 4d c8	 mov	 DWORD PTR __Pad$[ebp], ecx
  0011a	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR tv135[ebp+4]
  00120	89 55 cc	 mov	 DWORD PTR __Pad$[ebp+4], edx

; 786  : 		? 0 : _Ostr.width() - _Count;
; 787  : 	const typename _Myos::sentry _Ok(_Ostr);

  00123	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00126	50		 push	 eax
  00127	8d 4d b8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0012a	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  0012f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 788  : 
; 789  : 	if (!_Ok)

  00136	8d 4d b8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00139	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  0013e	0f b6 c0	 movzx	 eax, al
  00141	85 c0		 test	 eax, eax
  00143	75 0e		 jne	 SHORT $LN8@operator

; 790  : 		_State |= ios_base::badbit;

  00145	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  00148	83 c8 04	 or	 eax, 4
  0014b	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax

; 791  : 	else

  0014e	e9 ba 02 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 792  : 		{	// state okay, insert
; 793  : 		_TRY_IO_BEGIN

  00153	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 794  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  00157	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0015a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0015f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00162	8b f4		 mov	 esi, esp
  00164	8b ca		 mov	 ecx, edx
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  0016c	3b f4		 cmp	 esi, esp
  0016e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00173	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv137[ebp], eax
  00179	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR tv137[ebp]
  0017f	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00184	83 f8 40	 cmp	 eax, 64			; 00000040H
  00187	0f 84 d5 00 00
	00		 je	 $LN11@operator

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  0018d	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:
  0018f	8b 45 c8	 mov	 eax, DWORD PTR __Pad$[ebp]
  00192	83 e8 01	 sub	 eax, 1
  00195	8b 4d cc	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  00198	83 d9 00	 sbb	 ecx, 0
  0019b	89 45 c8	 mov	 DWORD PTR __Pad$[ebp], eax
  0019e	89 4d cc	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
  001a1	83 7d cc 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  001a5	0f 8c b7 00 00
	00		 jl	 $LN11@operator
  001ab	7f 0a		 jg	 SHORT $LN26@operator
  001ad	83 7d c8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  001b1	0f 86 ab 00 00
	00		 jbe	 $LN11@operator
$LN26@operator:

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

  001b7	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  001bc	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001bf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001c2	8b f4		 mov	 esi, esp
  001c4	8b ca		 mov	 ecx, edx
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  001cc	3b f4		 cmp	 esi, esp
  001ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d3	88 85 b7 fe ff
	ff		 mov	 BYTE PTR tv283[ebp], al
  001d9	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001de	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001e1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001e4	8b f4		 mov	 esi, esp
  001e6	8b ca		 mov	 ecx, edx
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001ee	3b f4		 cmp	 esi, esp
  001f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f5	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv284[ebp], eax
  001fb	8b f4		 mov	 esi, esp
  001fd	0f b6 85 b7 fe
	ff ff		 movzx	 eax, BYTE PTR tv283[ebp]
  00204	50		 push	 eax
  00205	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR tv284[ebp]
  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00211	3b f4		 cmp	 esi, esp
  00213	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00218	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv285[ebp], eax
  0021e	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv285[ebp]
  00224	89 8d ec fe ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
  0022a	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  0022f	89 85 e0 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  00235	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  0023b	52		 push	 edx
  0023c	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00242	50		 push	 eax
  00243	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  00248	83 c4 08	 add	 esp, 8
  0024b	0f b6 c8	 movzx	 ecx, al
  0024e	85 c9		 test	 ecx, ecx
  00250	74 0b		 je	 SHORT $LN12@operator

; 797  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 798  : 					{	// insertion failed, quit
; 799  : 					_State |= ios_base::badbit;

  00252	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  00255	83 c8 04	 or	 eax, 4
  00258	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax

; 800  : 					break;

  0025b	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 801  : 					}
; 802  : 
; 803  : 		if (_State == ios_base::goodbit

  0025d	e9 2d ff ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  00262	83 7d e8 00	 cmp	 DWORD PTR __State$[ebp], 0
  00266	75 6e		 jne	 SHORT $LN13@operator
  00268	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0026b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0026d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00270	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00273	8b f4		 mov	 esi, esp
  00275	8b ca		 mov	 ecx, edx
  00277	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0027d	3b f4		 cmp	 esi, esp
  0027f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00284	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv286[ebp], eax
  0028a	8b f4		 mov	 esi, esp
  0028c	8b 45 dc	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0028f	50		 push	 eax
  00290	8b 4d d8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00293	51		 push	 ecx
  00294	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00297	52		 push	 edx
  00298	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv286[ebp]
  0029e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  002a4	3b f4		 cmp	 esi, esp
  002a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ab	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv287[ebp], eax
  002b1	89 95 b0 fe ff
	ff		 mov	 DWORD PTR tv287[ebp+4], edx
  002b7	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv287[ebp]
  002bd	3b 45 d8	 cmp	 eax, DWORD PTR __Count$[ebp]
  002c0	75 0b		 jne	 SHORT $LN27@operator
  002c2	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR tv287[ebp+4]
  002c8	3b 4d dc	 cmp	 ecx, DWORD PTR __Count$[ebp+4]
  002cb	74 09		 je	 SHORT $LN13@operator
$LN27@operator:

; 805  : 			_State |= ios_base::badbit;

  002cd	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  002d0	83 c8 04	 or	 eax, 4
  002d3	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 806  : 
; 807  : 		if (_State == ios_base::goodbit)

  002d6	83 7d e8 00	 cmp	 DWORD PTR __State$[ebp], 0
  002da	0f 85 d5 00 00
	00		 jne	 $LN14@operator

; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  002e0	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  002e2	8b 45 c8	 mov	 eax, DWORD PTR __Pad$[ebp]
  002e5	83 e8 01	 sub	 eax, 1
  002e8	8b 4d cc	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  002eb	83 d9 00	 sbb	 ecx, 0
  002ee	89 45 c8	 mov	 DWORD PTR __Pad$[ebp], eax
  002f1	89 4d cc	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
  002f4	83 7d cc 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  002f8	0f 8c b7 00 00
	00		 jl	 $LN14@operator
  002fe	7f 0a		 jg	 SHORT $LN28@operator
  00300	83 7d c8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00304	0f 86 ab 00 00
	00		 jbe	 $LN14@operator
$LN28@operator:

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0030a	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0030d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030f	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00312	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00315	8b f4		 mov	 esi, esp
  00317	8b ca		 mov	 ecx, edx
  00319	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0031f	3b f4		 cmp	 esi, esp
  00321	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00326	88 85 b7 fe ff
	ff		 mov	 BYTE PTR tv288[ebp], al
  0032c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0032f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00331	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00334	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00337	8b f4		 mov	 esi, esp
  00339	8b ca		 mov	 ecx, edx
  0033b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00341	3b f4		 cmp	 esi, esp
  00343	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00348	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv289[ebp], eax
  0034e	8b f4		 mov	 esi, esp
  00350	0f b6 85 b7 fe
	ff ff		 movzx	 eax, BYTE PTR tv288[ebp]
  00357	50		 push	 eax
  00358	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR tv289[ebp]
  0035e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00364	3b f4		 cmp	 esi, esp
  00366	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0036b	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv290[ebp], eax
  00371	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv290[ebp]
  00377	89 8d d4 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  0037d	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  00382	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00388	8d 95 d4 fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  0038e	52		 push	 edx
  0038f	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00395	50		 push	 eax
  00396	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  0039b	83 c4 08	 add	 esp, 8
  0039e	0f b6 c8	 movzx	 ecx, al
  003a1	85 c9		 test	 ecx, ecx
  003a3	74 0b		 je	 SHORT $LN15@operator

; 810  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 811  : 					{	// insertion failed, quit
; 812  : 					_State |= ios_base::badbit;

  003a5	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  003a8	83 c8 04	 or	 eax, 4
  003ab	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax

; 813  : 					break;

  003ae	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 814  : 					}

  003b0	e9 2d ff ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 815  : 		_Ostr.width(0);

  003b5	8b f4		 mov	 esi, esp
  003b7	6a 00		 push	 0
  003b9	6a 00		 push	 0
  003bb	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003be	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c0	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  003c3	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  003c6	8b ca		 mov	 ecx, edx
  003c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  003ce	3b f4		 cmp	 esi, esp
  003d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d5	eb 26		 jmp	 SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 816  : 		_CATCH_IO_(_Ostr)

  003d7	8b f4		 mov	 esi, esp
  003d9	6a 01		 push	 1
  003db	6a 04		 push	 4
  003dd	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e2	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  003e5	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  003e8	8b ca		 mov	 ecx, edx
  003ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003f0	3b f4		 cmp	 esi, esp
  003f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003f7	b8 00 00 00 00	 mov	 eax, $LN23@operator
  003fc	c3		 ret	 0
$LN19@operator:
  003fd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00404	eb 07		 jmp	 SHORT $LN9@operator
$LN23@operator:
  00406	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 817  : 		}
; 818  : 
; 819  : 	_Ostr.setstate(_State);

  0040d	8b f4		 mov	 esi, esp
  0040f	6a 00		 push	 0
  00411	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  00414	50		 push	 eax
  00415	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00418	8b 11		 mov	 edx, DWORD PTR [ecx]
  0041a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0041d	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00420	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00426	3b f4		 cmp	 esi, esp
  00428	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 820  : 	return (_Ostr);

  0042d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00430	89 85 bc fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00436	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0043d	8d 4d b8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00440	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00445	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 821  : 	}

  0044b	52		 push	 edx
  0044c	8b cd		 mov	 ecx, ebp
  0044e	50		 push	 eax
  0044f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@operator
  00455	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0045a	58		 pop	 eax
  0045b	5a		 pop	 edx
  0045c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0045f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00466	59		 pop	 ecx
  00467	5f		 pop	 edi
  00468	5e		 pop	 esi
  00469	5b		 pop	 ebx
  0046a	81 c4 60 01 00
	00		 add	 esp, 352		; 00000160H
  00470	3b ec		 cmp	 ebp, esp
  00472	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00477	8b e5		 mov	 esp, ebp
  00479	5d		 pop	 ebp
  0047a	c3		 ret	 0
  0047b	90		 npad	 1
$LN32@operator:
  0047c	01 00 00 00	 DD	 1
  00480	00 00 00 00	 DD	 $LN31@operator
$LN31@operator:
  00484	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00488	08 00 00 00	 DD	 8
  0048c	00 00 00 00	 DD	 $LN29@operator
$LN29@operator:
  00490	5f		 DB	 95			; 0000005fH
  00491	4f		 DB	 79			; 0000004fH
  00492	6b		 DB	 107			; 0000006bH
  00493	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00000	8d 4d b8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 9c fe ff
	ff		 mov	 ecx, DWORD PTR [edx-356]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
tv128 = -352						; size = 8
tv279 = -348						; size = 4
tv274 = -348						; size = 4
tv313 = -344						; size = 8
tv278 = -344						; size = 4
tv276 = -344						; size = 4
tv273 = -344						; size = 4
tv275 = -340						; size = 4
tv65 = -340						; size = 4
tv277 = -337						; size = 1
tv272 = -337						; size = 1
$T2 = -332						; size = 4
$T3 = -320						; size = 4
$T4 = -308						; size = 4
$T5 = -296						; size = 4
$T6 = -284						; size = 4
$T7 = -272						; size = 4
$T8 = -260						; size = 4
__Pad$9 = -56						; size = 8
__Ok$ = -40						; size = 8
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 826  : 	{	// insert a char into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00021	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 827  : 	typedef char _Elem;
; 828  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 829  : 	ios_base::iostate _State = ios_base::goodbit;

  00041	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 830  : 	const typename _Myos::sentry _Ok(_Ostr);

  00048	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0004f	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 831  : 
; 832  : 	if (_Ok)

  0005b	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0005e	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00063	0f b6 c0	 movzx	 eax, al
  00066	85 c0		 test	 eax, eax
  00068	0f 84 3a 03 00
	00		 je	 $LN8@operator

; 833  : 		{	// state okay, insert
; 834  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  0006e	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00076	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00079	8b f4		 mov	 esi, esp
  0007b	8b ca		 mov	 ecx, edx
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  00083	3b f4		 cmp	 esi, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv313[ebp], eax
  00090	89 95 ac fe ff
	ff		 mov	 DWORD PTR tv313[ebp+4], edx
  00096	83 bd ac fe ff
	ff 00		 cmp	 DWORD PTR tv313[ebp+4], 0
  0009d	7f 18		 jg	 SHORT $LN15@operator
  0009f	7c 09		 jl	 SHORT $LN22@operator
  000a1	83 bd a8 fe ff
	ff 01		 cmp	 DWORD PTR tv313[ebp], 1
  000a8	77 0d		 ja	 SHORT $LN15@operator
$LN22@operator:
  000aa	0f 57 c0	 xorps	 xmm0, xmm0
  000ad	66 0f 13 85 a0
	fe ff ff	 movlpd	 QWORD PTR tv128[ebp], xmm0
  000b5	eb 2e		 jmp	 SHORT $LN16@operator
$LN15@operator:
  000b7	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bc	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000bf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000c2	8b f4		 mov	 esi, esp
  000c4	8b ca		 mov	 ecx, edx
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000cc	3b f4		 cmp	 esi, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	83 e8 01	 sub	 eax, 1
  000d6	83 da 00	 sbb	 edx, 0
  000d9	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv128[ebp], eax
  000df	89 95 a4 fe ff
	ff		 mov	 DWORD PTR tv128[ebp+4], edx
$LN16@operator:
  000e5	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR tv128[ebp]
  000eb	89 45 c8	 mov	 DWORD PTR __Pad$9[ebp], eax
  000ee	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR tv128[ebp+4]
  000f4	89 4d cc	 mov	 DWORD PTR __Pad$9[ebp+4], ecx

; 835  : 
; 836  : 		_TRY_IO_BEGIN

  000f7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 837  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000fb	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00100	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00103	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00106	8b f4		 mov	 esi, esp
  00108	8b ca		 mov	 ecx, edx
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  00110	3b f4		 cmp	 esi, esp
  00112	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00117	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0011d	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  00123	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00128	83 f8 40	 cmp	 eax, 64			; 00000040H
  0012b	0f 84 dd 00 00
	00		 je	 $LN10@operator

; 838  : 			for (; _State == ios_base::goodbit && 0 < _Pad;

  00131	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:

; 839  : 				--_Pad)	// pad on left

  00133	8b 45 c8	 mov	 eax, DWORD PTR __Pad$9[ebp]
  00136	83 e8 01	 sub	 eax, 1
  00139	8b 4d cc	 mov	 ecx, DWORD PTR __Pad$9[ebp+4]
  0013c	83 d9 00	 sbb	 ecx, 0
  0013f	89 45 c8	 mov	 DWORD PTR __Pad$9[ebp], eax
  00142	89 4d cc	 mov	 DWORD PTR __Pad$9[ebp+4], ecx
$LN4@operator:

; 838  : 			for (; _State == ios_base::goodbit && 0 < _Pad;

  00145	83 7d e8 00	 cmp	 DWORD PTR __State$[ebp], 0
  00149	0f 85 bf 00 00
	00		 jne	 $LN10@operator
  0014f	83 7d cc 00	 cmp	 DWORD PTR __Pad$9[ebp+4], 0
  00153	0f 8c b5 00 00
	00		 jl	 $LN10@operator
  00159	7f 0a		 jg	 SHORT $LN23@operator
  0015b	83 7d c8 00	 cmp	 DWORD PTR __Pad$9[ebp], 0
  0015f	0f 86 a9 00 00
	00		 jbe	 $LN10@operator
$LN23@operator:

; 840  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00165	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00168	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0016d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00170	8b f4		 mov	 esi, esp
  00172	8b ca		 mov	 ecx, edx
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0017a	3b f4		 cmp	 esi, esp
  0017c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00181	88 85 af fe ff
	ff		 mov	 BYTE PTR tv272[ebp], al
  00187	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0018a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0018f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00192	8b f4		 mov	 esi, esp
  00194	8b ca		 mov	 ecx, edx
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0019c	3b f4		 cmp	 esi, esp
  0019e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a3	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv273[ebp], eax
  001a9	8b f4		 mov	 esi, esp
  001ab	0f b6 85 af fe
	ff ff		 movzx	 eax, BYTE PTR tv272[ebp]
  001b2	50		 push	 eax
  001b3	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR tv273[ebp]
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001bf	3b f4		 cmp	 esi, esp
  001c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c6	89 85 a4 fe ff
	ff		 mov	 DWORD PTR tv274[ebp], eax
  001cc	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR tv274[ebp]
  001d2	89 8d fc fe ff
	ff		 mov	 DWORD PTR $T8[ebp], ecx
  001d8	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  001dd	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  001e3	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  001e9	52		 push	 edx
  001ea	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  001f6	83 c4 08	 add	 esp, 8
  001f9	0f b6 c8	 movzx	 ecx, al
  001fc	85 c9		 test	 ecx, ecx
  001fe	74 09		 je	 SHORT $LN11@operator

; 841  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 842  : 					_State |= ios_base::badbit;

  00200	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  00203	83 c8 04	 or	 eax, 4
  00206	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax
$LN11@operator:

; 843  : 
; 844  : 		if (_State == ios_base::goodbit

  00209	e9 25 ff ff ff	 jmp	 $LN2@operator
$LN10@operator:

; 845  : 			&& _Traits::eq_int_type(_Traits::eof(),

  0020e	83 7d e8 00	 cmp	 DWORD PTR __State$[ebp], 0
  00212	75 7f		 jne	 SHORT $LN12@operator
  00214	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00217	8b 08		 mov	 ecx, DWORD PTR [eax]
  00219	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0021c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0021f	8b f4		 mov	 esi, esp
  00221	8b ca		 mov	 ecx, edx
  00223	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00229	3b f4		 cmp	 esi, esp
  0022b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00230	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv275[ebp], eax
  00236	8b f4		 mov	 esi, esp
  00238	0f b6 45 0c	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0023c	50		 push	 eax
  0023d	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv275[ebp]
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00249	3b f4		 cmp	 esi, esp
  0024b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00250	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv276[ebp], eax
  00256	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR tv276[ebp]
  0025c	89 8d e4 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
  00262	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  00267	89 85 d8 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  0026d	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  00273	52		 push	 edx
  00274	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0027a	50		 push	 eax
  0027b	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  00280	83 c4 08	 add	 esp, 8
  00283	0f b6 c8	 movzx	 ecx, al
  00286	85 c9		 test	 ecx, ecx
  00288	74 09		 je	 SHORT $LN12@operator

; 846  : 				_Ostr.rdbuf()->sputc(_Ch)))
; 847  : 			_State |= ios_base::badbit;

  0028a	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  0028d	83 c8 04	 or	 eax, 4
  00290	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax
$LN12@operator:

; 848  : 
; 849  : 		for (; _State == ios_base::goodbit && 0 < _Pad;

  00293	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:

; 850  : 			--_Pad)	// pad on right

  00295	8b 45 c8	 mov	 eax, DWORD PTR __Pad$9[ebp]
  00298	83 e8 01	 sub	 eax, 1
  0029b	8b 4d cc	 mov	 ecx, DWORD PTR __Pad$9[ebp+4]
  0029e	83 d9 00	 sbb	 ecx, 0
  002a1	89 45 c8	 mov	 DWORD PTR __Pad$9[ebp], eax
  002a4	89 4d cc	 mov	 DWORD PTR __Pad$9[ebp+4], ecx
$LN7@operator:

; 848  : 
; 849  : 		for (; _State == ios_base::goodbit && 0 < _Pad;

  002a7	83 7d e8 00	 cmp	 DWORD PTR __State$[ebp], 0
  002ab	0f 85 bf 00 00
	00		 jne	 $LN6@operator
  002b1	83 7d cc 00	 cmp	 DWORD PTR __Pad$9[ebp+4], 0
  002b5	0f 8c b5 00 00
	00		 jl	 $LN6@operator
  002bb	7f 0a		 jg	 SHORT $LN24@operator
  002bd	83 7d c8 00	 cmp	 DWORD PTR __Pad$9[ebp], 0
  002c1	0f 86 a9 00 00
	00		 jbe	 $LN6@operator
$LN24@operator:

; 851  : 			if (_Traits::eq_int_type(_Traits::eof(),

  002c7	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  002cc	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d2	8b f4		 mov	 esi, esp
  002d4	8b ca		 mov	 ecx, edx
  002d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  002dc	3b f4		 cmp	 esi, esp
  002de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e3	88 85 af fe ff
	ff		 mov	 BYTE PTR tv277[ebp], al
  002e9	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ee	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002f1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002f4	8b f4		 mov	 esi, esp
  002f6	8b ca		 mov	 ecx, edx
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002fe	3b f4		 cmp	 esi, esp
  00300	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00305	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv278[ebp], eax
  0030b	8b f4		 mov	 esi, esp
  0030d	0f b6 85 af fe
	ff ff		 movzx	 eax, BYTE PTR tv277[ebp]
  00314	50		 push	 eax
  00315	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR tv278[ebp]
  0031b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00321	3b f4		 cmp	 esi, esp
  00323	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00328	89 85 a4 fe ff
	ff		 mov	 DWORD PTR tv279[ebp], eax
  0032e	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR tv279[ebp]
  00334	89 8d cc fe ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  0033a	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  0033f	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00345	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  0034b	52		 push	 edx
  0034c	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00352	50		 push	 eax
  00353	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  00358	83 c4 08	 add	 esp, 8
  0035b	0f b6 c8	 movzx	 ecx, al
  0035e	85 c9		 test	 ecx, ecx
  00360	74 09		 je	 SHORT $LN13@operator

; 852  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 853  : 				_State |= ios_base::badbit;

  00362	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  00365	83 c8 04	 or	 eax, 4
  00368	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 854  : 		_CATCH_IO_(_Ostr)

  0036b	e9 25 ff ff ff	 jmp	 $LN5@operator
$LN6@operator:
  00370	eb 26		 jmp	 SHORT $LN17@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0:
  00372	8b f4		 mov	 esi, esp
  00374	6a 01		 push	 1
  00376	6a 04		 push	 4
  00378	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0037b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0037d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00380	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00383	8b ca		 mov	 ecx, edx
  00385	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0038b	3b f4		 cmp	 esi, esp
  0038d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00392	b8 00 00 00 00	 mov	 eax, $LN21@operator
  00397	c3		 ret	 0
$LN17@operator:
  00398	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0039f	eb 07		 jmp	 SHORT $LN8@operator
$LN21@operator:
  003a1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN8@operator:

; 855  : 		}
; 856  : 
; 857  : 	_Ostr.width(0);

  003a8	8b f4		 mov	 esi, esp
  003aa	6a 00		 push	 0
  003ac	6a 00		 push	 0
  003ae	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b3	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  003b6	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  003b9	8b ca		 mov	 ecx, edx
  003bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  003c1	3b f4		 cmp	 esi, esp
  003c3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 858  : 	_Ostr.setstate(_State);

  003c8	8b f4		 mov	 esi, esp
  003ca	6a 00		 push	 0
  003cc	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  003cf	50		 push	 eax
  003d0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003d3	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003d8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  003db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003e1	3b f4		 cmp	 esi, esp
  003e3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 859  : 	return (_Ostr);

  003e8	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003eb	89 85 b4 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  003f1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  003f8	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  003fb	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00400	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 860  : 	}

  00406	52		 push	 edx
  00407	8b cd		 mov	 ecx, ebp
  00409	50		 push	 eax
  0040a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@operator
  00410	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00415	58		 pop	 eax
  00416	5a		 pop	 edx
  00417	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0041a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00421	59		 pop	 ecx
  00422	5f		 pop	 edi
  00423	5e		 pop	 esi
  00424	5b		 pop	 ebx
  00425	81 c4 60 01 00
	00		 add	 esp, 352		; 00000160H
  0042b	3b ec		 cmp	 ebp, esp
  0042d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00432	8b e5		 mov	 esp, ebp
  00434	5d		 pop	 ebp
  00435	c3		 ret	 0
  00436	66 90		 npad	 2
$LN28@operator:
  00438	01 00 00 00	 DD	 1
  0043c	00 00 00 00	 DD	 $LN27@operator
$LN27@operator:
  00440	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00444	08 00 00 00	 DD	 8
  00448	00 00 00 00	 DD	 $LN25@operator
$LN25@operator:
  0044c	5f		 DB	 95			; 0000005fH
  0044d	4f		 DB	 79			; 0000004fH
  0044e	6b		 DB	 107			; 0000006bH
  0044f	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 9c fe ff
	ff		 mov	 ecx, DWORD PTR [edx-356]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
tv133 = -252						; size = 4
tv130 = -248						; size = 4
tv136 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
$T4 = -209						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >, COMDAT

; 2790 : 	{	// order [_First, _Last), using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00020	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 2791 : 	_STD sort(_First, _Last, less<>());

  00044	0f b6 85 2f ff
	ff ff		 movzx	 eax, BYTE PTR $T4[ebp]
  0004b	50		 push	 eax
  0004c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0004f	8b cc		 mov	 ecx, esp
  00051	89 a5 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  00057	8d 55 14	 lea	 edx, DWORD PTR __Last$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  00060	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv136[ebp], eax
  00066	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv136[ebp]
  0006c	89 85 08 ff ff
	ff		 mov	 DWORD PTR tv130[ebp], eax
  00072	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00076	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00079	8b cc		 mov	 ecx, esp
  0007b	89 a5 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], esp
  00081	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  0008a	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv133[ebp], eax
  00090	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00094	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0U?$less@X@0@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >,std::less<void> >
  00099	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2792 : 	}

  0009c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000a0	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  000a3	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000af	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  000b2	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  000b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c1	59		 pop	 ecx
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  000cb	3b ec		 cmp	 ebp, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z$2:
  00010	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 8a 00 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-256]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z
_TEXT	SEGMENT
tv130 = -284						; size = 4
tv184 = -280						; size = 4
tv183 = -276						; size = 4
tv176 = -276						; size = 4
tv180 = -272						; size = 4
tv173 = -272						; size = 4
tv179 = -268						; size = 4
tv128 = -268						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
$T6 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Val$ = 36						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >,char>, COMDAT

; 3283 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd e4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-284]
  00020	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  00047	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 3284 : 	_DEBUG_RANGE(_First, _Last);

  0004e	68 d4 0c 00 00	 push	 3284			; 00000cd4H
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00058	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0005b	8b cc		 mov	 ecx, esp
  0005d	89 a5 2c ff ff
	ff		 mov	 DWORD PTR $T6[ebp], esp
  00063	8d 45 18	 lea	 eax, DWORD PTR __Last$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  0006c	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv128[ebp], eax
  00072	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv128[ebp]
  00078	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv173[ebp], ecx
  0007e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00082	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00085	8b cc		 mov	 ecx, esp
  00087	89 a5 20 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], esp
  0008d	8d 55 0c	 lea	 edx, DWORD PTR __First$[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  00096	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv176[ebp], eax
  0009c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000a0	e8 00 00 00 00	 call	 ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
  000a5	83 c4 20	 add	 esp, 32			; 00000020H

; 3285 : 	return (_Rechecked(_First,

  000a8	8b 45 24	 mov	 eax, DWORD PTR __Val$[ebp]
  000ab	50		 push	 eax
  000ac	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000af	8b cc		 mov	 ecx, esp
  000b1	89 a5 14 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], esp
  000b7	8d 55 18	 lea	 edx, DWORD PTR __Last$[ebp]
  000ba	52		 push	 edx
  000bb	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  000c0	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv179[ebp], eax
  000c6	e8 00 00 00 00	 call	 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ce	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv180[ebp], eax
  000d4	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv180[ebp]
  000da	50		 push	 eax
  000db	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000de	8b cc		 mov	 ecx, esp
  000e0	89 a5 08 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  000e6	8d 55 0c	 lea	 edx, DWORD PTR __First$[ebp]
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  000ef	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv183[ebp], eax
  000f5	e8 00 00 00 00	 call	 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAPAUOption@CCustomMenu@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fd	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv184[ebp], eax
  00103	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv184[ebp]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 ??$_Find_unchecked@PAUOption@CCustomMenu@@D@std@@YAPAUOption@CCustomMenu@@PAU12@0ABD@Z ; std::_Find_unchecked<CCustomMenu::Option *,char>
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00112	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv130[ebp], eax
  00118	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR tv130[ebp]
  0011e	51		 push	 ecx
  0011f	8d 55 0c	 lea	 edx, DWORD PTR __First$[ebp]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@AAV10@PAUOption@CCustomMenu@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
  00128	83 c4 08	 add	 esp, 8
  0012b	50		 push	 eax
  0012c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0012f	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  00134	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  0013a	83 c8 01	 or	 eax, 1
  0013d	89 85 fc fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00143	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00147	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0014a	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  0014f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00156	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  00159	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  0015e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3286 : 		_Find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
; 3287 : 	}

  00161	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00164	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016b	59		 pop	 ecx
  0016c	5f		 pop	 edi
  0016d	5e		 pop	 esi
  0016e	5b		 pop	 ebx
  0016f	81 c4 1c 01 00
	00		 add	 esp, 284		; 0000011cH
  00175	3b ec		 cmp	 ebp, esp
  00177	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z$0:
  00000	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z$1:
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z$2:
  00010	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 8a e0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-288]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >,char>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPAUOption@CCustomMenu@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPAUOption@CCustomMenu@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Unchecked, COMDAT
; _this$ = ecx

; 325  : 		{	// make an unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 326  : 		return (this->_Ptr);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 327  : 		}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPAUOption@CCustomMenu@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV12@PAUOption@CCustomMenu@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV12@PAUOption@CCustomMenu@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Rechecked, COMDAT
; _this$ = ecx

; 319  : 		{	// reset from unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 320  : 		this->_Ptr = _Right;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00029	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 321  : 		return (*this);

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 322  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV12@PAUOption@CCustomMenu@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 312  : 		: _Mybase(_Parg, _Pvector)

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >

; 314  : 		}

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00035	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00038	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00035	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00038	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Compat, COMDAT
; _this$ = ecx

; 245  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 246  : 		if (this->_Getcont() != _Right._Getcont())

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00035	3b f0		 cmp	 esi, eax
  00037	0f 84 86 00 00
	00		 je	 $LN1@Compat

; 247  : 			{
; 248  : 			_DEBUG_ERROR("vector iterators incompatible");

  0003d	8b f4		 mov	 esi, esp
  0003f	68 f8 00 00 00	 push	 248			; 000000f8H
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 249  : 			_SCL_SECURE_INVALID_ARGUMENT;

  0005e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
  00063	85 c0		 test	 eax, eax
  00065	74 04		 je	 SHORT $LN4@Compat
  00067	33 c9		 xor	 ecx, ecx
  00069	75 30		 jne	 SHORT $LN5@Compat
$LN4@Compat:
  0006b	8b f4		 mov	 esi, esp
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00077	6a 00		 push	 0
  00079	68 f9 00 00 00	 push	 249			; 000000f9H
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00083	6a 02		 push	 2
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0008b	83 c4 18	 add	 esp, 24			; 00000018H
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	83 f8 01	 cmp	 eax, 1
  00098	75 01		 jne	 SHORT $LN5@Compat
  0009a	cc		 int	 3
$LN5@Compat:
  0009b	8b f4		 mov	 esi, esp
  0009d	6a 00		 push	 0
  0009f	68 f9 00 00 00	 push	 249			; 000000f9H
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_1OM@HACCCHHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000b9	83 c4 14	 add	 esp, 20			; 00000014H
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Compat:

; 250  : 			}
; 251  : 		}

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000cc	3b ec		 cmp	 ebp, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator<, COMDAT
; _this$ = ecx

; 223  : 		{	// test if this < _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 224  : 		_Compat(_Right);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Compat

; 225  : 		return (_Ptr < _Right._Ptr);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00035	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00038	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003b	73 0c		 jae	 SHORT $LN3@operator
  0003d	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  00047	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00049	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00053	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]

; 226  : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 219  : 		return (!(*this == _Right));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator==
  0002f	0f b6 c8	 movzx	 ecx, al
  00032	85 c9		 test	 ecx, ecx
  00034	75 0c		 jne	 SHORT $LN3@operator
  00036	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  00040	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00042	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0004c	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]

; 220  : 		}

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Compat(_Right);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Compat

; 214  : 		return (_Ptr == _Right._Ptr);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00035	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00038	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003b	75 0c		 jne	 SHORT $LN3@operator
  0003d	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  00047	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00049	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00053	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]

; 215  : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002b	89 45 ec	 mov	 DWORD PTR __Mycont$[ebp], eax

; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)

  0002e	83 7d ec 00	 cmp	 DWORD PTR __Mycont$[ebp], 0
  00032	74 17		 je	 SHORT $LN3@operator
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0003b	74 0e		 je	 SHORT $LN3@operator
  0003d	8b 45 ec	 mov	 eax, DWORD PTR __Mycont$[ebp]
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00046	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00049	77 7d		 ja	 SHORT $LN2@operator
$LN3@operator:

; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");

  0004b	8b f4		 mov	 esi, esp
  0004d	6a 66		 push	 102			; 00000066H
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 103  : 			_SCL_SECURE_OUT_OF_RANGE;

  00069	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  0006e	85 c0		 test	 eax, eax
  00070	74 04		 je	 SHORT $LN5@operator
  00072	33 c9		 xor	 ecx, ecx
  00074	75 2d		 jne	 SHORT $LN6@operator
$LN5@operator:
  00076	8b f4		 mov	 esi, esp
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00082	6a 00		 push	 0
  00084	6a 67		 push	 103			; 00000067H
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008b	6a 02		 push	 2
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00093	83 c4 18	 add	 esp, 24			; 00000018H
  00096	3b f4		 cmp	 esi, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009d	83 f8 01	 cmp	 eax, 1
  000a0	75 01		 jne	 SHORT $LN6@operator
  000a2	cc		 int	 3
$LN6@operator:
  000a3	8b f4		 mov	 esi, esp
  000a5	6a 00		 push	 0
  000a7	6a 67		 push	 103			; 00000067H
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_1PE@FEBODMLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000be	83 c4 14	 add	 esp, 20			; 00000014H
  000c1	3b f4		 cmp	 esi, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ce	83 c1 20	 add	 ecx, 32			; 00000020H
  000d1	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 114  : 		return (*this);

  000d7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 115  : 		}

  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx
  000dd	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000e3	3b ec		 cmp	 ebp, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPBUOption@CCustomMenu@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPBUOption@CCustomMenu@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator->, COMDAT
; _this$ = ecx

; 90   : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 91   : 		return (pointer_traits<pointer>::pointer_to(**this));

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABUOption@CCustomMenu@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator*
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?pointer_to@?$pointer_traits@PBUOption@CCustomMenu@@@std@@SAPBUOption@CCustomMenu@@ABU34@@Z ; std::pointer_traits<CCustomMenu::Option const *>::pointer_to
  00031	83 c4 04	 add	 esp, 4

; 92   : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPBUOption@CCustomMenu@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABUOption@CCustomMenu@@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABUOption@CCustomMenu@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002b	89 45 ec	 mov	 DWORD PTR __Mycont$[ebp], eax

; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)

  0002e	83 7d ec 00	 cmp	 DWORD PTR __Mycont$[ebp], 0
  00032	74 25		 je	 SHORT $LN3@operator
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0003b	74 1c		 je	 SHORT $LN3@operator
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 4d ec	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  00043	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00046	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00049	72 0e		 jb	 SHORT $LN3@operator
  0004b	8b 45 ec	 mov	 eax, DWORD PTR __Mycont$[ebp]
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00054	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00057	77 7d		 ja	 SHORT $LN2@operator
$LN3@operator:

; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");

  00059	8b f4		 mov	 esi, esp
  0005b	6a 49		 push	 73			; 00000049H
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00070	3b f4		 cmp	 esi, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 74   : 			_SCL_SECURE_OUT_OF_RANGE;

  00077	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  0007c	85 c0		 test	 eax, eax
  0007e	74 04		 je	 SHORT $LN5@operator
  00080	33 c9		 xor	 ecx, ecx
  00082	75 2d		 jne	 SHORT $LN6@operator
$LN5@operator:
  00084	8b f4		 mov	 esi, esp
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00090	6a 00		 push	 0
  00092	6a 4a		 push	 74			; 0000004aH
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00099	6a 02		 push	 2
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  000a1	83 c4 18	 add	 esp, 24			; 00000018H
  000a4	3b f4		 cmp	 esi, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	83 f8 01	 cmp	 eax, 1
  000ae	75 01		 jne	 SHORT $LN6@operator
  000b0	cc		 int	 3
$LN6@operator:
  000b1	8b f4		 mov	 esi, esp
  000b3	6a 00		 push	 0
  000b5	6a 4a		 push	 74			; 0000004aH
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_1PC@BPDPMBHD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000cc	83 c4 14	 add	 esp, 20			; 00000014H
  000cf	3b f4		 cmp	 esi, esp
  000d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 87   : 		}

  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx
  000df	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000e5	3b ec		 cmp	 ebp, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABUOption@CCustomMenu@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 46   : 		: _Ptr(_Parg)

  00051	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00057	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

  0005a	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

  00066	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UOption@CCustomMenu@@HPBU34@ABU34@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,CCustomMenu::Option,int,CCustomMenu::Option const *,CCustomMenu::Option const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File s:\chris\onedrive - uat\c++ programming ii\pete_final\pete_final\custommenu.cpp
;	COMDAT ?contains@CCustomMenu@@QAE_ND@Z
_TEXT	SEGMENT
tv139 = -317						; size = 1
tv161 = -316						; size = 4
tv71 = -312						; size = 4
tv159 = -308						; size = 4
tv156 = -304						; size = 4
tv152 = -300						; size = 4
tv162 = -296						; size = 4
$T2 = -288						; size = 12
$T3 = -268						; size = 12
$T4 = -248						; size = 4
$T5 = -236						; size = 4
$T6 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_letter$ = 8						; size = 1
?contains@CCustomMenu@@QAE_ND@Z PROC			; CCustomMenu::contains, COMDAT
; _this$ = ecx

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?contains@CCustomMenu@@QAE_ND@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd c0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-320]
  00021	b9 4d 00 00 00	 mov	 ecx, 77			; 0000004dH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 	// Make sure letter is uppercase
; 60   : 	letter = toupper(letter);

  00042	0f be 45 08	 movsx	 eax, BYTE PTR _letter$[ebp]
  00046	8b f4		 mov	 esi, esp
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  0004f	83 c4 04	 add	 esp, 4
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	88 45 08	 mov	 BYTE PTR _letter$[ebp], al

; 61   : 
; 62   : 	// Check if it can find the inputted value in the menu option list
; 63   : 	return find(optionList.begin(), optionList.end(), letter) != optionList.end();

  0005c	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00062	50		 push	 eax
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::end
  0006b	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv162[ebp], eax
  00071	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv162[ebp]
  00077	89 8d d4 fe ff
	ff		 mov	 DWORD PTR tv152[ebp], ecx
  0007d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00084	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR tv152[ebp]
  0008a	52		 push	 edx
  0008b	8d 45 08	 lea	 eax, DWORD PTR _letter$[ebp]
  0008e	50		 push	 eax
  0008f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00092	8b cc		 mov	 ecx, esp
  00094	89 a5 14 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], esp
  0009a	51		 push	 ecx
  0009b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::end
  000a3	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv156[ebp], eax
  000a9	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000ac	8b d4		 mov	 edx, esp
  000ae	89 a5 08 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], esp
  000b4	52		 push	 edx
  000b5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::begin
  000bd	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv159[ebp], eax
  000c3	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >,char>
  000cf	83 c4 20	 add	 esp, 32			; 00000020H
  000d2	89 85 c8 fe ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  000d8	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  000de	89 8d c4 fe ff
	ff		 mov	 DWORD PTR tv161[ebp], ecx
  000e4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000e8	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv161[ebp]
  000ee	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator!=
  000f3	88 85 c3 fe ff
	ff		 mov	 BYTE PTR tv139[ebp], al
  000f9	8a 95 c3 fe ff
	ff		 mov	 dl, BYTE PTR tv139[ebp]
  000ff	88 95 23 ff ff
	ff		 mov	 BYTE PTR $T6[ebp], dl
  00105	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00109	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0010f	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  00114	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0011b	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00121	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  00126	8a 85 23 ff ff
	ff		 mov	 al, BYTE PTR $T6[ebp]

; 64   : }

  0012c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00136	59		 pop	 ecx
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx
  0013a	81 c4 40 01 00
	00		 add	 esp, 320		; 00000140H
  00140	3b ec		 cmp	 ebp, esp
  00142	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?contains@CCustomMenu@@QAE_ND@Z$0:
  00000	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?contains@CCustomMenu@@QAE_ND@Z$3:
  0000b	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?contains@CCustomMenu@@QAE_ND@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a bc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-324]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?contains@CCustomMenu@@QAE_ND@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?contains@CCustomMenu@@QAE_ND@Z ENDP			; CCustomMenu::contains
; Function compile flags: /Odtp /RTCsu /ZI
; File s:\chris\onedrive - uat\c++ programming ii\pete_final\pete_final\custommenu.cpp
;	COMDAT ?displayMenuOptions@CCustomMenu@@QAEXXZ
_TEXT	SEGMENT
tv166 = -328						; size = 4
tv164 = -328						; size = 4
tv161 = -328						; size = 4
tv168 = -324						; size = 4
tv167 = -324						; size = 4
tv65 = -324						; size = 4
$T2 = -316						; size = 12
$T3 = -293						; size = 1
$T4 = -284						; size = 12
$T5 = -261						; size = 1
$T6 = -252						; size = 12
_it$7 = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?displayMenuOptions@CCustomMenu@@QAEXXZ PROC		; CCustomMenu::displayMenuOptions, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?displayMenuOptions@CCustomMenu@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd b8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-328]
  00021	b9 4f 00 00 00	 mov	 ecx, 79			; 0000004fH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 	// Loop through the added options
; 43   : 	for (vector<Option>::const_iterator it = optionList.begin(); it != optionList.end(); ++it)

  00042	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00048	50		 push	 eax
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::begin
  00051	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv167[ebp], eax
  00057	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv167[ebp]
  0005d	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv161[ebp], ecx
  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006a	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv161[ebp]
  00070	52		 push	 edx
  00071	8d 4d d8	 lea	 ecx, DWORD PTR _it$7[ebp]
  00074	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@$$QAV01@@Z
  00079	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0007d	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00083	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  00088	eb 08		 jmp	 SHORT $LN4@displayMen
$LN2@displayMen:
  0008a	8d 4d d8	 lea	 ecx, DWORD PTR _it$7[ebp]
  0008d	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator++
$LN4@displayMen:
  00092	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00098	50		 push	 eax
  00099	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::end
  000a1	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  000a7	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  000ad	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv164[ebp], ecx
  000b3	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000b7	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv164[ebp]
  000bd	52		 push	 edx
  000be	8d 4d d8	 lea	 ecx, DWORD PTR _it$7[ebp]
  000c1	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator!=
  000c6	88 85 fb fe ff
	ff		 mov	 BYTE PTR $T5[ebp], al
  000cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000d0	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000d6	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  000db	0f b6 85 fb fe
	ff ff		 movzx	 eax, BYTE PTR $T5[ebp]
  000e2	85 c0		 test	 eax, eax
  000e4	0f 84 c1 00 00
	00		 je	 $LN3@displayMen

; 44   : 	{
; 45   : 		// Display the option
; 46   : 		cout << "\t" << it->letter << ")  " << it->text;

  000ea	8d 4d d8	 lea	 ecx, DWORD PTR _it$7[ebp]
  000ed	e8 00 00 00 00	 call	 ??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPBUOption@CCustomMenu@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator->
  000f2	83 c0 04	 add	 eax, 4
  000f5	50		 push	 eax
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_03KOEIKCBF@?$CJ?5?5?$AA@
  000fb	8d 4d d8	 lea	 ecx, DWORD PTR _it$7[ebp]
  000fe	e8 00 00 00 00	 call	 ??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPBUOption@CCustomMenu@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator->
  00103	8a 00		 mov	 al, BYTE PTR [eax]
  00105	0f b6 c8	 movzx	 ecx, al
  00108	51		 push	 ecx
  00109	68 00 00 00 00	 push	 OFFSET ??_C@_01GPOEFGEJ@?7?$AA@
  0010e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0011a	83 c4 08	 add	 esp, 8
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
  00123	83 c4 08	 add	 esp, 8
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0012c	83 c4 08	 add	 esp, 8
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  00135	83 c4 08	 add	 esp, 8

; 47   : 
; 48   : 		// If the option being displayed isn't the last one, add a newline
; 49   : 		if (it != optionList.end())

  00138	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0013e	50		 push	 eax
  0013f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00142	e8 00 00 00 00	 call	 ?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::end
  00147	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv168[ebp], eax
  0014d	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv168[ebp]
  00153	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv166[ebp], ecx
  00159	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0015d	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv166[ebp]
  00163	52		 push	 edx
  00164	8d 4d d8	 lea	 ecx, DWORD PTR _it$7[ebp]
  00167	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator!=
  0016c	88 85 db fe ff
	ff		 mov	 BYTE PTR $T3[ebp], al
  00172	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00176	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0017c	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  00181	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR $T3[ebp]
  00188	85 c0		 test	 eax, eax
  0018a	74 1a		 je	 SHORT $LN5@displayMen

; 50   : 		{
; 51   : 			cout << endl;

  0018c	8b f4		 mov	 esi, esp
  0018e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00193	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0019f	3b f4		 cmp	 esi, esp
  001a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@displayMen:

; 52   : 		}

  001a6	e9 df fe ff ff	 jmp	 $LN2@displayMen
$LN3@displayMen:

; 53   : 	}

  001ab	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001b2	8d 4d d8	 lea	 ecx, DWORD PTR _it$7[ebp]
  001b5	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ

; 54   : }

  001ba	52		 push	 edx
  001bb	8b cd		 mov	 ecx, ebp
  001bd	50		 push	 eax
  001be	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@displayMen
  001c4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001c9	58		 pop	 eax
  001ca	5a		 pop	 edx
  001cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d5	59		 pop	 ecx
  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	5b		 pop	 ebx
  001d9	81 c4 48 01 00
	00		 add	 esp, 328		; 00000148H
  001df	3b ec		 cmp	 ebp, esp
  001e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c3		 ret	 0
  001ea	66 90		 npad	 2
$LN14@displayMen:
  001ec	01 00 00 00	 DD	 1
  001f0	00 00 00 00	 DD	 $LN13@displayMen
$LN13@displayMen:
  001f4	d8 ff ff ff	 DD	 -40			; ffffffd8H
  001f8	0c 00 00 00	 DD	 12			; 0000000cH
  001fc	00 00 00 00	 DD	 $LN11@displayMen
$LN11@displayMen:
  00200	69		 DB	 105			; 00000069H
  00201	74		 DB	 116			; 00000074H
  00202	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?displayMenuOptions@CCustomMenu@@QAEXXZ$0:
  00000	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?displayMenuOptions@CCustomMenu@@QAEXXZ$1:
  0000b	8d 4d d8	 lea	 ecx, DWORD PTR _it$7[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?displayMenuOptions@CCustomMenu@@QAEXXZ$2:
  00013	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?displayMenuOptions@CCustomMenu@@QAEXXZ$3:
  0001e	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?displayMenuOptions@CCustomMenu@@QAEXXZ:
  00029	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00030	8b 8a b4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-332]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?displayMenuOptions@CCustomMenu@@QAEXXZ
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?displayMenuOptions@CCustomMenu@@QAEXXZ ENDP		; CCustomMenu::displayMenuOptions
; Function compile flags: /Odtp /RTCsu /ZI
; File s:\chris\onedrive - uat\c++ programming ii\pete_final\pete_final\custommenu.cpp
;	COMDAT ?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tv140 = -409						; size = 1
tv202 = -408						; size = 4
tv72 = -404						; size = 4
tv200 = -400						; size = 4
tv197 = -396						; size = 4
tv209 = -392						; size = 4
tv193 = -392						; size = 4
tv212 = -388						; size = 4
tv206 = -388						; size = 4
$T2 = -377						; size = 1
$T3 = -368						; size = 4
$T4 = -356						; size = 4
$T5 = -341						; size = 1
$T6 = -332						; size = 12
$T7 = -312						; size = 12
$T8 = -292						; size = 4
$T9 = -280						; size = 4
$T10 = -265						; size = 1
_newOption$ = -64					; size = 32
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_letter$ = 8						; size = 1
_text$ = 12						; size = 28
?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CCustomMenu::addMenuOption, COMDAT
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 90 01 00
	00		 sub	 esp, 400		; 00000190H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 64 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-412]
  00021	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 17   : 	// Make sure letter is uppercase
; 18   : 	letter = toupper(letter);

  0004c	0f be 45 08	 movsx	 eax, BYTE PTR _letter$[ebp]
  00050	8b f4		 mov	 esi, esp
  00052	50		 push	 eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  00059	83 c4 04	 add	 esp, 4
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	88 45 08	 mov	 BYTE PTR _letter$[ebp], al

; 19   : 
; 20   : 	// Check if an option with that letter already exists
; 21   : 	if (find(optionList.begin(), optionList.end(), letter) != optionList.end())

  00066	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::end
  00075	89 85 7c fe ff
	ff		 mov	 DWORD PTR tv212[ebp], eax
  0007b	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR tv212[ebp]
  00081	89 8d 78 fe ff
	ff		 mov	 DWORD PTR tv193[ebp], ecx
  00087	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0008b	8b 95 78 fe ff
	ff		 mov	 edx, DWORD PTR tv193[ebp]
  00091	52		 push	 edx
  00092	8d 45 08	 lea	 eax, DWORD PTR _letter$[ebp]
  00095	50		 push	 eax
  00096	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00099	8b cc		 mov	 ecx, esp
  0009b	89 a5 e8 fe ff
	ff		 mov	 DWORD PTR $T9[ebp], esp
  000a1	51		 push	 ecx
  000a2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::end
  000aa	89 85 74 fe ff
	ff		 mov	 DWORD PTR tv197[ebp], eax
  000b0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000b3	8b d4		 mov	 edx, esp
  000b5	89 a5 dc fe ff
	ff		 mov	 DWORD PTR $T8[ebp], esp
  000bb	52		 push	 edx
  000bc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	e8 00 00 00 00	 call	 ?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::begin
  000c4	89 85 70 fe ff
	ff		 mov	 DWORD PTR tv200[ebp], eax
  000ca	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@D@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@V10@0ABD@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >,char>
  000d6	83 c4 20	 add	 esp, 32			; 00000020H
  000d9	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  000df	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  000e5	89 8d 68 fe ff
	ff		 mov	 DWORD PTR tv202[ebp], ecx
  000eb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000ef	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR tv202[ebp]
  000f5	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::operator!=
  000fa	88 85 67 fe ff
	ff		 mov	 BYTE PTR tv140[ebp], al
  00100	8a 95 67 fe ff
	ff		 mov	 dl, BYTE PTR tv140[ebp]
  00106	88 95 f7 fe ff
	ff		 mov	 BYTE PTR $T10[ebp], dl
  0010c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00110	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00116	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  0011b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0011f	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00125	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  0012a	0f b6 85 f7 fe
	ff ff		 movzx	 eax, BYTE PTR $T10[ebp]
  00131	85 c0		 test	 eax, eax
  00133	74 21		 je	 SHORT $LN2@addMenuOpt

; 22   : 	{
; 23   : 		return false;

  00135	c6 85 ab fe ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
  0013c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00143	8d 4d 0c	 lea	 ecx, DWORD PTR _text$[ebp]
  00146	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0014b	8a 85 ab fe ff
	ff		 mov	 al, BYTE PTR $T5[ebp]
  00151	e9 8e 00 00 00	 jmp	 $LN1@addMenuOpt
$LN2@addMenuOpt:

; 24   : 	}
; 25   : 
; 26   : 	// Make a new temporary option variable that will be added to the vector
; 27   : 	Option newOption;

  00156	8d 4d c0	 lea	 ecx, DWORD PTR _newOption$[ebp]
  00159	e8 00 00 00 00	 call	 ??0Option@CCustomMenu@@QAE@XZ
  0015e	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 28   : 	newOption.letter = letter;

  00162	8a 45 08	 mov	 al, BYTE PTR _letter$[ebp]
  00165	88 45 c0	 mov	 BYTE PTR _newOption$[ebp], al

; 29   : 	newOption.text = text;

  00168	8d 45 0c	 lea	 eax, DWORD PTR _text$[ebp]
  0016b	50		 push	 eax
  0016c	8d 4d c4	 lea	 ecx, DWORD PTR _newOption$[ebp+4]
  0016f	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 30   : 
; 31   : 	// Add the new option
; 32   : 	optionList.push_back(newOption);

  00174	8d 45 c0	 lea	 eax, DWORD PTR _newOption$[ebp]
  00177	50		 push	 eax
  00178	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017b	e8 00 00 00 00	 call	 ?push_back@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXABUOption@CCustomMenu@@@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::push_back

; 33   : 
; 34   : 	// Sort the list so it is in alphabetical order
; 35   : 	sort(optionList.begin(), optionList.end());

  00180	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00183	8b c4		 mov	 eax, esp
  00185	89 a5 9c fe ff
	ff		 mov	 DWORD PTR $T4[ebp], esp
  0018b	50		 push	 eax
  0018c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	e8 00 00 00 00	 call	 ?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::end
  00194	89 85 7c fe ff
	ff		 mov	 DWORD PTR tv206[ebp], eax
  0019a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0019d	8b cc		 mov	 ecx, esp
  0019f	89 a5 90 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  001a5	51		 push	 ecx
  001a6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a9	e8 00 00 00 00	 call	 ?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::begin
  001ae	89 85 78 fe ff
	ff		 mov	 DWORD PTR tv209[ebp], eax
  001b4	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > > >
  001b9	83 c4 18	 add	 esp, 24			; 00000018H

; 36   : 
; 37   : 	return true;

  001bc	c6 85 87 fe ff
	ff 01		 mov	 BYTE PTR $T2[ebp], 1
  001c3	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001c7	8d 4d c0	 lea	 ecx, DWORD PTR _newOption$[ebp]
  001ca	e8 00 00 00 00	 call	 ??1Option@CCustomMenu@@QAE@XZ
  001cf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001d6	8d 4d 0c	 lea	 ecx, DWORD PTR _text$[ebp]
  001d9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001de	8a 85 87 fe ff
	ff		 mov	 al, BYTE PTR $T2[ebp]
$LN1@addMenuOpt:

; 38   : }

  001e4	52		 push	 edx
  001e5	8b cd		 mov	 ecx, ebp
  001e7	50		 push	 eax
  001e8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@addMenuOpt
  001ee	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001f3	58		 pop	 eax
  001f4	5a		 pop	 edx
  001f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ff	59		 pop	 ecx
  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	5b		 pop	 ebx
  00203	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00206	33 cd		 xor	 ecx, ebp
  00208	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020d	81 c4 9c 01 00
	00		 add	 esp, 412		; 0000019cH
  00213	3b ec		 cmp	 ebp, esp
  00215	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0021a	8b e5		 mov	 esp, ebp
  0021c	5d		 pop	 ebp
  0021d	c2 20 00	 ret	 32			; 00000020H
$LN15@addMenuOpt:
  00220	01 00 00 00	 DD	 1
  00224	00 00 00 00	 DD	 $LN14@addMenuOpt
$LN14@addMenuOpt:
  00228	c0 ff ff ff	 DD	 -64			; ffffffc0H
  0022c	20 00 00 00	 DD	 32			; 00000020H
  00230	00 00 00 00	 DD	 $LN12@addMenuOpt
$LN12@addMenuOpt:
  00234	6e		 DB	 110			; 0000006eH
  00235	65		 DB	 101			; 00000065H
  00236	77		 DB	 119			; 00000077H
  00237	4f		 DB	 79			; 0000004fH
  00238	70		 DB	 112			; 00000070H
  00239	74		 DB	 116			; 00000074H
  0023a	69		 DB	 105			; 00000069H
  0023b	6f		 DB	 111			; 0000006fH
  0023c	6e		 DB	 110			; 0000006eH
  0023d	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _text$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  00008	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$4:
  00013	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$5:
  0001e	8d 4d c0	 lea	 ecx, DWORD PTR _newOption$[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1Option@CCustomMenu@@QAE@XZ
__ehhandler$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00026	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002d	8b 8a 60 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-416]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003d	33 c8		 xor	 ecx, eax
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00049	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?addMenuOption@CCustomMenu@@QAE_NDV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CCustomMenu::addMenuOption
; Function compile flags: /Odtp /RTCsu /ZI
; File s:\chris\onedrive - uat\c++ programming ii\pete_final\pete_final\custommenu.cpp
;	COMDAT ??1CCustomMenu@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CCustomMenu@@QAE@XZ PROC				; CCustomMenu::~CCustomMenu, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : }

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::~vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1CCustomMenu@@QAE@XZ ENDP				; CCustomMenu::~CCustomMenu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File s:\chris\onedrive - uat\c++ programming ii\pete_final\pete_final\custommenu.cpp
;	COMDAT ??0CCustomMenu@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0CCustomMenu@@QAE@XZ PROC				; CCustomMenu::CCustomMenu, COMDAT
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >

; 7    : }

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0CCustomMenu@@QAE@XZ ENDP				; CCustomMenu::CCustomMenu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z
_TEXT	SEGMENT
__Pnext$ = -44						; size = 4
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1775 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00021	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1776 : 		_Lockit _Lock(_LOCK_DEBUG);

  00042	8b f4		 mov	 esi, esp
  00044	6a 03		 push	 3
  00046	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1777 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

  0005d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getpfirst
  00065	89 45 d4	 mov	 DWORD PTR __Pnext$[ebp], eax

; 1778 : 		if (_Pnext != 0)

  00068	83 7d d4 00	 cmp	 DWORD PTR __Pnext$[ebp], 0
  0006c	74 4e		 je	 SHORT $LN4@Orphan_ran
$LN2@Orphan_ran:

; 1779 : 			{	// test an iterator
; 1780 : 			while (*_Pnext != 0)

  0006e	8b 45 d4	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00071	83 38 00	 cmp	 DWORD PTR [eax], 0
  00074	74 46		 je	 SHORT $LN4@Orphan_ran

; 1781 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

  00076	8b 45 d4	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007e	3b 55 08	 cmp	 edx, DWORD PTR __First$[ebp]
  00081	72 0d		 jb	 SHORT $LN7@Orphan_ran
  00083	8b 45 d4	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0008b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0008e	73 0f		 jae	 SHORT $LN5@Orphan_ran
$LN7@Orphan_ran:

; 1782 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

  00090	8b 45 d4	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00093	8b 08		 mov	 ecx, DWORD PTR [eax]
  00095	e8 00 00 00 00	 call	 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
  0009a	89 45 d4	 mov	 DWORD PTR __Pnext$[ebp], eax

; 1783 : 				else

  0009d	eb 1b		 jmp	 SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1784 : 					{	// orphan the iterator
; 1785 : 					(*_Pnext)->_Clrcont();

  0009f	8b 45 d4	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	e8 00 00 00 00	 call	 ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont

; 1786 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

  000a9	8b 45 d4	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	e8 00 00 00 00	 call	 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
  000b3	8b 4d d4	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  000b6	8b 10		 mov	 edx, DWORD PTR [eax]
  000b8	89 11		 mov	 DWORD PTR [ecx], edx
$LN6@Orphan_ran:

; 1787 : 					}

  000ba	eb b2		 jmp	 SHORT $LN2@Orphan_ran
$LN4@Orphan_ran:

; 1788 : 			}
; 1789 : 		}

  000bc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c3	8b f4		 mov	 esi, esp
  000c5	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	52		 push	 edx
  000d6	8b cd		 mov	 ecx, ebp
  000d8	50		 push	 eax
  000d9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@Orphan_ran
  000df	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e4	58		 pop	 eax
  000e5	5a		 pop	 edx
  000e6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f0	59		 pop	 ecx
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000fa	3b ec		 cmp	 ebp, esp
  000fc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 08 00	 ret	 8
  00107	90		 npad	 1
$LN13@Orphan_ran:
  00108	01 00 00 00	 DD	 1
  0010c	00 00 00 00	 DD	 $LN12@Orphan_ran
$LN12@Orphan_ran:
  00110	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00114	04 00 00 00	 DD	 4
  00118	00 00 00 00	 DD	 $LN10@Orphan_ran
$LN10@Orphan_ran:
  0011c	5f		 DB	 95			; 0000005fH
  0011d	4c		 DB	 76			; 0000004cH
  0011e	6f		 DB	 111			; 0000006fH
  0011f	63		 DB	 99			; 00000063H
  00120	6b		 DB	 107			; 0000006bH
  00121	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 0c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-244]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXXZ PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Xlen, COMDAT
; _this$ = ecx

; 1764 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1765 : 		_Xlength_error("vector<T> too long");

  00023	8b f4		 mov	 esi, esp
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xlen:

; 1766 : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?_Xlen@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXXZ ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Tidy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXXZ PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1637 : 		if (this->_Myfirst() != pointer())

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	0f 84 84 00 00
	00		 je	 $LN1@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();

  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Orphan_all

; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	50		 push	 eax
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	51		 push	 ecx
  00052	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXPAUOption@CCustomMenu@@0@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Destroy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
  00062	8b f0		 mov	 esi, eax
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  0006c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006e	2b 08		 sub	 ecx, DWORD PTR [eax]
  00070	c1 f9 05	 sar	 ecx, 5
  00073	51		 push	 ecx
  00074	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  0007c	8b 10		 mov	 edx, DWORD PTR [eax]
  0007e	52		 push	 edx
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@I@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::deallocate

; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();

  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  00096	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1644 : 			this->_Mylast() = pointer();

  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  000a4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1645 : 			this->_Myend() = pointer();

  000aa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
  000b2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Tidy:

; 1646 : 			}
; 1647 : 		}

  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
?_Tidy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXXZ ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1627 : 		if (_Unused_capacity() < _Count)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Unused_capacity@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Unused_capacity
  0002b	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0002e	73 3e		 jae	 SHORT $LN4@Reserve

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?max_size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::max_size
  00038	8b f0		 mov	 esi, eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::size
  00042	2b f0		 sub	 esi, eax
  00044	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  00047	73 08		 jae	 SHORT $LN3@Reserve

; 1630 : 				_Xlen();

  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Xlen
$LN3@Reserve:

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::size
  00059	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEII@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Grow_to
  00065	50		 push	 eax
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Reallocate
$LN4@Reserve:

; 1632 : 			}
; 1633 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
?_Reserve@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -48						; size = 4
__Ptr$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00022	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	59		 pop	 ecx
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00043	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  00052	8b c8		 mov	 ecx, eax
  00054	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEPAUOption@CCustomMenu@@I@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::allocate
  00059	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1603 : 
; 1604 : 		_TRY_BEGIN

  0005c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  00063	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00066	50		 push	 eax
  00067	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	51		 push	 ecx
  00072	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  0007a	8b 10		 mov	 edx, DWORD PTR [eax]
  0007c	52		 push	 edx
  0007d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ??$_Umove@PAUOption@CCustomMenu@@@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEPAUOption@CCustomMenu@@PAU23@00@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Umove<CCustomMenu::Option *>
  00085	eb 26		 jmp	 SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z$0:

; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);

  00087	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d dc	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0008e	51		 push	 ecx
  0008f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  00097	8b c8		 mov	 ecx, eax
  00099	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@I@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::deallocate

; 1608 : 		_RERAISE;

  0009e	6a 00		 push	 0
  000a0	6a 00		 push	 0
  000a2	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1609 : 		_CATCH_END

  000a7	b8 00 00 00 00	 mov	 eax, $LN8@Reallocate
  000ac	c3		 ret	 0
$LN5@Reallocate:
  000ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b4	eb 07		 jmp	 SHORT __tryend$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
  000b6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z$1:

; 1610 : 
; 1611 : 		size_type _Size = size();

  000bd	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::size
  000c5	89 45 d0	 mov	 DWORD PTR __Size$[ebp], eax

; 1612 : 		if (this->_Myfirst() != pointer())

  000c8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  000d0	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d3	74 52		 je	 SHORT $LN3@Reallocate

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  000d5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  000dd	8b 00		 mov	 eax, DWORD PTR [eax]
  000df	50		 push	 eax
  000e0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  000e8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ea	51		 push	 ecx
  000eb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXPAUOption@CCustomMenu@@0@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Destroy

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

  000f3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  000fb	8b f0		 mov	 esi, eax
  000fd	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
  00105	8b 00		 mov	 eax, DWORD PTR [eax]
  00107	2b 06		 sub	 eax, DWORD PTR [esi]
  00109	c1 f8 05	 sar	 eax, 5
  0010c	50		 push	 eax
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  00115	8b 08		 mov	 ecx, DWORD PTR [eax]
  00117	51		 push	 ecx
  00118	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  00120	8b c8		 mov	 ecx, eax
  00122	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@I@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::deallocate
$LN3@Reallocate:

; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();

  00127	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Orphan_all

; 1620 : 		this->_Myend() = _Ptr + _Count;

  0012f	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  00132	c1 e6 05	 shl	 esi, 5
  00135	03 75 dc	 add	 esi, DWORD PTR __Ptr$[ebp]
  00138	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
  00140	89 30		 mov	 DWORD PTR [eax], esi

; 1621 : 		this->_Mylast() = _Ptr + _Size;

  00142	8b 75 d0	 mov	 esi, DWORD PTR __Size$[ebp]
  00145	c1 e6 05	 shl	 esi, 5
  00148	03 75 dc	 add	 esi, DWORD PTR __Ptr$[ebp]
  0014b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  00153	89 30		 mov	 DWORD PTR [eax], esi

; 1622 : 		this->_Myfirst() = _Ptr;

  00155	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00158	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  0015d	8b 4d dc	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00160	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Reallocate:

; 1623 : 		}

  00162	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00165	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016c	59		 pop	 ecx
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi
  0016f	5b		 pop	 ebx
  00170	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  00176	3b ec		 cmp	 ebp, esp
  00178	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Reallocate
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBE_NPBUOption@CCustomMenu@@@Z
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBE_NPBUOption@CCustomMenu@@@Z PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unfancy<CCustomMenu::Option>
  00033	83 c4 04	 add	 esp, 4
  00036	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  00039	73 24		 jae	 SHORT $LN3@Inside
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unfancy<CCustomMenu::Option>
  0004b	83 c4 04	 add	 esp, 4
  0004e	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  00051	77 0c		 ja	 SHORT $LN3@Inside
  00053	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv82[ebp], 1
  0005d	eb 0a		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0005f	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv82[ebp], 0
$LN4@Inside:
  00069	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv82[ebp]

; 1598 : 		}

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
?_Inside@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBE_NPBUOption@CCustomMenu@@@Z ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Capacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEII@Z PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1586 : 		size_type _Capacity = capacity();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?capacity@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::capacity
  0002b	89 45 ec	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?max_size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::max_size
  00036	8b 4d ec	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00039	d1 e9		 shr	 ecx, 1
  0003b	2b c1		 sub	 eax, ecx
  0003d	3b 45 ec	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00040	73 0c		 jae	 SHORT $LN4@Grow_to
  00042	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
  0004c	eb 0e		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0004e	8b 55 ec	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00051	d1 ea		 shr	 edx, 1
  00053	03 55 ec	 add	 edx, DWORD PTR __Capacity$[ebp]
  00056	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0005c	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  00062	89 45 ec	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

  00065	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00068	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0006b	73 06		 jae	 SHORT $LN2@Grow_to

; 1591 : 			_Capacity = _Count;

  0006d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN2@Grow_to:

; 1592 : 		return (_Capacity);

  00073	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1593 : 		}

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?_Grow_to@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEII@Z ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXPAUOption@CCustomMenu@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXPAUOption@CCustomMenu@@0@Z PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Destroy, COMDAT
; _this$ = ecx

; 1580 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  0002b	50		 push	 eax
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UOption@CCustomMenu@@@std@@PAUOption@CCustomMenu@@@std@@YAXPAUOption@CCustomMenu@@0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<CCustomMenu::Option>,CCustomMenu::Option *>
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1582 : 		}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
?_Destroy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXPAUOption@CCustomMenu@@0@Z ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXABUOption@CCustomMenu@@@Z
_TEXT	SEGMENT
tv231 = -220						; size = 4
tv176 = -220						; size = 4
__Idx$1 = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXABUOption@CCustomMenu@@@Z PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1277 : 		if (_Inside(_STD addressof(_Val)))

  00023	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$addressof@$$CBUOption@CCustomMenu@@@std@@YAPBUOption@CCustomMenu@@ABU12@@Z ; std::addressof<CCustomMenu::Option const >
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Inside@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBE_NPBUOption@CCustomMenu@@@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Inside
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	0f 84 c3 00 00
	00		 je	 $LN2@push_back

; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

  00043	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$addressof@$$CBUOption@CCustomMenu@@@std@@YAPBUOption@CCustomMenu@@ABU12@@Z ; std::addressof<CCustomMenu::Option const >
  0004c	83 c4 04	 add	 esp, 4
  0004f	8b f0		 mov	 esi, eax
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unfancy<CCustomMenu::Option>
  00061	83 c4 04	 add	 esp, 4
  00064	2b f0		 sub	 esi, eax
  00066	c1 fe 05	 sar	 esi, 5
  00069	89 75 ec	 mov	 DWORD PTR __Idx$1[ebp], esi

; 1280 : 			if (this->_Mylast() == this->_Myend())

  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  00074	8b f0		 mov	 esi, eax
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
  0007e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00080	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00082	75 0a		 jne	 SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

  00084	6a 01		 push	 1
  00086	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Reserve
$LN4@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  00096	8b 00		 mov	 eax, DWORD PTR [eax]
  00098	50		 push	 eax
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	51		 push	 ecx
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Orphan_range

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  000b4	8b 4d ec	 mov	 ecx, DWORD PTR __Idx$1[ebp]
  000b7	c1 e1 05	 shl	 ecx, 5
  000ba	03 08		 add	 ecx, DWORD PTR [eax]
  000bc	51		 push	 ecx
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  000c5	8b 10		 mov	 edx, DWORD PTR [eax]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unfancy<CCustomMenu::Option>
  000cd	83 c4 04	 add	 esp, 4
  000d0	50		 push	 eax
  000d1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  000d9	8b c8		 mov	 ecx, eax
  000db	e8 00 00 00 00	 call	 ??$construct@UOption@CCustomMenu@@AAU12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@AAU23@@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option &>

; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();

  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  000e8	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv176[ebp], eax
  000ee	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  000f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f6	83 c1 20	 add	 ecx, 32			; 00000020H
  000f9	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv176[ebp]
  000ff	89 0a		 mov	 DWORD PTR [edx], ecx

; 1286 : 			}
; 1287 : 		else

  00101	e9 88 00 00 00	 jmp	 $LN1@push_back
$LN2@push_back:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

  00106	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  0010e	8b f0		 mov	 esi, eax
  00110	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
  00118	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0011a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0011c	75 0a		 jne	 SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

  0011e	6a 01		 push	 1
  00120	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXI@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Reserve
$LN5@push_back:

; 1291 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

  00128	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  00130	8b 00		 mov	 eax, DWORD PTR [eax]
  00132	50		 push	 eax
  00133	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	51		 push	 ecx
  0013e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IBEXPAUOption@CCustomMenu@@0@Z ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Orphan_range

; 1292 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00146	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00149	50		 push	 eax
  0014a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  00152	8b 08		 mov	 ecx, DWORD PTR [eax]
  00154	51		 push	 ecx
  00155	e8 00 00 00 00	 call	 ??$_Unfancy@UOption@CCustomMenu@@@std@@YAPAUOption@CCustomMenu@@PAU12@@Z ; std::_Unfancy<CCustomMenu::Option>
  0015a	83 c4 04	 add	 esp, 4
  0015d	50		 push	 eax
  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  00166	8b c8		 mov	 ecx, eax
  00168	e8 00 00 00 00	 call	 ??$construct@UOption@CCustomMenu@@ABU12@@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@ABU23@@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::construct<CCustomMenu::Option,CCustomMenu::Option const &>

; 1293 : 				_Val);
; 1294 : 			++this->_Mylast();

  0016d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00170	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  00175	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv231[ebp], eax
  0017b	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv231[ebp]
  00181	8b 08		 mov	 ecx, DWORD PTR [eax]
  00183	83 c1 20	 add	 ecx, 32			; 00000020H
  00186	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv231[ebp]
  0018c	89 0a		 mov	 DWORD PTR [edx], ecx
$LN1@push_back:

; 1295 : 			}
; 1296 : 		}

  0018e	5f		 pop	 edi
  0018f	5e		 pop	 esi
  00190	5b		 pop	 ebx
  00191	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00197	3b ec		 cmp	 ebp, esp
  00199	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c2 04 00	 ret	 4
?push_back@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXABUOption@CCustomMenu@@@Z ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?max_size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1185 : 		return (this->_Getal().max_size());

  00023	0f b6 85 2f ff
	ff ff		 movzx	 eax, BYTE PTR $T1[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  00033	8b c8		 mov	 ecx, eax
  00035	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::max_size

; 1186 : 		}

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?max_size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::size, COMDAT
; _this$ = ecx

; 1179 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	2b 08		 sub	 ecx, DWORD PTR [eax]
  00039	c1 f9 05	 sar	 ecx, 5
  0003c	8b c1		 mov	 eax, ecx

; 1181 : 		}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?size@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::end, COMDAT
; _this$ = ecx

; 1067 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1068 : 		return (iterator(this->_Mylast(), &this->_Get_data()));

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0004a	50		 push	 eax
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	50		 push	 eax
  00056	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00059	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
  0005e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1069 : 		}

  00061	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00064	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006b	59		 pop	 ecx
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?end@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::end
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0004a	50		 push	 eax
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	50		 push	 eax
  00056	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00059	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@PAUOption@CCustomMenu@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCustomMenu::Option> > >
  0005e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1059 : 		}

  00061	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00064	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006b	59		 pop	 ecx
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@@2@XZ ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::begin
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unused_capacity@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		{	// micro-optimization for capacity() - size()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	2b 08		 sub	 ecx, DWORD PTR [eax]
  00039	c1 f9 05	 sar	 ecx, 5
  0003c	8b c1		 mov	 eax, ecx

; 1049 : 		}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?_Unused_capacity@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?capacity@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	2b 08		 sub	 ecx, DWORD PTR [eax]
  00039	c1 f9 05	 sar	 ecx, 5
  0003c	8b c1		 mov	 eax, ecx

; 1044 : 		}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?capacity@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIXZ ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::~vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 976  : 		_Tidy();

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@IAEXXZ ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::_Tidy

; 977  : 		}

  0004a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ??1?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::~_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::~vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ PROC ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >, COMDAT
; _this$ = ecx

; 707  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 706  : 		: _Mybase()

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >

; 708  : 		}

  0004a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ENDP ; std::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >::vector<CCustomMenu::Option,std::allocator<CCustomMenu::Option> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@QAE@XZ
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 320  : 		return (_Myval2);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 321  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 315  : 		return (_Myval2);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 316  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		{	// return const reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 300  : 		return (*this);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 301  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 295  : 		return (*this);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 296  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >::~_Vector_val<std::_Simple_types<CCustomMenu::Option> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >::~_Vector_val<std::_Simple_types<CCustomMenu::Option> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >::_Vector_val<std::_Simple_types<CCustomMenu::Option> >, COMDAT
; _this$ = ecx

; 488  : 		{	// initialize values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12

; 485  : 		: _Myfirst(),

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 486  : 		_Mylast(),

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 487  : 		_Myend()

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 489  : 		}

  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >::_Vector_val<std::_Simple_types<CCustomMenu::Option> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		{	// return const reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 668  : 		return (_Get_data()._Myend);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0002b	83 c0 0c	 add	 eax, 12			; 0000000cH

; 669  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		{	// return reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 663  : 		return (_Get_data()._Myend);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0002b	83 c0 0c	 add	 eax, 12			; 0000000cH

; 664  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		{	// return const reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 658  : 		return (_Get_data()._Mylast);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0002b	83 c0 08	 add	 eax, 8

; 659  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		{	// return reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 653  : 		return (_Get_data()._Mylast);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0002b	83 c0 08	 add	 eax, 8

; 654  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		{	// return const reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 648  : 		return (_Get_data()._Myfirst);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0002b	83 c0 04	 add	 eax, 4

; 649  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABQAUOption@CCustomMenu@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		{	// return reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 		return (_Get_data()._Myfirst);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0002b	83 c0 04	 add	 eax, 4

; 644  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAUOption@CCustomMenu@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		{	// return const reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 		return (_Mypair._Get_second());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_second

; 639  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		{	// return reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 633  : 		return (_Mypair._Get_second());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_second

; 634  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		{	// return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 		return (_Mypair._Get_first());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_first

; 629  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 623  : 		return (_Mypair._Get_first());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Get_first

; 624  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 613  : 		_Get_data()._Orphan_all();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0002b	8b c8		 mov	 ecx, eax
  0002d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 614  : 		}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myproxy, COMDAT
; _this$ = ecx

; 601  : 		{	// return reference to _Myproxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 602  : 		return (_Get_data()._Myproxy);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data

; 603  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getpfirst, COMDAT
; _this$ = ecx

; 596  : 		{	// get address of iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 597  : 		return (_Get_data()._Getpfirst());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0002b	8b c8		 mov	 ecx, eax
  0002d	e8 00 00 00 00	 call	 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst

; 598  : 		}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 586  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 587  : 		typename _Alty::template rebind<_Container_proxy>::other
; 588  : 			_Alproxy(_Getal());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  0002b	50		 push	 eax
  0002c	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$?0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<CCustomMenu::Option> > &>

; 589  : 		_Orphan_all();

  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Orphan_all

; 590  : 		_Alproxy.destroy(_Myproxy());

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myproxy
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	50		 push	 eax
  00047	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0004a	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 591  : 		_Alproxy.deallocate(_Alproxy.address(*_Myproxy()), 1);

  0004f	6a 01		 push	 1
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myproxy
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	50		 push	 eax
  0005c	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0005f	e8 00 00 00 00	 call	 ?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
  00064	50		 push	 eax
  00065	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00068	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 592  : 		_Myproxy() = 0;

  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myproxy
  00075	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 593  : 		}

  0007b	52		 push	 edx
  0007c	8b cd		 mov	 ecx, ebp
  0007e	50		 push	 eax
  0007f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Free_proxy
  00085	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008a	58		 pop	 eax
  0008b	5a		 pop	 edx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN5@Free_proxy:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN4@Free_proxy
$LN4@Free_proxy:
  000a8	ef ff ff ff	 DD	 -17			; ffffffefH
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN3@Free_proxy
$LN3@Free_proxy:
  000b4	5f		 DB	 95			; 0000005fH
  000b5	41		 DB	 65			; 00000041H
  000b6	6c		 DB	 108			; 0000006cH
  000b7	70		 DB	 112			; 00000070H
  000b8	72		 DB	 114			; 00000072H
  000b9	6f		 DB	 111			; 0000006fH
  000ba	78		 DB	 120			; 00000078H
  000bb	79		 DB	 121			; 00000079H
  000bc	00		 DB	 0
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 577  : 		{	// construct proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 578  : 		typename _Alty::template rebind<_Container_proxy>::other
; 579  : 			_Alproxy(_Getal());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Getal
  0002b	50		 push	 eax
  0002c	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$?0AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<CCustomMenu::Option> > &>

; 580  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

  00034	6a 01		 push	 1
  00036	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00039	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00044	83 c4 04	 add	 esp, 4
  00047	8b f0		 mov	 esi, eax
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myproxy
  00051	89 30		 mov	 DWORD PTR [eax], esi

; 581  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());

  00053	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00059	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy
  0005e	50		 push	 eax
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myproxy
  00067	8b 00		 mov	 eax, DWORD PTR [eax]
  00069	50		 push	 eax
  0006a	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0006d	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 582  : 		_Myproxy()->_Mycont = &_Get_data();

  00072	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Get_data
  0007a	8b f0		 mov	 esi, eax
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Myproxy
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
  00086	89 30		 mov	 DWORD PTR [eax], esi

; 583  : 		}

  00088	52		 push	 edx
  00089	8b cd		 mov	 ecx, ebp
  0008b	50		 push	 eax
  0008c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Alloc_prox
  00092	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00097	58		 pop	 eax
  00098	5a		 pop	 edx
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000a2	3b ec		 cmp	 ebp, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
  000ad	0f 1f 00	 npad	 3
$LN5@Alloc_prox:
  000b0	01 00 00 00	 DD	 1
  000b4	00 00 00 00	 DD	 $LN4@Alloc_prox
$LN4@Alloc_prox:
  000b8	ef ff ff ff	 DD	 -17			; ffffffefH
  000bc	01 00 00 00	 DD	 1
  000c0	00 00 00 00	 DD	 $LN3@Alloc_prox
$LN3@Alloc_prox:
  000c4	5f		 DB	 95			; 0000005fH
  000c5	41		 DB	 65			; 00000041H
  000c6	6c		 DB	 108			; 0000006cH
  000c7	70		 DB	 112			; 00000070H
  000c8	72		 DB	 114			; 00000072H
  000c9	6f		 DB	 111			; 0000006fH
  000ca	78		 DB	 120			; 00000078H
  000cb	79		 DB	 121			; 00000079H
  000cc	00		 DB	 0
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::~_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 559  : 		_Free_proxy();

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Free_proxy

; 560  : 		}

  0004a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@XZ
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::~_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >, COMDAT
; _this$ = ecx

; 544  : 		{	// default construct allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00021	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 543  : 		: _Mypair(_Zero_then_variadic_args_t())

  00042	0f b6 85 23 ff
	ff ff		 movzx	 eax, BYTE PTR $T2[ebp]
  00049	50		 push	 eax
  0004a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >,std::_Vector_val<std::_Simple_types<CCustomMenu::Option> >,1><>
  00052	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 545  : 		_Alloc_proxy();

  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Alloc_proxy

; 546  : 		}

  00061	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00068	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UOption@CCustomMenu@@@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@U?$_Vec_base_types@UOption@CCustomMenu@@V?$allocator@UOption@CCustomMenu@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >::_Vector_alloc<std::_Vec_base_types<CCustomMenu::Option,std::allocator<CCustomMenu::Option> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::max_size, COMDAT
; _this$ = ecx

; 1007 : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAIABV?$allocator@UOption@CCustomMenu@@@2@@Z ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::max_size
  0002c	83 c4 04	 add	 esp, 4

; 1009 : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@I@Z ; std::allocator<CCustomMenu::Option>::deallocate

; 988  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEXPAUOption@CCustomMenu@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEPAUOption@CCustomMenu@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEPAUOption@CCustomMenu@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 976  : 		return (_Mybase::allocate(_Count));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?allocate@?$allocator@UOption@CCustomMenu@@@std@@QAEPAUOption@CCustomMenu@@I@Z ; std::allocator<CCustomMenu::Option>::allocate

; 977  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAEPAUOption@CCustomMenu@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::_Wrap_alloc<std::allocator<CCustomMenu::Option> >, COMDAT
; _this$ = ecx

; 936  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 935  : 		: _Mybase()

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$allocator@UOption@CCustomMenu@@@std@@QAE@XZ ; std::allocator<CCustomMenu::Option>::allocator<CCustomMenu::Option>

; 937  : 		}

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@UOption@CCustomMenu@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CCustomMenu::Option> >::_Wrap_alloc<std::allocator<CCustomMenu::Option> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAIABV?$allocator@UOption@CCustomMenu@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAIABV?$allocator@UOption@CCustomMenu@@@2@@Z PROC ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::max_size, COMDAT

; 868  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 869  : 		return (_Al.max_size());

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00021	e8 00 00 00 00	 call	 ?max_size@?$allocator@UOption@CCustomMenu@@@std@@QBEIXZ ; std::allocator<CCustomMenu::Option>::max_size

; 870  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UOption@CCustomMenu@@@std@@@std@@SAIABV?$allocator@UOption@CCustomMenu@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CCustomMenu::Option> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UOption@CCustomMenu@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@UOption@CCustomMenu@@@std@@QBEIXZ PROC ; std::allocator<CCustomMenu::Option>::max_size, COMDAT
; _this$ = ecx

; 748  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00023	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 750  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?max_size@?$allocator@UOption@CCustomMenu@@@std@@QBEIXZ ENDP ; std::allocator<CCustomMenu::Option>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UOption@CCustomMenu@@@std@@QAEPAUOption@CCustomMenu@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UOption@CCustomMenu@@@std@@QAEPAUOption@CCustomMenu@@I@Z PROC ; std::allocator<CCustomMenu::Option>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00023	6a 01		 push	 1
  00025	6a 20		 push	 32			; 00000020H
  00027	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 726  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?allocate@?$allocator@UOption@CCustomMenu@@@std@@QAEPAUOption@CCustomMenu@@I@Z ENDP ; std::allocator<CCustomMenu::Option>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@I@Z PROC ; std::allocator<CCustomMenu::Option>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00023	6a 20		 push	 32			; 00000020H
  00025	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 721  : 		}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
?deallocate@?$allocator@UOption@CCustomMenu@@@std@@QAEXPAUOption@CCustomMenu@@I@Z ENDP ; std::allocator<CCustomMenu::Option>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UOption@CCustomMenu@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@UOption@CCustomMenu@@@std@@QAE@XZ PROC	; std::allocator<CCustomMenu::Option>::allocator<CCustomMenu::Option>, COMDAT
; _this$ = ecx

; 699  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??0?$allocator@UOption@CCustomMenu@@@std@@QAE@XZ ENDP	; std::allocator<CCustomMenu::Option>::allocator<CCustomMenu::Option>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GOption@CCustomMenu@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GOption@CCustomMenu@@QAEPAXI@Z PROC			; CCustomMenu::Option::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1Option@CCustomMenu@@QAE@XZ
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0e		 je	 SHORT $LN2@scalar
  00033	6a 20		 push	 32			; 00000020H
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003e	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
??_GOption@CCustomMenu@@QAEPAXI@Z ENDP			; CCustomMenu::Option::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z PROC		; CCustomMenu::Option::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00029	8a 11		 mov	 dl, BYTE PTR [ecx]
  0002b	88 10		 mov	 BYTE PTR [eax], dl
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 04	 add	 ecx, 4
  0003a	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??4Option@CCustomMenu@@QAEAAU01@$$QAU01@@Z ENDP		; CCustomMenu::Option::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0Option@CCustomMenu@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0Option@CCustomMenu@@QAE@$$QAU01@@Z PROC		; CCustomMenu::Option::Option, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00029	8a 11		 mov	 dl, BYTE PTR [ecx]
  0002b	88 10		 mov	 BYTE PTR [eax], dl
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 04	 add	 ecx, 4
  0003a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??0Option@CCustomMenu@@QAE@$$QAU01@@Z ENDP		; CCustomMenu::Option::Option
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0Option@CCustomMenu@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0Option@CCustomMenu@@QAE@ABU01@@Z PROC		; CCustomMenu::Option::Option, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00029	8a 11		 mov	 dl, BYTE PTR [ecx]
  0002b	88 10		 mov	 BYTE PTR [eax], dl
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 04	 add	 ecx, 4
  0003a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??0Option@CCustomMenu@@QAE@ABU01@@Z ENDP		; CCustomMenu::Option::Option
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1Option@CCustomMenu@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1Option@CCustomMenu@@QAE@XZ PROC			; CCustomMenu::Option::~Option, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 04	 add	 ecx, 4
  00029	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??1Option@CCustomMenu@@QAE@XZ ENDP			; CCustomMenu::Option::~Option
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0Option@CCustomMenu@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Option@CCustomMenu@@QAE@XZ PROC			; CCustomMenu::Option::Option, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 04	 add	 ecx, 4
  00029	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??0Option@CCustomMenu@@QAE@XZ ENDP			; CCustomMenu::Option::Option
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File s:\chris\onedrive - uat\c++ programming ii\pete_final\pete_final\custommenu.h
;	COMDAT ??MOption@CCustomMenu@@QBE_NABU01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
_rightSide$ = 8						; size = 4
??MOption@CCustomMenu@@QBE_NABU01@@Z PROC		; CCustomMenu::Option::operator<, COMDAT
; _this$ = ecx

; 25   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 			return this->letter < rightSide.letter;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	8b 55 08	 mov	 edx, DWORD PTR _rightSide$[ebp]
  0002c	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0002f	3b c8		 cmp	 ecx, eax
  00031	7d 0c		 jge	 SHORT $LN3@operator
  00033	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  0003d	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0003f	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00049	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]

; 27   : 		}

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??MOption@CCustomMenu@@QBE_NABU01@@Z ENDP		; CCustomMenu::Option::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File s:\chris\onedrive - uat\c++ programming ii\pete_final\pete_final\custommenu.h
;	COMDAT ??8Option@CCustomMenu@@QBE_NABD@Z
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
_rightSide$ = 8						; size = 4
??8Option@CCustomMenu@@QBE_NABD@Z PROC			; CCustomMenu::Option::operator==, COMDAT
; _this$ = ecx

; 20   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : 			return this->letter == rightSide;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	8b 55 08	 mov	 edx, DWORD PTR _rightSide$[ebp]
  0002c	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0002f	3b c8		 cmp	 ecx, eax
  00031	75 0c		 jne	 SHORT $LN3@operator
  00033	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
  0003d	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0003f	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
$LN4@operator:
  00049	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]

; 22   : 		}

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??8Option@CCustomMenu@@QBE_NABD@Z ENDP			; CCustomMenu::Option::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2282 : 		{	// report an out_of_range error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00023	8b f4		 mov	 esi, esp
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xran:

; 2284 : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2271 : 		if (this->_Mysize() < _Off)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00030	73 08		 jae	 SHORT $LN3@Check_offs

; 2272 : 			_Xran();

  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN3@Check_offs:

; 2273 : 		}

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2265 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2266 : 		_Xlength_error("string too long");

  00023	8b f4		 mov	 esi, esp
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xlen:

; 2267 : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -20						; size = 4
_this$ = -8						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2249 : 		if (!_Built)

  00023	0f b6 45 08	 movzx	 eax, BYTE PTR __Built$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	75 05		 jne	 SHORT $LN2@Tidy
  0002b	e9 84 00 00 00	 jmp	 $LN3@Tidy
$LN2@Tidy:

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00038	83 38 10	 cmp	 DWORD PTR [eax], 16	; 00000010H
  0003b	72 77		 jb	 SHORT $LN3@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 ec	 mov	 DWORD PTR __Ptr$1[ebp], eax

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));

  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  00058	83 c4 04	 add	 esp, 4
  0005b	50		 push	 eax
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00064	8b c8		 mov	 ecx, eax
  00066	e8 00 00 00 00	 call	 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2255 : 			if (0 < _Newsize)

  0006b	83 7d 0c 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0006f	76 22		 jbe	 SHORT $LN5@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  00071	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00074	50		 push	 eax
  00075	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$1[ebp]
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0007e	83 c4 04	 add	 esp, 4
  00081	50		 push	 eax
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00093	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  0009b	8b 00		 mov	 eax, DWORD PTR [eax]
  0009d	83 c0 01	 add	 eax, 1
  000a0	50		 push	 eax
  000a1	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$1[ebp]
  000a4	51		 push	 ecx
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000bc	c7 00 0f 00 00
	00		 mov	 DWORD PTR [eax], 15	; 0000000fH

; 2261 : 		_Eos(_Newsize);

  000c2	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2262 : 		}

  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi
  000d0	5b		 pop	 ebx
  000d1	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000d7	3b ec		 cmp	 ebp, esp
  000d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00023	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00027	74 26		 je	 SHORT $LN4@Inside
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00031	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  00034	72 19		 jb	 SHORT $LN4@Inside
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0003e	8b f0		 mov	 esi, eax
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00048	03 30		 add	 esi, DWORD PTR [eax]
  0004a	3b 75 08	 cmp	 esi, DWORD PTR __Ptr$[ebp]
  0004d	77 06		 ja	 SHORT $LN2@Inside
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  0004f	32 c0		 xor	 al, al
  00051	eb 04		 jmp	 SHORT $LN1@Inside

; 2242 : 		else

  00053	eb 02		 jmp	 SHORT $LN1@Inside
$LN2@Inside:

; 2243 : 			return (true);

  00055	b0 01		 mov	 al, 1
$LN1@Inside:

; 2244 : 		}

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv140 = -208						; size = 4
tv133 = -208						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2225 : 		if (max_size() < _Newsize)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0002b	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0002e	73 08		 jae	 SHORT $LN2@Grow

; 2226 : 			_Xlen();	// result too long

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Grow:

; 2227 : 		if (this->_Myres() < _Newsize)

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00045	73 19		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	50		 push	 eax
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00055	51		 push	 ecx
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0005e	eb 5b		 jmp	 SHORT $LN4@Grow
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00060	0f b6 45 0c	 movzx	 eax, BYTE PTR __Trim$[ebp]
  00064	85 c0		 test	 eax, eax
  00066	74 43		 je	 SHORT $LN5@Grow
  00068	83 7d 08 10	 cmp	 DWORD PTR __Newsize$[ebp], 16 ; 00000010H
  0006c	73 3d		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00076	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00079	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0007b	73 0b		 jae	 SHORT $LN9@Grow
  0007d	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00080	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv133[ebp], edx
  00086	eb 10		 jmp	 SHORT $LN10@Grow
$LN9@Grow:
  00088	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00090	8b 00		 mov	 eax, DWORD PTR [eax]
  00092	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv133[ebp], eax
$LN10@Grow:
  00098	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv133[ebp]
  0009e	51		 push	 ecx
  0009f	6a 01		 push	 1
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000a9	eb 10		 jmp	 SHORT $LN4@Grow
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  000ab	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  000af	75 0a		 jne	 SHORT $LN4@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  000b1	6a 00		 push	 0
  000b3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

  000bb	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  000bf	76 0c		 jbe	 SHORT $LN11@Grow
  000c1	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv140[ebp], 1
  000cb	eb 0a		 jmp	 SHORT $LN12@Grow
$LN11@Grow:
  000cd	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv140[ebp], 0
$LN12@Grow:
  000d7	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv140[ebp]
$LN8@Grow:

; 2235 : 		}

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000e6	3b ec		 cmp	 ebp, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -221						; size = 1
__Dx$ = -20						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00013	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 : 		auto& _Dx = this->_Get_data();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0002b	89 45 ec	 mov	 DWORD PTR __Dx$[ebp], eax

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  0002e	c6 85 23 ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  00035	8b 45 ec	 mov	 eax, DWORD PTR __Dx$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0003b	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0003e	8d 95 23 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00044	52		 push	 edx
  00045	8b 4d ec	 mov	 ecx, DWORD PTR __Dx$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0004d	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
  00056	83 c4 08	 add	 esp, 8

; 2220 : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv217 = -248						; size = 4
tv216 = -248						; size = 4
__Ptr$ = -48						; size = 4
__Newres$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00022	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	59		 pop	 ecx
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00043	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00046	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00049	83 c8 0f	 or	 eax, 15			; 0000000fH
  0004c	89 45 dc	 mov	 DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

  0004f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00057	3b 45 dc	 cmp	 eax, DWORD PTR __Newres$[ebp]
  0005a	73 08		 jae	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0005f	89 45 dc	 mov	 DWORD PTR __Newres$[ebp], eax
  00062	eb 6a		 jmp	 SHORT $LN3@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00064	8b 45 dc	 mov	 eax, DWORD PTR __Newres$[ebp]
  00067	33 d2		 xor	 edx, edx
  00069	b9 03 00 00 00	 mov	 ecx, 3
  0006e	f7 f1		 div	 ecx
  00070	8b f0		 mov	 esi, eax
  00072	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  0007a	8b 10		 mov	 edx, DWORD PTR [eax]
  0007c	d1 ea		 shr	 edx, 1
  0007e	3b d6		 cmp	 edx, esi
  00080	77 02		 ja	 SHORT $LN4@Copy
  00082	eb 4a		 jmp	 SHORT $LN3@Copy
$LN4@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00084	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  0008c	8b 30		 mov	 esi, DWORD PTR [eax]
  0008e	d1 ee		 shr	 esi, 1
  00090	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00098	8b f8		 mov	 edi, eax
  0009a	2b fe		 sub	 edi, esi
  0009c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000a4	39 38		 cmp	 DWORD PTR [eax], edi
  000a6	77 1b		 ja	 SHORT $LN6@Copy

; 2189 : 			_Newres = this->_Myres()

  000a8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000b0	8b 30		 mov	 esi, DWORD PTR [eax]
  000b2	d1 ee		 shr	 esi, 1
  000b4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000bc	03 30		 add	 esi, DWORD PTR [eax]
  000be	89 75 dc	 mov	 DWORD PTR __Newres$[ebp], esi

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else

  000c1	eb 0b		 jmp	 SHORT $LN3@Copy
$LN6@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

  000c3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  000cb	89 45 dc	 mov	 DWORD PTR __Newres$[ebp], eax
$LN3@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN

  000ce	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  000d5	8b 45 dc	 mov	 eax, DWORD PTR __Newres$[ebp]
  000d8	83 c0 01	 add	 eax, 1
  000db	50		 push	 eax
  000dc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  000e4	8b c8		 mov	 ecx, eax
  000e6	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000eb	89 85 08 ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  000f1	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  000f7	89 4d d0	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000fa	eb 65		 jmp	 SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

  000fc	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000ff	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00102	89 45 dc	 mov	 DWORD PTR __Newres$[ebp], eax

; 2199 : 			_TRY_BEGIN

  00105	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00109	8b 45 dc	 mov	 eax, DWORD PTR __Newres$[ebp]
  0010c	83 c0 01	 add	 eax, 1
  0010f	50		 push	 eax
  00110	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  0011f	89 85 08 ff ff
	ff		 mov	 DWORD PTR tv217[ebp], eax
  00125	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR tv217[ebp]
  0012b	89 4d d0	 mov	 DWORD PTR __Ptr$[ebp], ecx
  0012e	eb 1b		 jmp	 SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00130	6a 00		 push	 0
  00132	6a 01		 push	 1
  00134	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00137	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

  0013c	6a 00		 push	 0
  0013e	6a 00		 push	 0
  00140	e8 00 00 00 00	 call	 __CxxThrowException@8

; 2204 : 			_CATCH_END

  00145	b8 00 00 00 00	 mov	 eax, $LN17@Copy
  0014a	c3		 ret	 0
$LN14@Copy:
  0014b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00152	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
  00154	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

  0015b	b8 00 00 00 00	 mov	 eax, $LN19@Copy
  00160	c3		 ret	 0
$LN12@Copy:
  00161	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00168	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
  0016a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  00171	83 7d 0c 00	 cmp	 DWORD PTR __Oldlen$[ebp], 0
  00175	76 22		 jbe	 SHORT $LN10@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  00177	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  0017a	50		 push	 eax
  0017b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00183	50		 push	 eax
  00184	8b 4d d0	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00187	51		 push	 ecx
  00188	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0018d	83 c4 04	 add	 esp, 4
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00196	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  00199	6a 00		 push	 0
  0019b	6a 01		 push	 1
  0019d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a0	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);

  001a5	8d 45 d0	 lea	 eax, DWORD PTR __Ptr$[ebp]
  001a8	50		 push	 eax
  001a9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ac	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  001b1	50		 push	 eax
  001b2	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  001b7	83 c4 04	 add	 esp, 4
  001ba	50		 push	 eax
  001bb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001be	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  001c3	8b c8		 mov	 ecx, eax
  001c5	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres() = _Newres;

  001ca	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  001d2	8b 4d dc	 mov	 ecx, DWORD PTR __Newres$[ebp]
  001d5	89 08		 mov	 DWORD PTR [eax], ecx

; 2213 : 		_Eos(_Oldlen);

  001d7	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  001da	50		 push	 eax
  001db	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001de	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

  001e3	52		 push	 edx
  001e4	8b cd		 mov	 ecx, ebp
  001e6	50		 push	 eax
  001e7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@Copy
  001ed	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001f2	58		 pop	 eax
  001f3	5a		 pop	 edx
  001f4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001f7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001fe	59		 pop	 ecx
  001ff	5f		 pop	 edi
  00200	5e		 pop	 esi
  00201	5b		 pop	 ebx
  00202	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  00208	3b ec		 cmp	 ebp, esp
  0020a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0020f	8b e5		 mov	 esp, ebp
  00211	5d		 pop	 ebp
  00212	c2 08 00	 ret	 8
  00215	0f 1f 00	 npad	 3
$LN23@Copy:
  00218	01 00 00 00	 DD	 1
  0021c	00 00 00 00	 DD	 $LN22@Copy
$LN22@Copy:
  00220	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00224	04 00 00 00	 DD	 4
  00228	00 00 00 00	 DD	 $LN20@Copy
$LN20@Copy:
  0022c	5f		 DB	 95			; 0000005fH
  0022d	50		 DB	 80			; 00000050H
  0022e	74		 DB	 116			; 00000074H
  0022f	72		 DB	 114			; 00000072H
  00230	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 04 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-252]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Max_effective_size$ = -20				; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  00030	89 45 ec	 mov	 DWORD PTR __Max_effective_size$[ebp], eax

; 2113 : 		if (_Size <= _Max_effective_size)

  00033	8b 45 0c	 mov	 eax, DWORD PTR __Size$[ebp]
  00036	3b 45 ec	 cmp	 eax, DWORD PTR __Max_effective_size$[ebp]
  00039	77 07		 ja	 SHORT $LN2@Clamp_suff

; 2114 : 			return (_Size);

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Size$[ebp]
  0003e	eb 05		 jmp	 SHORT $LN1@Clamp_suff

; 2115 : 		else

  00040	eb 03		 jmp	 SHORT $LN1@Clamp_suff
$LN2@Clamp_suff:

; 2116 : 			return (_Max_effective_size);

  00042	8b 45 ec	 mov	 eax, DWORD PTR __Max_effective_size$[ebp]
$LN1@Clamp_suff:

; 2117 : 		}

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv75 = -232						; size = 4
$T1 = -221						; size = 1
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1769 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();

  00023	0f b6 85 23 ff
	ff ff		 movzx	 eax, BYTE PTR $T1[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00033	8b c8		 mov	 ecx, eax
  00035	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
  0003a	89 45 ec	 mov	 DWORD PTR __Num$[ebp], eax

; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  0003d	83 7d ec 01	 cmp	 DWORD PTR __Num$[ebp], 1
  00041	77 0c		 ja	 SHORT $LN3@max_size
  00043	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv75[ebp], 1
  0004d	eb 0c		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  0004f	8b 45 ec	 mov	 eax, DWORD PTR __Num$[ebp]
  00052	83 e8 01	 sub	 eax, 1
  00055	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
$LN4@max_size:
  0005b	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv75[ebp]

; 1772 : 		}

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1764 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1765 : 		return (this->_Mysize());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]

; 1766 : 		}

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1742 : 		{	// return pointer to null-terminated nonmutable array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1743 : 		return (this->_Myptr());

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr

; 1744 : 		}

  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Mydata$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 1606 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00021	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1607 : 		auto _Mydata = &this->_Get_data();

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0004a	89 45 e0	 mov	 DWORD PTR __Mydata$[ebp], eax

; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

  0004d	8b 45 e0	 mov	 eax, DWORD PTR __Mydata$[ebp]
  00050	50		 push	 eax
  00051	8b 4d e0	 mov	 ecx, DWORD PTR __Mydata$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00059	50		 push	 eax
  0005a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ; std::_Wrap_alloc<std::allocator<char> >::address
  00069	8b 4d e0	 mov	 ecx, DWORD PTR __Mydata$[ebp]
  0006c	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00073	e8 00 00 00 00	 call	 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
  00078	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1609 : 		}

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Mydata$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1594 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00021	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1595 : 		auto _Mydata = &this->_Get_data();

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0004a	89 45 e0	 mov	 DWORD PTR __Mydata$[ebp], eax

; 1596 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));

  0004d	8b 45 e0	 mov	 eax, DWORD PTR __Mydata$[ebp]
  00050	50		 push	 eax
  00051	8b 4d e0	 mov	 ecx, DWORD PTR __Mydata$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00059	50		 push	 eax
  0005a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ; std::_Wrap_alloc<std::allocator<char> >::address
  00069	50		 push	 eax
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0006d	e8 00 00 00 00	 call	 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
  00072	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1597 : 		}

  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
_TEXT	SEGMENT
tv167 = -276						; size = 4
tv165 = -276						; size = 4
tv173 = -272						; size = 4
tv172 = -272						; size = 4
$T2 = -264						; size = 4
$T3 = -252						; size = 12
$T4 = -232						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__First2$ = 32						; size = 12
__Last2$ = 44						; size = 12
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00021	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 1585 : 		if (_First2 == _Last2)

  00049	8d 45 2c	 lea	 eax, DWORD PTR __Last2$[ebp]
  0004c	50		 push	 eax
  0004d	8d 4d 20	 lea	 ecx, DWORD PTR __First2$[ebp]
  00050	e8 00 00 00 00	 call	 ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
  00055	0f b6 c8	 movzx	 ecx, al
  00058	85 c9		 test	 ecx, ecx
  0005a	74 5b		 je	 SHORT $LN2@replace

; 1586 : 			erase(_First - begin(), _Last - _First);

  0005c	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0005f	50		 push	 eax
  00060	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00063	e8 00 00 00 00	 call	 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
  00068	50		 push	 eax
  00069	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0006f	51		 push	 ecx
  00070	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00078	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv172[ebp], eax
  0007e	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv172[ebp]
  00084	89 95 ec fe ff
	ff		 mov	 DWORD PTR tv165[ebp], edx
  0008a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0008e	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv165[ebp]
  00094	50		 push	 eax
  00095	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00098	e8 00 00 00 00	 call	 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
  0009d	50		 push	 eax
  0009e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  000a6	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000aa	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000b0	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ

; 1587 : 		else

  000b5	eb 6f		 jmp	 SHORT $LN3@replace
$LN2@replace:

; 1588 : 			replace(_First - begin(), _Last - _First,

  000b7	8d 45 20	 lea	 eax, DWORD PTR __First2$[ebp]
  000ba	50		 push	 eax
  000bb	8d 4d 2c	 lea	 ecx, DWORD PTR __Last2$[ebp]
  000be	e8 00 00 00 00	 call	 ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
  000c3	50		 push	 eax
  000c4	8d 4d 20	 lea	 ecx, DWORD PTR __First2$[ebp]
  000c7	e8 00 00 00 00	 call	 ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  000cc	50		 push	 eax
  000cd	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  000d0	51		 push	 ecx
  000d1	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  000d4	e8 00 00 00 00	 call	 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
  000d9	50		 push	 eax
  000da	8d 95 04 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  000e0	52		 push	 edx
  000e1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  000e9	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv173[ebp], eax
  000ef	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv173[ebp]
  000f5	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv167[ebp], eax
  000fb	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000ff	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv167[ebp]
  00105	51		 push	 ecx
  00106	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00109	e8 00 00 00 00	 call	 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
  0010e	50		 push	 eax
  0010f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  00117	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0011b	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00121	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
$LN3@replace:

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 85 f8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  0012f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00133	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00136	e8 00 00 00 00	 call	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  0013b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0013f	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00142	e8 00 00 00 00	 call	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  00147	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0014b	8d 4d 20	 lea	 ecx, DWORD PTR __First2$[ebp]
  0014e	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  00153	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0015a	8d 4d 2c	 lea	 ecx, DWORD PTR __Last2$[ebp]
  0015d	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  00162	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 1591 : 		}

  00168	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00172	59		 pop	 ecx
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5b		 pop	 ebx
  00176	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  0017c	3b ec		 cmp	 ebp, esp
  0017e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c2 30 00	 ret	 48			; 00000030H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$0:
  00000	8d 4d 2c	 lea	 ecx, DWORD PTR __Last2$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$1:
  00008	8d 4d 20	 lea	 ecx, DWORD PTR __First2$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$2:
  00010	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$3:
  00018	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$4:
  00020	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z$5:
  0002b	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00031	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__ehhandler$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z:
  00036	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003d	8b 8a e8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-280]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z
_TEXT	SEGMENT
tv68 = -229						; size = 1
__Num$ = -32						; size = 4
__Nm$ = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);

  00023	83 7d 14 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00027	74 09		 je	 SHORT $LN9@replace
  00029	c6 85 1b ff ff
	ff 01		 mov	 BYTE PTR tv68[ebp], 1
  00030	eb 07		 jmp	 SHORT $LN10@replace
$LN9@replace:
  00032	c6 85 1b ff ff
	ff 00		 mov	 BYTE PTR tv68[ebp], 0
$LN10@replace:
  00039	68 ae 05 00 00	 push	 1454			; 000005aeH
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@EADHKMNI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00043	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00046	50		 push	 eax
  00047	0f b6 8d 1b ff
	ff ff		 movzx	 ecx, BYTE PTR tv68[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 ??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z ; std::_Debug_pointer_if<char const >
  00054	83 c4 10	 add	 esp, 16			; 00000010H

; 1455 : 		if (_Inside(_Ptr))

  00057	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00063	0f b6 c8	 movzx	 ecx, al
  00066	85 c9		 test	 ecx, ecx
  00068	74 2b		 je	 SHORT $LN2@replace

; 1456 : 			return (replace(_Off, _N0, *this,

  0006a	8b 45 14	 mov	 eax, DWORD PTR __Count$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00076	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00079	2b c8		 sub	 ecx, eax
  0007b	51		 push	 ecx
  0007c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00087	51		 push	 ecx
  00088	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  00090	e9 14 01 00 00	 jmp	 $LN8@replace
$LN2@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  00095	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00098	50		 push	 eax
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);

  000a1	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
  000b1	89 45 0c	 mov	 DWORD PTR __N0$[ebp], eax

; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

  000b4	83 ce ff	 or	 esi, -1
  000b7	2b 75 14	 sub	 esi, DWORD PTR __Count$[ebp]
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  000c2	8b 00		 mov	 eax, DWORD PTR [eax]
  000c4	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]
  000c7	3b f0		 cmp	 esi, eax
  000c9	77 08		 ja	 SHORT $LN3@replace

; 1462 : 			_Xlen();	// result too long

  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN3@replace:

; 1463 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;

  000d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  000db	8b 00		 mov	 eax, DWORD PTR [eax]
  000dd	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]
  000e0	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  000e3	89 45 ec	 mov	 DWORD PTR __Nm$[ebp], eax

; 1464 : 
; 1465 : 		if (_Count < _N0)

  000e6	8b 45 14	 mov	 eax, DWORD PTR __Count$[ebp]
  000e9	3b 45 0c	 cmp	 eax, DWORD PTR __N0$[ebp]
  000ec	73 2a		 jae	 SHORT $LN4@replace

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000ee	8b 45 ec	 mov	 eax, DWORD PTR __Nm$[ebp]
  000f1	50		 push	 eax
  000f2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  000fa	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000fd	03 45 0c	 add	 eax, DWORD PTR __N0$[ebp]
  00100	50		 push	 eax
  00101	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00109	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0010c	03 45 14	 add	 eax, DWORD PTR __Count$[ebp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@replace:

; 1467 : 				this->_Myptr() + _Off + _N0,
; 1468 : 				_Nm);	// smaller hole, move tail up
; 1469 : 		const size_type _Num = this->_Mysize() + _Count - _N0;

  00118	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00120	8b 00		 mov	 eax, DWORD PTR [eax]
  00122	03 45 14	 add	 eax, DWORD PTR __Count$[ebp]
  00125	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]
  00128	89 45 e0	 mov	 DWORD PTR __Num$[ebp], eax

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  0012b	83 7d 14 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0012f	77 06		 ja	 SHORT $LN6@replace
  00131	83 7d 0c 00	 cmp	 DWORD PTR __N0$[ebp], 0
  00135	76 6f		 jbe	 SHORT $LN5@replace
$LN6@replace:
  00137	6a 00		 push	 0
  00139	8b 45 e0	 mov	 eax, DWORD PTR __Num$[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00140	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00145	0f b6 c8	 movzx	 ecx, al
  00148	85 c9		 test	 ecx, ecx
  0014a	74 5a		 je	 SHORT $LN5@replace

; 1472 : 			{	// make room and rearrange
; 1473 : 			if (_N0 < _Count)

  0014c	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  0014f	3b 45 14	 cmp	 eax, DWORD PTR __Count$[ebp]
  00152	73 2a		 jae	 SHORT $LN7@replace

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

  00154	8b 45 ec	 mov	 eax, DWORD PTR __Nm$[ebp]
  00157	50		 push	 eax
  00158	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00160	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00163	03 45 0c	 add	 eax, DWORD PTR __N0$[ebp]
  00166	50		 push	 eax
  00167	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0016f	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00172	03 45 14	 add	 eax, DWORD PTR __Count$[ebp]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0017b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@replace:

; 1475 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1476 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  0017e	8b 45 14	 mov	 eax, DWORD PTR __Count$[ebp]
  00181	50		 push	 eax
  00182	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00185	51		 push	 ecx
  00186	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00189	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0018e	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00197	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1477 : 			_Eos(_Num);

  0019a	8b 45 e0	 mov	 eax, DWORD PTR __Num$[ebp]
  0019d	50		 push	 eax
  0019e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN5@replace:

; 1478 : 			}
; 1479 : 		return (*this);

  001a6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN8@replace:

; 1480 : 		}

  001a9	5f		 pop	 edi
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx
  001ac	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  001b2	3b ec		 cmp	 ebp, esp
  001b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c2 10 00	 ret	 16			; 00000010H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT	SEGMENT
__Newsize$ = -32					; size = 4
__Nm$ = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Right$ = 16						; size = 4
__Roff$ = 20						; size = 4
__Count$ = 24						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00013	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1390 : 		_Check_offset(_Off);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1391 : 		_Right._Check_offset(_Roff);

  0002f	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
  0004b	89 45 0c	 mov	 DWORD PTR __N0$[ebp], eax

; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  0004e	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 14	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00055	51		 push	 ecx
  00056	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
  0005e	89 45 18	 mov	 DWORD PTR __Count$[ebp], eax

; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

  00061	83 ce ff	 or	 esi, -1
  00064	2b 75 18	 sub	 esi, DWORD PTR __Count$[ebp]
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]
  00074	3b f0		 cmp	 esi, eax
  00076	77 08		 ja	 SHORT $LN2@replace

; 1395 : 			_Xlen();	// result too long

  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@replace:

; 1396 : 
; 1397 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail

  00080	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]
  0008d	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  00090	89 45 ec	 mov	 DWORD PTR __Nm$[ebp], eax

; 1398 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;

  00093	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0009b	8b 00		 mov	 eax, DWORD PTR [eax]
  0009d	03 45 18	 add	 eax, DWORD PTR __Count$[ebp]
  000a0	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]
  000a3	89 45 e0	 mov	 DWORD PTR __Newsize$[ebp], eax

; 1399 : 		if (this->_Mysize() < _Newsize)

  000a6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  000ae	8b 00		 mov	 eax, DWORD PTR [eax]
  000b0	3b 45 e0	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  000b3	73 0e		 jae	 SHORT $LN3@replace

; 1400 : 			_Grow(_Newsize);

  000b5	6a 00		 push	 0
  000b7	8b 45 e0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
$LN3@replace:

; 1401 : 
; 1402 : 		if (_Count == _N0)

  000c3	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  000c6	3b 45 0c	 cmp	 eax, DWORD PTR __N0$[ebp]
  000c9	75 29		 jne	 SHORT $LN4@replace

; 1403 : 			{	// only one movement required, so _Traits::move handles any overlap
; 1404 : 			_Traits::move(this->_Myptr() + _Off,

  000cb	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  000ce	50		 push	 eax
  000cf	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  000d2	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  000d7	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  000da	50		 push	 eax
  000db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  000e3	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ef	e9 ef 01 00 00	 jmp	 $LN5@replace
$LN4@replace:

; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (this != &_Right)

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	3b 45 10	 cmp	 eax, DWORD PTR __Right$[ebp]
  000fa	74 53		 je	 SHORT $LN6@replace

; 1408 : 			{	// no overlap, just move down and copy in new stuff
; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000fc	8b 45 ec	 mov	 eax, DWORD PTR __Nm$[ebp]
  000ff	50		 push	 eax
  00100	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00108	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0010b	03 45 0c	 add	 eax, DWORD PTR __N0$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00117	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0011a	03 45 18	 add	 eax, DWORD PTR __Count$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1410 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

  00126	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  00129	50		 push	 eax
  0012a	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0012d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00132	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  00135	50		 push	 eax
  00136	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0013e	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014a	e9 94 01 00 00	 jmp	 $LN5@replace
$LN6@replace:

; 1412 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1413 : 			}
; 1414 : 		else if (_Count < _N0)

  0014f	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  00152	3b 45 0c	 cmp	 eax, DWORD PTR __N0$[ebp]
  00155	73 53		 jae	 SHORT $LN8@replace

; 1415 : 			{	// hole doesn't get larger, just copy in substring
; 1416 : 			_Traits::move(this->_Myptr() + _Off,

  00157	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  0015a	50		 push	 eax
  0015b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00163	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  00166	50		 push	 eax
  00167	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0016f	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1417 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  0017b	8b 45 ec	 mov	 eax, DWORD PTR __Nm$[ebp]
  0017e	50		 push	 eax
  0017f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00187	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0018a	03 45 0c	 add	 eax, DWORD PTR __N0$[ebp]
  0018d	50		 push	 eax
  0018e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00191	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00196	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00199	03 45 18	 add	 eax, DWORD PTR __Count$[ebp]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a5	e9 39 01 00 00	 jmp	 $LN5@replace
$LN8@replace:

; 1419 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1420 : 			}
; 1421 : 		else if (_Roff <= _Off)

  001aa	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  001ad	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  001b0	77 53		 ja	 SHORT $LN10@replace

; 1422 : 			{	// hole gets larger, substring begins before hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001b2	8b 45 ec	 mov	 eax, DWORD PTR __Nm$[ebp]
  001b5	50		 push	 eax
  001b6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b9	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  001be	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  001c1	03 45 0c	 add	 eax, DWORD PTR __N0$[ebp]
  001c4	50		 push	 eax
  001c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  001cd	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  001d0	03 45 18	 add	 eax, DWORD PTR __Count$[ebp]
  001d3	50		 push	 eax
  001d4	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,

  001dc	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  001df	50		 push	 eax
  001e0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e3	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  001e8	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  001eb	50		 push	 eax
  001ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ef	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  001f4	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  001fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00200	e9 de 00 00 00	 jmp	 $LN5@replace
$LN10@replace:

; 1426 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1427 : 			}
; 1428 : 		else if (_Off + _N0 <= _Roff)

  00205	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00208	03 45 0c	 add	 eax, DWORD PTR __N0$[ebp]
  0020b	3b 45 14	 cmp	 eax, DWORD PTR __Roff$[ebp]
  0020e	77 58		 ja	 SHORT $LN12@replace

; 1429 : 			{	// hole gets larger, substring begins after hole
; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00210	8b 45 ec	 mov	 eax, DWORD PTR __Nm$[ebp]
  00213	50		 push	 eax
  00214	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00217	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0021c	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0021f	03 45 0c	 add	 eax, DWORD PTR __N0$[ebp]
  00222	50		 push	 eax
  00223	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00226	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0022b	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0022e	03 45 18	 add	 eax, DWORD PTR __Count$[ebp]
  00231	50		 push	 eax
  00232	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00237	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1431 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1432 : 			_Traits::move(this->_Myptr() + _Off,

  0023a	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  0023d	50		 push	 eax
  0023e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00246	8b 4d 14	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00249	03 4d 18	 add	 ecx, DWORD PTR __Count$[ebp]
  0024c	2b 4d 0c	 sub	 ecx, DWORD PTR __N0$[ebp]
  0024f	03 c1		 add	 eax, ecx
  00251	50		 push	 eax
  00252	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00255	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0025a	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0025d	50		 push	 eax
  0025e	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00263	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else

  00266	eb 7b		 jmp	 SHORT $LN5@replace
$LN12@replace:

; 1437 : 			{	// hole gets larger, substring begins in hole
; 1438 : 			_Traits::move(this->_Myptr() + _Off,

  00268	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  0026b	50		 push	 eax
  0026c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0026f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00274	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  00277	50		 push	 eax
  00278	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0027b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00280	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00283	50		 push	 eax
  00284	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00289	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1439 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  0028c	8b 45 ec	 mov	 eax, DWORD PTR __Nm$[ebp]
  0028f	50		 push	 eax
  00290	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00293	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00298	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0029b	03 45 0c	 add	 eax, DWORD PTR __N0$[ebp]
  0029e	50		 push	 eax
  0029f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002a2	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  002a7	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  002aa	03 45 18	 add	 eax, DWORD PTR __Count$[ebp]
  002ad	50		 push	 eax
  002ae	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  002b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1441 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

  002b6	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  002b9	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]
  002bc	50		 push	 eax
  002bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c0	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  002c5	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  002c8	03 45 18	 add	 eax, DWORD PTR __Count$[ebp]
  002cb	50		 push	 eax
  002cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002cf	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  002d4	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  002d7	03 45 0c	 add	 eax, DWORD PTR __N0$[ebp]
  002da	50		 push	 eax
  002db	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  002e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@replace:

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

  002e3	8b 45 e0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  002e6	50		 push	 eax
  002e7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002ea	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1448 : 		return (*this);

  002ef	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN14@replace:

; 1449 : 		}

  002f2	5f		 pop	 edi
  002f3	5e		 pop	 esi
  002f4	5b		 pop	 ebx
  002f5	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  002fb	3b ec		 cmp	 ebp, esp
  002fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00302	8b e5		 mov	 esp, ebp
  00304	5d		 pop	 ebp
  00305	c2 14 00	 ret	 20			; 00000014H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -32					; size = 4
__Ptr$2 = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00013	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 : 		_Check_offset(_Off);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  0003c	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003f	77 0e		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  00041	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  0004d	eb 4a		 jmp	 SHORT $LN3@erase
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  0004f	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00053	76 44		 jbe	 SHORT $LN3@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0005d	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00060	89 45 ec	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	2b 45 0c	 sub	 eax, DWORD PTR __Count$[ebp]
  00070	89 45 e0	 mov	 DWORD PTR __Newsize$1[ebp], eax

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00073	8b 45 e0	 mov	 eax, DWORD PTR __Newsize$1[ebp]
  00076	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$2[ebp]
  0007d	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 ec	 mov	 edx, DWORD PTR __Ptr$2[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1356 : 			_Eos(_Newsize);

  0008d	8b 45 e0	 mov	 eax, DWORD PTR __Newsize$1[ebp]
  00090	50		 push	 eax
  00091	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00099	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1359 : 		}

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1341 : 		_Check_offset(_Off);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1342 : 		_Eos(_Off);

  0002f	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00032	50		 push	 eax
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1343 : 		return (*this);

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1344 : 		}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1150 : 		_Right._Check_offset(_Roff);

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  0002f	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
  0003f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00048	75 1f		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  0004a	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  0004d	03 45 10	 add	 eax, DWORD PTR __Count$[ebp]
  00050	50		 push	 eax
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00059	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0005c	51		 push	 ecx
  0005d	6a 00		 push	 0
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00067	eb 42		 jmp	 SHORT $LN3@assign
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  00069	6a 00		 push	 0
  0006b	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00077	0f b6 c8	 movzx	 ecx, al
  0007a	85 c9		 test	 ecx, ecx
  0007c	74 2d		 je	 SHORT $LN3@assign

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0007e	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0008a	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  0009f	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  000a2	50		 push	 eax
  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1162 : 		}

  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b7	3b ec		 cmp	 ebp, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1144 : 		return (assign(_Right, 0, npos));

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1024 : 		if (this != &_Right)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00029	74 4e		 je	 SHORT $LN2@operator

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
  00042	83 c4 08	 add	 esp, 8
  00045	0f b6 c0	 movzx	 eax, al
  00048	85 c0		 test	 eax, eax
  0004a	74 21		 je	 SHORT $LN3@operator
  0004c	33 c0		 xor	 eax, eax
  0004e	74 1d		 je	 SHORT $LN3@operator

; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);

  00050	6a 00		 push	 0
  00052	6a 01		 push	 1
  00054	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1030 : 				this->_Copy_alloc(_Right._Getal());

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00064	50		 push	 eax
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
$LN3@operator:

; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);

  0006d	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00070	50		 push	 eax
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@operator:

; 1034 : 			}
; 1035 : 		return (*this);

  00079	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1036 : 		}

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1017 : 		_Tidy(true);

  00042	6a 00		 push	 0
  00044	6a 01		 push	 1
  00046	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1018 : 		}

  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  0002b	83 38 10	 cmp	 DWORD PTR [eax], 16	; 00000010H
  0002e	73 2a		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00038	8b 00		 mov	 eax, DWORD PTR [eax]
  0003a	83 c0 01	 add	 eax, 1
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00046	50		 push	 eax
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00058	eb 38		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00062	50		 push	 eax
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  00071	83 c4 04	 add	 esp, 4
  00074	50		 push	 eax
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0007d	8b c8		 mov	 ecx, eax
  0007f	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 968  : 			_Right._Bx()._Ptr = pointer();

  00084	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00087	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  0008c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00092	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0009a	8b f0		 mov	 esi, eax
  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  000a4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a6	89 08		 mov	 DWORD PTR [eax], ecx

; 971  : 		this->_Myres() = _Right._Myres();

  000a8	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000ab	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000b0	8b f0		 mov	 esi, eax
  000b2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000ba	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000bc	89 08		 mov	 DWORD PTR [eax], ecx

; 972  : 		_Right._Tidy();

  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000c5	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 973  : 		}

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 928  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00021	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 929  : 		if (this != &_Right)

  00042	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00048	0f 84 af 00 00
	00		 je	 $LN2@operator

; 930  : 			{	// different, assign it
; 931  : 			_Tidy(true);

  0004e	6a 00		 push	 0
  00050	6a 01		 push	 1
  00052	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 932  : 
; 933  : 			if (_Alty::propagate_on_container_move_assignment::value
; 934  : 				&& this->_Getal() != _Right._Getal())

  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	85 c0		 test	 eax, eax
  00061	74 32		 je	 SHORT $LN3@operator
  00063	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00066	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0006b	50		 push	 eax
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
  0007a	83 c4 08	 add	 esp, 8
  0007d	0f b6 c0	 movzx	 eax, al
  00080	85 c0		 test	 eax, eax
  00082	74 11		 je	 SHORT $LN3@operator

; 935  : 				this->_Move_alloc(_Right._Getal());

  00084	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00087	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0008c	50		 push	 eax
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
$LN3@operator:

; 936  : 
; 937  : 			if (this->_Getal() != _Right._Getal())

  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00098	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0009d	50		 push	 eax
  0009e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
  000ac	83 c4 08	 add	 esp, 8
  000af	0f b6 c0	 movzx	 eax, al
  000b2	85 c0		 test	 eax, eax
  000b4	74 32		 je	 SHORT $LN4@operator

; 938  : 				assign(_Right.begin(), _Right.end());

  000b6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000b9	8b c4		 mov	 eax, esp
  000bb	89 a5 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  000c1	50		 push	 eax
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000c5	e8 00 00 00 00	 call	 ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
  000ca	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000cd	8b cc		 mov	 ecx, esp
  000cf	89 a5 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], esp
  000d5	51		 push	 ecx
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000d9	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >

; 939  : 			else

  000e6	eb 15		 jmp	 SHORT $LN2@operator
$LN4@operator:

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  000e8	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  000f1	83 c4 04	 add	 esp, 4
  000f4	50		 push	 eax
  000f5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN2@operator:

; 941  : 			}
; 942  : 		return (*this);

  000fd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]

; 943  : 		}

  00100	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00103	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010a	59		 pop	 ecx
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00114	3b ec		 cmp	 ebp, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 0c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-244]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 910  : 		: _Mybase(_STD move(_Right._Getal()))

  00042	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
  00050	83 c4 04	 add	 esp, 4
  00053	50		 push	 eax
  00054	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>

; 912  : 		_Tidy();

  0005c	6a 00		 push	 0
  0005e	6a 00		 push	 0
  00060	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00068	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00071	83 c4 04	 add	 esp, 4
  00074	50		 push	 eax
  00075	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 914  : 		}

  0007d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 794  : 		{	// construct empty string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 793  : 		: _Mybase()

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >

; 795  : 		_Tidy();

  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 796  : 		}

  00056	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00021	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())

  00042	0f b6 85 23 ff
	ff ff		 movzx	 eax, BYTE PTR $T3[ebp]
  00049	50		 push	 eax
  0004a	8d 8d 17 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00050	51		 push	 ecx
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 781  : 		_Tidy();

  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 782  : 		assign(_Right, 0, npos);

  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
  00081	50		 push	 eax
  00082	6a 00		 push	 0
  00084	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00087	51		 push	 ecx
  00088	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a4	59		 pop	 ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000ae	3b ec		 cmp	 ebp, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 0c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-244]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 320  : 		return (_Myval2);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 321  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 315  : 		return (_Myval2);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 316  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		{	// return const reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 300  : 		return (*this);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 301  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 295  : 		return (*this);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 296  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 733  : 		{	// return reference to _Myres

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 734  : 		return (_Get_data()._Myres);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0002b	83 c0 18	 add	 eax, 24			; 00000018H

; 735  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 728  : 		{	// return const reference to _Mysize

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 729  : 		return (_Get_data()._Mysize);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0002b	83 c0 14	 add	 eax, 20			; 00000014H

; 730  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 723  : 		{	// return reference to _Mysize

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 724  : 		return (_Get_data()._Mysize);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0002b	83 c0 14	 add	 eax, 20			; 00000014H

; 725  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 713  : 		{	// return reference to _Bx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 714  : 		return (_Get_data()._Bx);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0002b	83 c0 04	 add	 eax, 4

; 715  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 706  : 		{	// return const reference to _String_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 707  : 		return (_Mypair._Get_second());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second

; 708  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 701  : 		{	// return reference to _String_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 702  : 		return (_Mypair._Get_second());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second

; 703  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 696  : 		{	// return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 697  : 		return (_Mypair._Get_first());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 698  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 691  : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 692  : 		return (_Mypair._Get_first());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 693  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 681  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 682  : 		_Get_data()._Orphan_all();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0002b	8b c8		 mov	 ecx, eax
  0002d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 683  : 		}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy, COMDAT
; _this$ = ecx

; 670  : 		{	// return reference to _Myproxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 671  : 		return (_Get_data()._Myproxy);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data

; 672  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 655  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 656  : 		typename _Alty::template rebind<_Container_proxy>::other
; 657  : 			_Alproxy(_Getal());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0002b	50		 push	 eax
  0002c	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$?0AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > &>

; 658  : 		_Orphan_all();

  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all

; 659  : 		_Alproxy.destroy(_Myproxy());

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	50		 push	 eax
  00047	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0004a	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 660  : 		_Alproxy.deallocate(_Alproxy.address(*_Myproxy()), 1);

  0004f	6a 01		 push	 1
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	50		 push	 eax
  0005c	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0005f	e8 00 00 00 00	 call	 ?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
  00064	50		 push	 eax
  00065	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00068	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 661  : 		_Myproxy() = 0;

  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00075	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 662  : 		}

  0007b	52		 push	 edx
  0007c	8b cd		 mov	 ecx, ebp
  0007e	50		 push	 eax
  0007f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Free_proxy
  00085	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008a	58		 pop	 eax
  0008b	5a		 pop	 edx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN5@Free_proxy:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN4@Free_proxy
$LN4@Free_proxy:
  000a8	ef ff ff ff	 DD	 -17			; ffffffefH
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN3@Free_proxy
$LN3@Free_proxy:
  000b4	5f		 DB	 95			; 0000005fH
  000b5	41		 DB	 65			; 00000041H
  000b6	6c		 DB	 108			; 0000006cH
  000b7	70		 DB	 112			; 00000070H
  000b8	72		 DB	 114			; 00000072H
  000b9	6f		 DB	 111			; 0000006fH
  000ba	78		 DB	 120			; 00000078H
  000bb	79		 DB	 121			; 00000079H
  000bc	00		 DB	 0
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 646  : 		{	// construct proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 647  : 		typename _Alty::template rebind<_Container_proxy>::other
; 648  : 			_Alproxy(_Getal());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0002b	50		 push	 eax
  0002c	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$?0AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > &>

; 649  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

  00034	6a 01		 push	 1
  00036	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00039	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00044	83 c4 04	 add	 esp, 4
  00047	8b f0		 mov	 esi, eax
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00051	89 30		 mov	 DWORD PTR [eax], esi

; 650  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());

  00053	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00059	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy
  0005e	50		 push	 eax
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00067	8b 00		 mov	 eax, DWORD PTR [eax]
  00069	50		 push	 eax
  0006a	8d 4d ef	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0006d	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 651  : 		_Myproxy()->_Mycont = &_Get_data();

  00072	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0007a	8b f0		 mov	 esi, eax
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
  00086	89 30		 mov	 DWORD PTR [eax], esi

; 652  : 		}

  00088	52		 push	 edx
  00089	8b cd		 mov	 ecx, ebp
  0008b	50		 push	 eax
  0008c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Alloc_prox
  00092	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00097	58		 pop	 eax
  00098	5a		 pop	 edx
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000a2	3b ec		 cmp	 ebp, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
  000ad	0f 1f 00	 npad	 3
$LN5@Alloc_prox:
  000b0	01 00 00 00	 DD	 1
  000b4	00 00 00 00	 DD	 $LN4@Alloc_prox
$LN4@Alloc_prox:
  000b8	ef ff ff ff	 DD	 -17			; ffffffefH
  000bc	01 00 00 00	 DD	 1
  000c0	00 00 00 00	 DD	 $LN3@Alloc_prox
$LN3@Alloc_prox:
  000c4	5f		 DB	 95			; 0000005fH
  000c5	41		 DB	 65			; 00000041H
  000c6	6c		 DB	 108			; 0000006cH
  000c7	70		 DB	 112			; 00000070H
  000c8	72		 DB	 114			; 00000072H
  000c9	6f		 DB	 111			; 0000006fH
  000ca	78		 DB	 120			; 00000078H
  000cb	79		 DB	 121			; 00000079H
  000cc	00		 DB	 0
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 639  : 		{	// replace old allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 640  : 		_Free_proxy();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 641  : 		_Pocma(_Getal(), _Al);

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
  0003d	83 c4 08	 add	 esp, 8

; 642  : 		_Alloc_proxy();

  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 643  : 		}

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 632  : 		{	// replace old allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 633  : 		_Free_proxy();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 634  : 		_Pocca(_Getal(), _Al);

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
  0003d	83 c4 08	 add	 esp, 8

; 635  : 		_Alloc_proxy();

  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 636  : 		}

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 627  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 		_Free_proxy();

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 629  : 		}

  0004a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 613  : 		{	// default construct allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00021	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 612  : 		: _Mypair(_Zero_then_variadic_args_t())

  00042	0f b6 85 23 ff
	ff ff		 movzx	 eax, BYTE PTR $T2[ebp]
  00049	50		 push	 eax
  0004a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
  00052	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 614  : 		_Alloc_proxy();

  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 615  : 		}

  00061	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00068	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 582  : 		{	// determine current pointer to buffer for nonmutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 583  : 		return (_Get_data()._Myptr());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0002b	8b c8		 mov	 ecx, eax
  0002d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 584  : 		}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 577  : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Get_data()._Myptr());

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0002b	8b c8		 mov	 ecx, eax
  0002d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 579  : 		}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 04	 add	 ecx, 4
  00029	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 533  : 			{	// user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 534  : 			}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 528  : 		_Bxty()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 520  : 		{	// determine current pointer to buffer for nonmutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0002a	72 17		 jb	 SHORT $LN3@Myptr
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00038	83 c4 04	 add	 esp, 4
  0003b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00041	eb 0c		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 04	 add	 eax, 4
  00049	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0004f	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 513  : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0002a	72 17		 jb	 SHORT $LN3@Myptr
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00038	83 c4 04	 add	 esp, 4
  0003b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00041	eb 0c		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 04	 add	 eax, 4
  00049	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0004f	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 498  : 		{	// initialize values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 495  : 		: _Bx(),

  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 c1 04	 add	 ecx, 4
  00057	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 496  : 		_Mysize(0),

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 497  : 		_Myres(0)

  00066	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00069	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 499  : 		}

  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00077	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00084	59		 pop	 ecx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12
__ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1007 : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
  0002c	83 c4 04	 add	 esp, 4

; 1009 : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 988  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 976  : 		return (_Mybase::allocate(_Count));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 977  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 962  : 		{	// assign by moving

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
  0002c	83 c4 04	 add	 esp, 4

; 964  : 		return (*this);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 965  : 		}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 946  : 		{	// construct by moving

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 945  : 		: _Mybase(_STD move(_Right))

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>

; 947  : 		}

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 936  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 935  : 		: _Mybase()

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>

; 937  : 		}

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ; std::pointer_traits<char *>::pointer_to
  0002c	83 c4 04	 add	 esp, 4

; 927  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::address
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	8d 8d 2f ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
  00033	83 c4 08	 add	 esp, 8
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
  0003f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 875  : 		return (_Al);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 868  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 869  : 		return (_Al.max_size());

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00021	e8 00 00 00 00	 call	 ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size

; 870  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 748  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00023	83 c8 ff	 or	 eax, -1

; 750  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00023	6a 01		 push	 1
  00025	6a 01		 push	 1
  00027	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 726  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00023	6a 01		 push	 1
  00025	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 721  : 		}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 703  : 	allocator(const allocator<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 699  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr_container$1 = -44					; size = 4
__Ptr_ptr$2 = -32					; size = 4
__Ptr_user$3 = -20					; size = 4
__User_size$ = -8					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  0001e	83 c8 ff	 or	 eax, -1
  00021	33 d2		 xor	 edx, edx
  00023	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  00026	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  00029	76 6e		 jbe	 SHORT $LN2@Deallocate
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@
  00030	85 c0		 test	 eax, eax
  00032	74 04		 je	 SHORT $LN10@Deallocate
  00034	33 c9		 xor	 ecx, ecx
  00036	75 35		 jne	 SHORT $LN11@Deallocate
$LN10@Deallocate:
  00038	8b f4		 mov	 esi, esp
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00044	6a 00		 push	 0
  00046	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  0004c	83 c2 02	 add	 edx, 2
  0004f	52		 push	 edx
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00055	6a 02		 push	 2
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0005d	83 c4 18	 add	 esp, 24			; 00000018H
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	83 f8 01	 cmp	 eax, 1
  0006a	75 01		 jne	 SHORT $LN11@Deallocate
  0006c	cc		 int	 3
$LN11@Deallocate:
  0006d	8b f4		 mov	 esi, esp
  0006f	6a 00		 push	 0
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  00076	83 c0 02	 add	 eax, 2
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0008f	83 c4 14	 add	 esp, 20			; 00000014H
  00092	3b f4		 cmp	 esi, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0009c	0f af 45 10	 imul	 eax, DWORD PTR __Sz$[ebp]
  000a0	89 45 f8	 mov	 DWORD PTR __User_size$[ebp], eax

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  000a3	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR __User_size$[ebp], 4096 ; 00001000H
  000aa	0f 82 7d 02 00
	00		 jb	 $LN3@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);

  000b0	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000b3	89 45 ec	 mov	 DWORD PTR __Ptr_user$3[ebp], eax

; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  000b6	8b 45 ec	 mov	 eax, DWORD PTR __Ptr_user$3[ebp]
  000b9	83 e0 1f	 and	 eax, 31			; 0000001fH
  000bc	74 6e		 je	 SHORT $LN4@Deallocate
  000be	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@
  000c3	85 c0		 test	 eax, eax
  000c5	74 04		 je	 SHORT $LN12@Deallocate
  000c7	33 c9		 xor	 ecx, ecx
  000c9	75 35		 jne	 SHORT $LN13@Deallocate
$LN12@Deallocate:
  000cb	8b f4		 mov	 esi, esp
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  000d7	6a 00		 push	 0
  000d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  000df	83 c2 08	 add	 edx, 8
  000e2	52		 push	 edx
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000e8	6a 02		 push	 2
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  000f0	83 c4 18	 add	 esp, 24			; 00000018H
  000f3	3b f4		 cmp	 esi, esp
  000f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fa	83 f8 01	 cmp	 eax, 1
  000fd	75 01		 jne	 SHORT $LN13@Deallocate
  000ff	cc		 int	 3
$LN13@Deallocate:
  00100	8b f4		 mov	 esi, esp
  00102	6a 00		 push	 0
  00104	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  00109	83 c0 08	 add	 eax, 8
  0010c	50		 push	 eax
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00122	83 c4 14	 add	 esp, 20			; 00000014H
  00125	3b f4		 cmp	 esi, esp
  00127	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@Deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);

  0012c	8b 45 ec	 mov	 eax, DWORD PTR __Ptr_user$3[ebp]
  0012f	83 e8 04	 sub	 eax, 4
  00132	89 45 e0	 mov	 DWORD PTR __Ptr_ptr$2[ebp], eax

; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00135	8b 45 e0	 mov	 eax, DWORD PTR __Ptr_ptr$2[ebp]
  00138	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013a	89 4d d4	 mov	 DWORD PTR __Ptr_container$1[ebp], ecx

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0013d	b8 04 00 00 00	 mov	 eax, 4
  00142	6b c8 ff	 imul	 ecx, eax, -1
  00145	8b 55 e0	 mov	 edx, DWORD PTR __Ptr_ptr$2[ebp]
  00148	81 3c 0a fa fa
	fa fa		 cmp	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH
  0014f	74 6e		 je	 SHORT $LN5@Deallocate
  00151	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@
  00156	85 c0		 test	 eax, eax
  00158	74 04		 je	 SHORT $LN14@Deallocate
  0015a	33 c9		 xor	 ecx, ecx
  0015c	75 35		 jne	 SHORT $LN15@Deallocate
$LN14@Deallocate:
  0015e	8b f4		 mov	 esi, esp
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@
  00165	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0016a	6a 00		 push	 0
  0016c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  00172	83 c2 12	 add	 edx, 18			; 00000012H
  00175	52		 push	 edx
  00176	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0017b	6a 02		 push	 2
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00183	83 c4 18	 add	 esp, 24			; 00000018H
  00186	3b f4		 cmp	 esi, esp
  00188	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018d	83 f8 01	 cmp	 eax, 1
  00190	75 01		 jne	 SHORT $LN15@Deallocate
  00192	cc		 int	 3
$LN15@Deallocate:
  00193	8b f4		 mov	 esi, esp
  00195	6a 00		 push	 0
  00197	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  0019c	83 c0 12	 add	 eax, 18			; 00000012H
  0019f	50		 push	 eax
  001a0	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  001b5	83 c4 14	 add	 esp, 20			; 00000014H
  001b8	3b f4		 cmp	 esi, esp
  001ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@Deallocate:

; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  001bf	8b 45 d4	 mov	 eax, DWORD PTR __Ptr_container$1[ebp]
  001c2	3b 45 ec	 cmp	 eax, DWORD PTR __Ptr_user$3[ebp]
  001c5	72 6e		 jb	 SHORT $LN6@Deallocate
  001c7	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@
  001cc	85 c0		 test	 eax, eax
  001ce	74 04		 je	 SHORT $LN16@Deallocate
  001d0	33 c9		 xor	 ecx, ecx
  001d2	75 35		 jne	 SHORT $LN17@Deallocate
$LN16@Deallocate:
  001d4	8b f4		 mov	 esi, esp
  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
  001db	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  001e0	6a 00		 push	 0
  001e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  001e8	83 c2 16	 add	 edx, 22			; 00000016H
  001eb	52		 push	 edx
  001ec	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  001f1	6a 02		 push	 2
  001f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  001f9	83 c4 18	 add	 esp, 24			; 00000018H
  001fc	3b f4		 cmp	 esi, esp
  001fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00203	83 f8 01	 cmp	 eax, 1
  00206	75 01		 jne	 SHORT $LN17@Deallocate
  00208	cc		 int	 3
$LN17@Deallocate:
  00209	8b f4		 mov	 esi, esp
  0020b	6a 00		 push	 0
  0020d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  00212	83 c0 16	 add	 eax, 22			; 00000016H
  00215	50		 push	 eax
  00216	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0022b	83 c4 14	 add	 esp, 20			; 00000014H
  0022e	3b f4		 cmp	 esi, esp
  00230	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)

  00235	8b 45 ec	 mov	 eax, DWORD PTR __Ptr_user$3[ebp]
  00238	2b 45 d4	 sub	 eax, DWORD PTR __Ptr_container$1[ebp]
  0023b	83 f8 08	 cmp	 eax, 8
  0023e	73 6e		 jae	 SHORT $LN7@Deallocate
  00240	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@
  00245	85 c0		 test	 eax, eax
  00247	74 04		 je	 SHORT $LN18@Deallocate
  00249	33 c9		 xor	 ecx, ecx
  0024b	75 35		 jne	 SHORT $LN19@Deallocate
$LN18@Deallocate:
  0024d	8b f4		 mov	 esi, esp
  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@
  00254	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00259	6a 00		 push	 0
  0025b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  00261	83 c2 1a	 add	 edx, 26			; 0000001aH
  00264	52		 push	 edx
  00265	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0026a	6a 02		 push	 2
  0026c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00272	83 c4 18	 add	 esp, 24			; 00000018H
  00275	3b f4		 cmp	 esi, esp
  00277	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0027c	83 f8 01	 cmp	 eax, 1
  0027f	75 01		 jne	 SHORT $LN19@Deallocate
  00281	cc		 int	 3
$LN19@Deallocate:
  00282	8b f4		 mov	 esi, esp
  00284	6a 00		 push	 0
  00286	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  0028b	83 c0 1a	 add	 eax, 26			; 0000001aH
  0028e	50		 push	 eax
  0028f	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00294	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00299	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  0029e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  002a4	83 c4 14	 add	 esp, 20			; 00000014H
  002a7	3b f4		 cmp	 esi, esp
  002a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@Deallocate:

; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  002ae	8b 45 ec	 mov	 eax, DWORD PTR __Ptr_user$3[ebp]
  002b1	2b 45 d4	 sub	 eax, DWORD PTR __Ptr_container$1[ebp]
  002b4	83 f8 27	 cmp	 eax, 39			; 00000027H
  002b7	76 6e		 jbe	 SHORT $LN8@Deallocate
  002b9	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@
  002be	85 c0		 test	 eax, eax
  002c0	74 04		 je	 SHORT $LN20@Deallocate
  002c2	33 c9		 xor	 ecx, ecx
  002c4	75 35		 jne	 SHORT $LN21@Deallocate
$LN20@Deallocate:
  002c6	8b f4		 mov	 esi, esp
  002c8	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@
  002cd	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  002d2	6a 00		 push	 0
  002d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  002da	83 c2 22	 add	 edx, 34			; 00000022H
  002dd	52		 push	 edx
  002de	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  002e3	6a 02		 push	 2
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  002eb	83 c4 18	 add	 esp, 24			; 00000018H
  002ee	3b f4		 cmp	 esi, esp
  002f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002f5	83 f8 01	 cmp	 eax, 1
  002f8	75 01		 jne	 SHORT $LN21@Deallocate
  002fa	cc		 int	 3
$LN21@Deallocate:
  002fb	8b f4		 mov	 esi, esp
  002fd	6a 00		 push	 0
  002ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
  00304	83 c0 22	 add	 eax, 34			; 00000022H
  00307	50		 push	 eax
  00308	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0030d	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00312	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  00317	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0031d	83 c4 14	 add	 esp, 20			; 00000014H
  00320	3b f4		 cmp	 esi, esp
  00322	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00327	8b 45 d4	 mov	 eax, DWORD PTR __Ptr_container$1[ebp]
  0032a	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  0032d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00330	50		 push	 eax
  00331	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00336	83 c4 04	 add	 esp, 4

; 133  : 	}

  00339	5f		 pop	 edi
  0033a	5e		 pop	 esi
  0033b	5b		 pop	 ebx
  0033c	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00342	3b ec		 cmp	 ebp, esp
  00344	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00349	8b e5		 mov	 esp, ebp
  0034b	5d		 pop	 ebp
  0034c	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Ptr_container$1 = -44					; size = 4
__Block_size$2 = -32					; size = 4
__User_size$ = -20					; size = 4
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 49   : 	void *_Ptr = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 50   : 
; 51   : 	if (_Count == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00029	75 08		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  0002b	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	e9 9c 01 00 00	 jmp	 $LN9@Allocate
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  00033	83 c8 ff	 or	 eax, -1
  00036	33 d2		 xor	 edx, edx
  00038	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  0003b	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003e	73 0f		 jae	 SHORT $LN3@Allocate

; 56   : 		_Xbad_alloc();	// report no memory

  00040	8b f4		 mov	 esi, esp
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

  0004f	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00052	0f af 45 0c	 imul	 eax, DWORD PTR __Sz$[ebp]
  00056	89 45 ec	 mov	 DWORD PTR __User_size$[ebp], eax

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00059	0f b6 45 10	 movzx	 eax, BYTE PTR __Try_aligned_allocation$[ebp]
  0005d	85 c0		 test	 eax, eax
  0005f	0f 84 e4 00 00
	00		 je	 $LN4@Allocate
  00065	81 7d ec 00 10
	00 00		 cmp	 DWORD PTR __User_size$[ebp], 4096 ; 00001000H
  0006c	0f 82 d7 00 00
	00		 jb	 $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00072	8b 45 ec	 mov	 eax, DWORD PTR __User_size$[ebp]
  00075	83 c0 27	 add	 eax, 39			; 00000027H
  00078	89 45 e0	 mov	 DWORD PTR __Block_size$2[ebp], eax

; 66   : 		if (_Block_size <= _User_size)

  0007b	8b 45 e0	 mov	 eax, DWORD PTR __Block_size$2[ebp]
  0007e	3b 45 ec	 cmp	 eax, DWORD PTR __User_size$[ebp]
  00081	77 0f		 ja	 SHORT $LN6@Allocate

; 67   : 			_Xbad_alloc();	// report no memory

  00083	8b f4		 mov	 esi, esp
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0008b	3b f4		 cmp	 esi, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@Allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00092	8b 45 e0	 mov	 eax, DWORD PTR __Block_size$2[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 d4	 mov	 DWORD PTR __Ptr_container$1[ebp], eax

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  000a1	83 7d d4 00	 cmp	 DWORD PTR __Ptr_container$1[ebp], 0
  000a5	75 6e		 jne	 SHORT $LN7@Allocate
  000a7	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@
  000ac	85 c0		 test	 eax, eax
  000ae	74 04		 je	 SHORT $LN10@Allocate
  000b0	33 c9		 xor	 ecx, ecx
  000b2	75 35		 jne	 SHORT $LN11@Allocate
$LN10@Allocate:
  000b4	8b f4		 mov	 esi, esp
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  000c0	6a 00		 push	 0
  000c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA
  000c8	83 c2 16	 add	 edx, 22			; 00000016H
  000cb	52		 push	 edx
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000d1	6a 02		 push	 2
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  000d9	83 c4 18	 add	 esp, 24			; 00000018H
  000dc	3b f4		 cmp	 esi, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e3	83 f8 01	 cmp	 eax, 1
  000e6	75 01		 jne	 SHORT $LN11@Allocate
  000e8	cc		 int	 3
$LN11@Allocate:
  000e9	8b f4		 mov	 esi, esp
  000eb	6a 00		 push	 0
  000ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA
  000f2	83 c0 16	 add	 eax, 22			; 00000016H
  000f5	50		 push	 eax
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0010b	83 c4 14	 add	 esp, 20			; 00000014H
  0010e	3b f4		 cmp	 esi, esp
  00110	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@Allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00115	8b 45 d4	 mov	 eax, DWORD PTR __Ptr_container$1[ebp]
  00118	83 c0 27	 add	 eax, 39			; 00000027H
  0011b	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0011e	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00121	b8 04 00 00 00	 mov	 eax, 4
  00126	6b c8 ff	 imul	 ecx, eax, -1
  00129	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0012c	8b 45 d4	 mov	 eax, DWORD PTR __Ptr_container$1[ebp]
  0012f	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;

  00132	b8 04 00 00 00	 mov	 eax, 4
  00137	6b c8 fe	 imul	 ecx, eax, -2
  0013a	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0013d	c7 04 0a fa fa
	fa fa		 mov	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH

; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else

  00144	e9 83 00 00 00	 jmp	 $LN5@Allocate
$LN4@Allocate:

; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  00149	8b 45 ec	 mov	 eax, DWORD PTR __User_size$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00152	83 c4 04	 add	 esp, 4
  00155	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00158	83 7d f8 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0015c	75 6e		 jne	 SHORT $LN5@Allocate
  0015e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@
  00163	85 c0		 test	 eax, eax
  00165	74 04		 je	 SHORT $LN12@Allocate
  00167	33 c9		 xor	 ecx, ecx
  00169	75 35		 jne	 SHORT $LN13@Allocate
$LN12@Allocate:
  0016b	8b f4		 mov	 esi, esp
  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00177	6a 00		 push	 0
  00179	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA
  0017f	83 c2 24	 add	 edx, 36			; 00000024H
  00182	52		 push	 edx
  00183	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00188	6a 02		 push	 2
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00190	83 c4 18	 add	 esp, 24			; 00000018H
  00193	3b f4		 cmp	 esi, esp
  00195	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019a	83 f8 01	 cmp	 eax, 1
  0019d	75 01		 jne	 SHORT $LN13@Allocate
  0019f	cc		 int	 3
$LN13@Allocate:
  001a0	8b f4		 mov	 esi, esp
  001a2	6a 00		 push	 0
  001a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA
  001a9	83 c0 24	 add	 eax, 36			; 00000024H
  001ac	50		 push	 eax
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  001b7	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  001c2	83 c4 14	 add	 esp, 20			; 00000014H
  001c5	3b f4		 cmp	 esi, esp
  001c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@Allocate:

; 85   : 		}
; 86   : 	return (_Ptr);

  001cc	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN9@Allocate:

; 87   : 	}

  001cf	5f		 pop	 edi
  001d0	5e		 pop	 esi
  001d1	5b		 pop	 ebx
  001d2	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  001d8	3b ec		 cmp	 ebp, esp
  001da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_me@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT
; _this$ = ecx

; 193  : 		{	// cut ties with parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 194  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 195  : 		if (_Myproxy != 0)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	74 67		 je	 SHORT $LN1@Orphan_me

; 196  : 			{	// adopted, remove self from list
; 197  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	83 c1 04	 add	 ecx, 4
  00033	89 4d ec	 mov	 DWORD PTR __Pnext$1[ebp], ecx
$LN2@Orphan_me:

; 198  : 			while (*_Pnext != 0 && *_Pnext != this)

  00036	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00039	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003c	74 17		 je	 SHORT $LN3@Orphan_me
  0003e	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	3b 4d f8	 cmp	 ecx, DWORD PTR _this$[ebp]
  00046	74 0d		 je	 SHORT $LN3@Orphan_me

; 199  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  00048	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	83 c1 04	 add	 ecx, 4
  00050	89 4d ec	 mov	 DWORD PTR __Pnext$1[ebp], ecx
  00053	eb e1		 jmp	 SHORT $LN2@Orphan_me
$LN3@Orphan_me:

; 200  : 
; 201  : 			if (*_Pnext == 0)

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00058	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005b	75 21		 jne	 SHORT $LN5@Orphan_me

; 202  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  0005d	8b f4		 mov	 esi, esp
  0005f	68 ca 00 00 00	 push	 202			; 000000caH
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	3b f4		 cmp	 esi, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@Orphan_me:

; 203  : 			*_Pnext = _Mynextiter;

  0007e	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00081	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00087	89 10		 mov	 DWORD PTR [eax], edx

; 204  : 			_Myproxy = 0;

  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Orphan_me:

; 205  : 			}
; 206  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 207  : 		}

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
?_Orphan_me@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ PROC	; std::_Iterator_base12::_Getpnext, COMDAT
; _this$ = ecx

; 188  : 		{	// get address of remaining iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 		return (&_Mynextiter);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c0 04	 add	 eax, 4

; 190  : 		}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ENDP	; std::_Iterator_base12::_Getpnext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 183  : 		{	// get owning container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	75 0c		 jne	 SHORT $LN3@Getcont
  0002b	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00035	eb 0d		 jmp	 SHORT $LN4@Getcont
$LN3@Getcont:
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	8b 02		 mov	 eax, DWORD PTR [edx]
  0003e	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN4@Getcont:
  00044	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]

; 185  : 		}

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Clrcont@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Clrcont@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Clrcont, COMDAT
; _this$ = ecx

; 178  : 		{	// disown owning container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 179  : 		_Myproxy = 0;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 180  : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_Clrcont@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Clrcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$2 = -56						; size = 4
__Parent_proxy$3 = -44					; size = 4
__Lock$4 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 149  : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00021	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 150  : 		if (_Parent == 0)

  00042	83 7d 08 00	 cmp	 DWORD PTR __Parent$[ebp], 0
  00046	75 3e		 jne	 SHORT $LN2@Adopt

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);

  00048	8b f4		 mov	 esi, esp
  0004a	6a 03		 push	 3
  0004c	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 154  : 			_Orphan_me();

  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}

  0006b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00072	8b f4		 mov	 esi, esp
  00074	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 157  : 		else

  00084	eb 6b		 jmp	 SHORT $LN1@Adopt
$LN2@Adopt:

; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

  00086	8b 45 08	 mov	 eax, DWORD PTR __Parent$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	89 4d d4	 mov	 DWORD PTR __Parent_proxy$3[ebp], ecx

; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)

  0008e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00091	8b 08		 mov	 ecx, DWORD PTR [eax]
  00093	3b 4d d4	 cmp	 ecx, DWORD PTR __Parent_proxy$3[ebp]
  00096	74 59		 je	 SHORT $LN1@Adopt

; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);

  00098	8b f4		 mov	 esi, esp
  0009a	6a 03		 push	 3
  0009c	8d 4d c8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  000a5	3b f4		 cmp	 esi, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 165  : 				_Orphan_me();

  000b3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;

  000bb	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 4d d4	 mov	 ecx, DWORD PTR __Parent_proxy$3[ebp]
  000c1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c4	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 167  : 				_Parent_proxy->_Myfirstiter = this;

  000c7	8b 45 d4	 mov	 eax, DWORD PTR __Parent_proxy$3[ebp]
  000ca	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 168  : 				_Myproxy = _Parent_proxy;

  000d0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	8b 4d d4	 mov	 ecx, DWORD PTR __Parent_proxy$3[ebp]
  000d6	89 08		 mov	 DWORD PTR [eax], ecx

; 169  : 				}

  000d8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000df	8b f4		 mov	 esi, esp
  000e1	8d 4d c8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000ea	3b f4		 cmp	 esi, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Adopt:

; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;
; 173  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 174  : 			}
; 175  : 		}

  000f1	52		 push	 edx
  000f2	8b cd		 mov	 ecx, ebp
  000f4	50		 push	 eax
  000f5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@Adopt
  000fb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00100	58		 pop	 eax
  00101	5a		 pop	 edx
  00102	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00105	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010c	59		 pop	 ecx
  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx
  00110	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  00116	3b ec		 cmp	 ebp, esp
  00118	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 04 00	 ret	 4
  00123	90		 npad	 1
$LN12@Adopt:
  00124	02 00 00 00	 DD	 2
  00128	00 00 00 00	 DD	 $LN11@Adopt
$LN11@Adopt:
  0012c	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00130	04 00 00 00	 DD	 4
  00134	00 00 00 00	 DD	 $LN8@Adopt
  00138	c8 ff ff ff	 DD	 -56			; ffffffc8H
  0013c	04 00 00 00	 DD	 4
  00140	00 00 00 00	 DD	 $LN9@Adopt
$LN9@Adopt:
  00144	5f		 DB	 95			; 0000005fH
  00145	4c		 DB	 76			; 0000004cH
  00146	6f		 DB	 111			; 0000006fH
  00147	63		 DB	 99			; 00000063H
  00148	6b		 DB	 107			; 0000006bH
  00149	00		 DB	 0
$LN8@Adopt:
  0014a	5f		 DB	 95			; 0000005fH
  0014b	4c		 DB	 76			; 0000004cH
  0014c	6f		 DB	 111			; 0000006fH
  0014d	63		 DB	 99			; 00000063H
  0014e	6b		 DB	 107			; 0000006bH
  0014f	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1:
  00012	8b f4		 mov	 esi, esp
  00014	8d 4d c8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0001d	3b f4		 cmp	 esi, esp
  0001f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 8a 00 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-256]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 141  : 		{	// destroy the iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Iterator_base12@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00021	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 142  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 143  : 		_Lockit _Lock(_LOCK_DEBUG);

  00042	8b f4		 mov	 esi, esp
  00044	6a 03		 push	 3
  00046	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 144  : 		_Orphan_me();

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 145  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 146  : 		}

  0005e	8b f4		 mov	 esi, esp
  00060	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00069	3b f4		 cmp	 esi, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	52		 push	 edx
  00071	8b cd		 mov	 ecx, ebp
  00073	50		 push	 eax
  00074	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@Iterator_b
  0007a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007f	58		 pop	 eax
  00080	5a		 pop	 edx
  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN6@Iterator_b:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN5@Iterator_b
$LN5@Iterator_b:
  000a8	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000ac	04 00 00 00	 DD	 4
  000b0	00 00 00 00	 DD	 $LN3@Iterator_b
$LN3@Iterator_b:
  000b4	5f		 DB	 95			; 0000005fH
  000b5	4c		 DB	 76			; 0000004cH
  000b6	6f		 DB	 111			; 0000006fH
  000b7	63		 DB	 99			; 00000063H
  000b8	6b		 DB	 107			; 0000006bH
  000b9	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Iterator_base12@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Lock$2 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 124  : 		{	// assign an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00021	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

  00042	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00048	8b 10		 mov	 edx, DWORD PTR [eax]
  0004a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0004c	75 02		 jne	 SHORT $LN2@operator
  0004e	eb 56		 jmp	 SHORT $LN3@operator
$LN2@operator:

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)

  00050	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00053	83 38 00	 cmp	 DWORD PTR [eax], 0
  00056	74 12		 je	 SHORT $LN4@operator

; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

  00058	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 129  : 		else

  00068	eb 3c		 jmp	 SHORT $LN3@operator
$LN4@operator:

; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);

  0006a	8b f4		 mov	 esi, esp
  0006c	6a 03		 push	 3
  0006e	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00077	3b f4		 cmp	 esi, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 133  : 			_Orphan_me();

  00085	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}

  0008d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00094	8b f4		 mov	 esi, esp
  00096	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:

; 136  : 
; 137  : 		return (*this);

  000a6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]

; 138  : 		}

  000a9	52		 push	 edx
  000aa	8b cd		 mov	 ecx, ebp
  000ac	50		 push	 eax
  000ad	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@operator
  000b3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b8	58		 pop	 eax
  000b9	5a		 pop	 edx
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c4	59		 pop	 ecx
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000ce	3b ec		 cmp	 ebp, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 04 00	 ret	 4
  000db	90		 npad	 1
$LN11@operator:
  000dc	01 00 00 00	 DD	 1
  000e0	00 00 00 00	 DD	 $LN10@operator
$LN10@operator:
  000e4	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000e8	04 00 00 00	 DD	 4
  000ec	00 00 00 00	 DD	 $LN8@operator
$LN8@operator:
  000f0	5f		 DB	 95			; 0000005fH
  000f1	4c		 DB	 76			; 0000004cH
  000f2	6f		 DB	 111			; 0000006fH
  000f3	63		 DB	 99			; 00000063H
  000f4	6b		 DB	 107			; 0000006bH
  000f5	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 119  : 		{	// copy an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		: _Myproxy(0), _Mynextiter(0)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 120  : 		*this = _Right;

  00036	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=

; 121  : 		}

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 114  : 		{	// construct orphaned iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 115  : 		}

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -32						; size = 4
__Lock$2 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 215  : 	{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00013	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 216  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 217  : 	if (_Myproxy != 0)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	74 61		 je	 SHORT $LN1@Orphan_all

; 218  : 		{	// proxy allocated, drain it
; 219  : 		_Lockit _Lock(_LOCK_DEBUG);

  0002b	8b f4		 mov	 esi, esp
  0002d	6a 03		 push	 3
  0002f	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 220  : 
; 221  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	83 c1 04	 add	 ecx, 4
  00047	89 4d e0	 mov	 DWORD PTR __Pnext$1[ebp], ecx
  0004a	eb 0d		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 222  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  0004c	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  00054	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00057	89 02		 mov	 DWORD PTR [edx], eax
$LN4@Orphan_all:
  00059	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  0005c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005f	74 0d		 je	 SHORT $LN3@Orphan_all

; 223  : 			(*_Pnext)->_Myproxy = 0;

  00061	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0006c	eb de		 jmp	 SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 224  : 		_Myproxy->_Myfirstiter = 0;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 225  : 		}

  0007a	8b f4		 mov	 esi, esp
  0007c	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Orphan_all:

; 226  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 227  : 	}

  0008c	52		 push	 edx
  0008d	8b cd		 mov	 ecx, ebp
  0008f	50		 push	 eax
  00090	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@Orphan_all
  00096	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009b	58		 pop	 eax
  0009c	5a		 pop	 edx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
  000b1	0f 1f 00	 npad	 3
$LN10@Orphan_all:
  000b4	01 00 00 00	 DD	 1
  000b8	00 00 00 00	 DD	 $LN9@Orphan_all
$LN9@Orphan_all:
  000bc	ec ff ff ff	 DD	 -20			; ffffffecH
  000c0	04 00 00 00	 DD	 4
  000c4	00 00 00 00	 DD	 $LN8@Orphan_all
$LN8@Orphan_all:
  000c8	5f		 DB	 95			; 0000005fH
  000c9	4c		 DB	 76			; 0000004cH
  000ca	6f		 DB	 111			; 0000006fH
  000cb	63		 DB	 99			; 00000063H
  000cc	6b		 DB	 107			; 0000006bH
  000cd	00		 DB	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Container_base12::_Getpfirst, COMDAT
; _this$ = ecx

; 99   : 		{	// get address of iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 100  : 		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	75 0c		 jne	 SHORT $LN3@Getpfirst
  0002b	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00035	eb 0e		 jmp	 SHORT $LN4@Getpfirst
$LN3@Getpfirst:
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	83 c2 04	 add	 edx, 4
  0003f	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], edx
$LN4@Getpfirst:
  00045	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]

; 101  : 		}

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Container_base12::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Container_base12@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 95   : 		_Orphan_all();

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 96   : 		}

  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Container_base12@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Container_base12@std@@QAE@XZ
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 80   : 		{	// construct childless container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : 		: _Myproxy(0)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 81   : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		{	// construct from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 67   : 		: _Mycont(0), _Myfirstiter(0)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 69   : 		}

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 605  : 		{	// return end-of-file metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 606  : 		return (EOF);

  0001e	83 c8 ff	 or	 eax, -1

; 607  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 594  : 		{	// test for metacharacter equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 595  : 		return (_Left == _Right);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00028	75 0c		 jne	 SHORT $LN3@eq_int_typ
  0002a	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv65[ebp], 1
  00034	eb 0a		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  00036	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
  00040	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv65[ebp]

; 596  : 		}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 565  : 		_Left = _Right;

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00024	8a 11		 mov	 dl, BYTE PTR [ecx]
  00026	88 10		 mov	 BYTE PTR [eax], dl

; 566  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 553  : 		return (_Count == 0 ? _First1

  0001e	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00022	75 0b		 jne	 SHORT $LN3@move
  00024	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00027	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0002d	eb 24		 jmp	 SHORT $LN4@move
$LN3@move:
  0002f	8b f4		 mov	 esi, esp
  00031	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	3b f4		 cmp	 esi, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN4@move:
  00053	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 530  : 		return (_Count == 0 ? _First1

  0001e	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00022	75 0b		 jne	 SHORT $LN3@copy
  00024	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00027	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0002d	eb 1a		 jmp	 SHORT $LN4@copy
$LN3@copy:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00036	52		 push	 edx
  00037	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _memcpy
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN4@copy:
  00049	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 523  : 		return (*_First == 0 ? 0

  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00024	85 c9		 test	 ecx, ecx
  00026	75 0c		 jne	 SHORT $LN3@length
  00028	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00032	eb 12		 jmp	 SHORT $LN4@length
$LN3@length:
  00034	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _strlen
  0003d	83 c4 04	 add	 esp, 4
  00040	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN4@length:
  00046	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 93   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 94   :         return;
; 95   :     }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 88   :         (void)_Size;
; 89   :         return _Where;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File s:\chris\onedrive - uat\c++ programming ii\pete_final\pete_final\custommenu.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File s:\chris\onedrive - uat\c++ programming ii\pete_final\pete_final\custommenu.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
